———— Advance C programming - https://www.sanfoundry.com/advanced-c-programming-training/
https://pebble.gitbooks.io/learning-c-with-pebble/content/chapter10.html

Compile c program use - cc code.c -o c
./c  —> to run program 
Compile c++ program use g++ code.cpp
> ./a.out  —> to run the program
————— POINTER — READ THIS — ——— 
https://www.thegeekstuff.com/2011/12/c-pointers-fundamentals


Number system - Binary , Octal , Decimal , Hexadecimal 
To represent a number in binary you need to follow the universal rule: break down the number to a sum of exact powers of 2. 10010 = 1 * 26 + 1 * 25 + 0 * 24 + 0 * 23 + 1 * 22 + 0 * 21 + 0 * 20

The octal numeral system, or oct for short, is the base-8 number system

In the decimal system each decimal place is a power of ten.

To represent a number as a hex in the source code use the “0x”(zero x) prefix. This tells the compiler that the number is in hex. The number will be converted to its decimal representation before compilation. We use a base of 16. 100 = 6 * 16 + 4 = 6 * 161 + 4 * 160

	▪	Storage Class Specifiers
	▪	Scope of a Variable
	▪	Register, Auto, Static, Extern
	▪	Why Register Class and Practical Examples
	▪	Automatic Variables and Stack
	▪	Static Variables and Functions
	▪	True meaning of Extern
	▪	How to Use extern across Multiple Files with Examples
	▪	Best Practices for Extern Usage
	▪	Local/Block/Global Scope
	▪	Nesting of Scope
	▪	Lifetime of a Variable
	▪	Linkage of a Variable
	▪	What is Const?

————————————— File ———————————— 
fopen()     create a new file or open a existing file
fclose()    closes a file 
getc()  reads a character from a file 
putc() writes a character to a file 
fscanf()    reads a set of data from a file 
fprintf()   writes a set of data to a file 
getw() reads a integer from a file 
putw() writes a integer to a file 
fseek() set the position to desire point 
ftell() gives current position in the file 
rewind() set the position to the beginning point 

————————— ————— 
Enumeration - this is just a key value pair db. Where values are in code and key are internal to complier 
enum mydbname { value1, value2 …} ;


#include <stdio.h>
enum State {WORKING = 0, FAILED, FREEZED};
enum State currState = 2;
 
enum State FindState() {
    return currState;
}
 
int main() {
   (FindState() == WORKING)? printf("WORKING"): printf("NOT WORKING");
   return 0;
}
— output — —— 
NOT WORKING
—— another example. 
#include <stdio.h>

enum db {a, c , g }; 

int main() { 
  enum db myask;
  myask = c;
  printf("value to be printed %d", myask);
  return 0;
}

—output — 
value to be printed c

——————————— pass function by value(. Is used)  and by reference (-> used) but in case of pointer data and reference both uses -> 
   ———————— 
#include <stdio.h>
#include <string.h>

struct stdstructure { 				//union has same syntax as structure , only difference is union elements share memory location , structure is a record
  char nameofsociety[20];
  int numofpeoplestaying;
};

// typedef works exactly same as structure except definition is bit different as shown below
typedef struct Books {
   char title[50];
   int book_id;
} Book;
//

int printbyvalue(struct stdstructure getdata) { 
    printf("name of the society %s\n", getdata.nameofsociety);
    printf("number of folks staying %d\n", getdata.numofpeoplestaying);
    return 0;
}

void printbyref(struct stdstructure *getref) { 
    printf("name of society by ref %s\n", getref->nameofsociety);
    printf("num of folks by ref %d\n", getref->numofpeoplestaying);
}

int main() { 
  struct stdstructure setdata;
  struct stdstructure refdata;
  
  strcpy(setdata.nameofsociety,"Pink city");
  setdata.numofpeoplestaying = 50;
  printbyvalue(setdata);  //this is pass structure by value
  printf("-----------up by value----below by reference---\n");

  strcpy(refdata.nameofsociety,"Ref Pink city");
  refdata.numofpeoplestaying = 150;
  printbyref(&refdata); //structure pass by reference
  return 0;
}

————— output ——— 
name of the society Pink city
number of folks staying 50
-----------up by value----below by reference---
name of society by ref Ref Pink city
num of folks by ref 150

———————— Simple linked list -here casting ( struct mylink* ) malloc is also bit different and we use -> for both , to post and reference data  ————— 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct mylink{ 
  char data[30]; 
  int pointer;
};
int main() { 
  struct mylink *first;
  struct mylink *second;
  struct mylink *third;
  first = (struct mylink*) malloc(sizeof(struct mylink));
  second = (struct mylink*) malloc(sizeof(struct mylink));
  third = (struct mylink*) malloc(sizeof(struct mylink));
  strcpy(first->data, "Allan");
  strcpy(second->data, "Michael");
  strcpy(third->data, "Gonsalves");
  first->pointer = second;
  second->pointer = third;
  third->pointer = NULL;
  printf("value of first %s\n", first->data );
  printf("value of second %s\n", second->data );
  printf("value of third %s\n", third->data );
  return 0;
}

——— — output ——— 
value of first Allan
value of second Michael
value of third Gonsalves
———————— nested structure ———————— 
#include <stdio.h>

struct insidestruct { 
  int dimid;
  char charname[20];
};
struct mainstruct { 
  int sid;
  struct insidestruct in;
} driver;
int main() { 
  struct mainstruct driver = { 100, 200, strcpy( driver.in.charname, "product")};
  printf("print structure data %d , %d , %s\n", driver.sid, driver.in.dimid,driver.in.charname);
  return 0;
} 
——— — output ——— 
print structure data 100 , 200 , product

————— POINTER ——— 
https://www.thegeekstuff.com/2011/12/c-pointers-fundamentals

	•	    Constant pointer and pointer to constant.
	•	    Pointer to pointer with an example
	•	    Array of pointers with an example
	•	    Pointer to functions with an example

——————————— For constant pointer and pointer constant , try below rule to remember  ——————— 
A C P ( Address cannot be changed - Constant - Pointer ) 
       P C V  ( Pointer - Constant - Value cannot be changed ) 

Remove P so now it becomes AC - CV 
AC (P) - (P) CV 

—— Constant pointer - 
#include <stdio.h>
int main() { 
  float Var = 20.33;
  float jam = 32.34;
  float *const pointer = &Var;  //note the *const — this is how we define constant pointer.
//  pointer = &jam;  -- not allowed, we cannot assign new address to constant pointer
  printf("%.2f",*pointer );
  return 0;
}
—— Pointer  Constant - 
#include <stdio.h>
int main() { 
  char var1 = 'a';
  const char *pointer = &var1;
//  *pointer = 'b';  in case of constant pointer, value cannot be changed
  printf("value stored %c", *pointer);
  return 0;
}
—— Pointer  to Pointer  - 
#include <stdio.h> 
int main() { 
  const char *firstpointer = NULL;
  const char **secondpointer = NULL;
  firstpointer = "well done double pointer";
  secondpointer = &firstpointer;
  printf("print : %s\n", *secondpointer ); //for %s , we dont use * , we use only pointer name e.g. firstpointer but for double pointer we have to use one *
  
  return 0;
} 
—— Array of Pointer  - 
#include<stdio.h> 

int main(void)
{
    char *p1 = "Allan";
    char *p2 = "Gonsalves";
    char *p3 = "India"; 

    char *arr[3]; 

    arr[0] = p1;
    arr[1] = p2;
    arr[2] = p3; 

   printf("\n p1 = [%s] \n",p1);
   printf("\n p2 = [%s] \n",p2);
   printf("\n p3 = [%s] \n",p3); 

   printf("\n arr[0] = [%s] \n",arr[0]);
   printf("\n arr[1] = [%s] \n",arr[1]);
   printf("\n arr[2] = [%s] \n",arr[2]); 

   return 0;
}
—— Function Pointer  - 
int (*fptr)(int, int)

— example below 
#include<stdio.h> 

int func (int a, int b)
{
    printf("\n a = %d\n",a);
    printf("\n b = %d\n",b); 
    return 0;
} 

int main(void)
{
    int(*fptr)(int,int); // Function pointer 
    fptr = func; // Assign address to function pointer  . Note that, name of the function can be treated as starting address of the function so
// we can assign the address of function to function pointer using function’s name.
    func(2,3);
    fptr(2,3); 
    return 0;
}


————————————— 
int main(void) 
{ 

    char *ptr = "I am a string"; 

    printf("[%c], [%s]\n",  *ptr, ptr);  // Asterisk means value of the pointer. By default 
//any character pointer pointing to a string stores the address of the first character of the string. In the code above, ‘ptr’ holds the address 
of the character ‘I’ ie 1001. Now, when we apply the ‘value of’ operator ‘*’ to ‘ptr’, we intend to fetch the value at address 1001 which is 
‘I’ and hence when we print ‘*ptr’, we get ‘I’ as the output. The concept is that %s specifier requires the address of the beginning byte 
of string to display the complete string, which we provided using ‘ptr’ (which we know holds the beginning byte address of the string).

    return 0; 
}
—— output — 
[I], [I am a string]

——————— how to use structure pointer ————— 
#include<stdio.h> 

struct st{ 
int a; 
char ch; 
}; 

int main(void) 
{ 
    struct st obj; 
    struct st *stobj = &obj; 

    stobj->a = 5; 
    stobj->ch = 'a'; 

    printf("\n [%d] [%c]\n", stobj->a, stobj->ch); 
    return 0; 
}
——————— 
———————————— nested structure with pointer variable ————————— 
#include <stdio.h>
#include <string.h>
 
struct student_college_detail
{
    int college_id;
};
 
struct student_detail 
{
    float percentage; 
    struct student_college_detail clg_data; 
}stu_data, *stu_data_ptr;
 
int main() 
{
  struct student_detail stu_data = { 90.5, 71145};
    stu_data_ptr = &stu_data;
    printf(" Percentage is: %f \n\n", 
                         stu_data_ptr->percentage);
    printf(" College Id is: %d \n", 
                         stu_data_ptr->clg_data.college_id);
    return 0;
}
——— — output ——— 
 Percentage is: 90.500000 
 College Id is: 71145 
—————————— using dot notation in structure with pointer variables ——————— 

#include <stdio.h>
#include <string.h>
 
struct student_college_detail
{
    int college_id;
    int another_id;
};
 
struct student_detail 
{
    float percentage; 
    struct student_college_detail clg_data; 
}stu_data, *stu_data_ptr;
 
int main() 
{
  struct student_detail stu_data = { 
    .percentage = 200, 
    .clg_data.college_id = 300   };
    
    stu_data_ptr = &stu_data;
    printf(" Percentage is: %f \n\n", 
                         stu_data_ptr->percentage);
    printf(" College Id is: %d \n", 
                         stu_data_ptr->clg_data.college_id);
    return 0;
}

————— output ————— 
 Percentage is: 200.000000 
 College Id is: 300 

————— passing structure to function pointer ( single character ) —————— 
#include <stdio.h>

struct pro { 
  char name;
  int id;
};
void dosomething(struct pro *getinfo) { 
      printf("%c\n", getinfo->name);
      printf("%d\n", getinfo->id);
}

int main() { 
  struct pro info;
  info.name = 'a';
  info.id = 300;
  void(*funpointer)(struct pro *);
  funpointer = dosomething;
  funpointer(&info);
  return 0;
}

——output —- 
a
300

————— passing structure to function pointer ( with string ) —————— 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct pro {
    char *name;
    int id;
};

struct pro* dosomething(int j) {
    struct pro *infostruct;
    infostruct = (struct pro *) malloc(sizeof(struct pro));
    infostruct->name = "alan gonsalves";
    infostruct->id = j;
    return infostruct;
}


int main() {
    struct pro *mainfun;
    struct pro* (*funpointer)(int i);
    
    funpointer  = dosomething;
    mainfun = funpointer(30);
    printf("print name %s\n", mainfun->name);
    printf("print id %d\n", mainfun->id);
    return 0;
}
————— output ———— 
print name alan gonsalves
print id 30
——more such examples at below ———— 
//http://www.cs.utsa.edu/~wagner/CS2213/structs/structs_pass.html
—— Passing structure as a return type in the Function Pointer  - 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct pro {
    char name;
    int id;
};

struct pro* dosomething(int j) {
    struct pro *infostruct;
    infostruct = (struct pro *) malloc(sizeof(struct pro));
    infostruct->name = 'a';
    infostruct->id = j;
    return infostruct;
}

int main() {
    struct pro *mainfun;
    struct pro* (*funpointer)(int i);
    
    funpointer  = dosomething;
    mainfun = funpointer(30);
    printf("print name %c\n", mainfun->name);
    printf("print id %d\n", mainfun->id);
    return 0;
}
————— output ————— 
print name a
print id 30
——————  —— Extern ————— - - 
#include <stdio.h>
int x = 10;
int z = 5;
int main()
{
    extern int y; // line 2
    extern int z;
    printf("%d %d %d", x, y, z);
}
int y = 2;
————— output ————— 
10 2 5.  We define 2 variables x and z in global scope. By default, all of them have external linkage. When we use extern int z, we tell the compiler to use the same z as the global one. In main, we declare y as externally linked and tell the compiler to look for definition of y elsewhere. It has local scope upto when line 2 is compiled.The compiler reaches the end of the program and finds the definition of y. Since it is declared outside main, it is now promoted to global scope. Thus, the linker does not complain of not finding definition of y and the program runs.
————— ———Preprocessors———— ———————
//https://pebble.gitbooks.io/learning-c-with-pebble/content/chapter15.html

#define
#include
#undef
#pragma
#ifdef
#ifndef
#if
#else
#elif
#endif
#error 

———— Few examples on preprocessor————— ————
#define APWIDTH 20
#define BASWIDTH 30
#define CHWIDTH 50
#define WIDTHS APWIDTH, BASWIDTH, CHWIDTH
int widths[] =  { WIDTHS } ;

int main() { 
  int i;
  for(i= 0; i<4; i++) { 
    printf("values %d\n", widths[i]);
  }
  return 0;
}
—————output ————— 
values 20
values 30
values 50
values 0

———— Example 2 - preprocessor conditional code ————— ————

#if defined(TABLE_SIZE)
  #if TABLE_SIZE > 100 
    #undef TABLE_SIZE
    #define TABLE_SIZE 100
    int boundary = 200;
  #else
    int boundary = 100;
  #endif
#else 
  #define TABLE_SIZE 50;
  int boundary = 100;
#endif 
————— ———Pointer arithmetic ———— ———————
Here we can do integer type operation on pointer as shown below 

#include <stdio.h>
const int MAX = 3;
int main () {
   int  var[] = {10, 100, 200};
   int  i, *ptr;
   /* let us have address of the first element in pointer */
   ptr = &var;
   i = 0;
   while ( ptr <= &var[MAX - 1] ) {
      printf("Address of var[%d] = %x\n", i, ptr );
      printf("Value of var[%d] = %d\n", i, *ptr );

      /* point to the previous location */
      ptr++;
      i++;
   }
   return 0;
}
———— output ————— 
Address of var[0] = f2f4b0e0
Value of var[0] = 10
Address of var[1] = f2f4b0e4
Value of var[1] = 100
Address of var[2] = f2f4b0e8
Value of var[2] = 200
————— ———Heap memory (this is global , configured using malloc, free is must to avoid memory leak) and stack memory (normal variables lives during function)  ———— ———————
#include <stdio.h>
#include <stdlib.h>
int main() { 
  int *whatever = malloc(sizeof(int));
  *whatever = 30;
  printf("print %d", *whatever);
  free(whatever);
  return 0;
}
--output -- 
print 30


———— Some examples —— 
#undef FILE_SIZE
#define FILE_SIZE 42 
It tells the CPP ( C pre-processor ) to undefine existing FILE_SIZE and define it as 42.

#ifndef MESSAGE 
	#define MESSAGE “You wish”
#endif
It tells the CPP to define MESSAGE only if MESSAGE isn't already defined.

Predefined Macros as follows - 
__DATE__
__TIME__
__FILE__
__STDC__

————— ——————— ——————— 
There are two types of macros - Object-like (do not take parameters) and function-like (Can take parameters)
// object-like macro
#define        
// function-like macro          
#define () 
To delete macro use #undef 

We can write multi-line macro same like function, but each statement ends with “\”. 
#include <stdio.h>
  
#define MACRO(num, str) {\
            printf("%d", num);\
            printf(" is");\
            printf(" %s number", str);\
            printf("\n");\
           }

———— example 1- 
#include <stdio.h>

#define M1
#define M2

int main(void) { 
#ifdef M1
  printf("this is macro M1\n");
#endif 

#ifdef M2
  printf("this is M2 micro\n");
#endif
  return 0;
}

------- Output — 
this is macro M1
this is M2 micro
—————Below macro value is passed in the code 
#include <stdio.h>
#define M1(x)  x * (x+5)
int main() { 
#ifdef M1
  printf("macro M1 is active\n");
#endif
  int res = M1(2);
  printf("new value based on macro %d - \n ", res);
  return 0;
}
———To pass macro value from command line use below - 
> gcc -Wall -DMACRO1=25 macro.c -o macro

————— ———Macro functions———— ———————
#include <stdio.h>
#define PRINT(i, limit) while (i < limit) \
                        { \
                            printf("GeeksQuiz "); \
                            i++; \
                        }
int main()
{
    int i = 0;
    PRINT(i, 3);
    return 0;
}
// Output: GeeksQuiz  GeeksQuiz  GeeksQuiz

Stringize operator is # as shown below #a and #b.
#define  message_for(a, b)  \
   printf(#a " and " #b ": We love you!\n")

int main(void) {
   message_for(Carole, Debra);
   return 0;
}

—— Token pasting operator (##) —— 
#include <stdio.h>

#define tokenpaster(n) \
  printf ("token" #n " = %d", token##n)

int main(void) {
   int token34 = 400;
   tokenpaster(34);
   return 0;
}
—— output 
token34 = 400

————— ———Endian-ness – Little Vs Big ——— ———————
Little and big endian are two ways of storing multibyte data-types ( int, float, etc).
\\ https://www.geeksforgeeks.org/little-and-big-endian-mystery/

————— ———All about file ———— ———————
#include <stdio.h>
#include <string.h>


int main() { 
  char c[100];
  char buffer[100];
  FILE *pointer;
  pointer  = fopen("/root/c_world/sample.txt", "w+") ; 
  fgets(c, 100, stdin);
  fwrite(c, strlen(c) + 1, 1, pointer); 
  fseek(pointer, 3, SEEK_SET);
  fread(buffer, strlen(c) + 1, 1, pointer);
  printf("%s", buffer);
  fclose(pointer);

  return 0 ;

}
————— output ——————— 
> this is my life 
> s is my life 

————— ———Inline functions - (inline code of function gets when called)———— ———————
#include <stdio.h>
int inline func1(int a) { 
  return ( a + 10 );
}

void inline func2() { 
  printf("Printing value : %d", func1(30) );
}

int main() { 
  func2();
  return 0;  
}
———— Output - 
Printing value : 40
————— ——————— ——————— 
//constant pointer, pointer to constant and constant pointer to constant.
/*constant pointer = A constant pointer is a pointer that cannot change the address its holding. In other words, we can say that once a constant pointer points to a variable then it cannot point to any other variable

int main(void)
{
    int var1 = 0, var2 = 0;
    int *const ptr = &var1;
 //   ptr = &var2;   this is not possible
    printf("%d\n", *ptr);
    
    return 0;
} */
/*Pointer to constant - a pointer through which one cannot change the value of variable it points is known as a pointer to constant. These type of pointers can change the address they point to but cannot change the value kept at those address.


int main(void)
{
    int var1 = 10;
    const int* ptr = &var1;
//    *ptr = 1;           //changing value of the pointer now possible
    printf("%d\n", *ptr);
    
    return 0;
} */

/* Constant pointer to constant - A constant pointer to constant is a pointer that can neither change the address its pointing to and nor it can change the value kept at that address. */

#include<stdio.h>

int main(void)
{
    int var1 = 20,var2 = 0;
    const int* const ptr = &var1;
//    *ptr = 1;
//    ptr = &var2;
    printf("%d\n", *ptr);
    
    return 0;
}


——————— - —————— Function pointer —————— —————— 
//https://www.geeksforgeeks.org/function-pointer-in-c/

#include <stdio.h>
int fun(int a)
{
    printf("Value of a is %d\n", a);
    return a * 2;

}
 
int main()
{
    // fun_ptr is a pointer to function fun() 
    int (*fun_ptr)(int) = &fun;
 
    /* The above line is equivalent of following two
       int (*fun_ptr)(int);
       fun_ptr = &fun; 
    */
 
     printf("new value %d\n", (*fun_ptr) (10));
    return 0;
}
—output - 
Value of a is 10
new value 20



—————————————— How to return string from a function ———————— 
#include <stdio.h>
char* displayString(char str[]){
    str = "now this is new statement";
    return(str);
}
int main()
{ 
    printf("new value %s\n", displayString("this is  statement"));  
    return 0;
}
————— output ————— 
new value  : now this is new statement
——————————————————— How to use malloc on simple characteristics and on structure 
#include <stdio.h>
#include <stdlib.h>

int main () {
    char *str;
    
    /* Initial memory allocation */
    str = (char *) malloc(15);
    strcpy(str, "tutorialspoint");
    printf("String = %s,  Address = %u\n", str, str);
    
    /* Reallocating memory */
    str = (char *) realloc(str, 25);
    strcat(str, ".com");
    printf("String = %s,  Address = %u\n", str, str);
    
    free(str);
    
    return(0);
}
————— 
String = tutorialspoint,  Address = 7566976
String = tutorialspoint.com,  Address = 7567600
Program ended with exit code: 0 


——————————————————— Depth first search 
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>

#define MAX 5

struct Vertex {
    char label;
    bool visited;
};

//stack variables
int stack[MAX];
int top = -1;

//array of vertices
struct Vertex*  firstVertices[MAX];

//adjacency matrix
int adjMatrix[MAX][MAX];

//vertex count
int vertexCount = 0;

//stack functions
void push(int item) {
    stack[++top] = item;
}

int pop() {
    return stack[top--];
}

int peek() {
    return stack[top];
}

bool isStackEmpty() {
    return top == -1;
}

//add vertex to the vertex list
void addVertex(char label) {
    struct Vertex* vertex = (struct Vertex*) malloc(sizeof(struct Vertex));
    vertex->label = label;
    vertex->visited = false;
    firstVertices[vertexCount++] = vertex;
}

//add edge to edge array
void addEdge(int start,int end) {
    adjMatrix[start][end] = 1;
    adjMatrix[end][start] = 1;
}

//display the vertex
void displayVertex(int vertexIndex) {
    printf("%c ",firstVertices[vertexIndex]->label);
}

//get the adjacent unvisited vertex
int getAdjUnvisitedVertex(int vertexIndex) {
    int i;
    
    for(i = 0; i < vertexCount; i++) {
        if(adjMatrix[vertexIndex][i] == 1 && firstVertices[i]->visited == false) {
            return i;
        }
    }
    
    return -1;
}

void depthFirstSearch() {
    int i;
    
    //mark first node as visited
    firstVertices[0]->visited = true;
    
    //display the vertex
    displayVertex(0);
    
    //push vertex index in stack
    push(0);
    
    while(!isStackEmpty()) {
        //get the unvisited vertex of vertex which is at top of the stack
        int unvisitedVertex = getAdjUnvisitedVertex(peek());
        
        //no adjacent vertex found
        if(unvisitedVertex == -1) {
            pop();
        } else {
            firstVertices[unvisitedVertex]->visited = true;
            displayVertex(unvisitedVertex);
            push(unvisitedVertex);
        }
    }
    
    //stack is empty, search is complete, reset the visited flag
    for(i = 0;i < vertexCount;i++) {
        firstVertices[i]->visited = false;
    }
}

int main() {
    int i, j;
    
    for(i = 0; i < MAX; i++)    // set adjacency {
        for(j = 0; j < MAX; j++) // matrix to 0
            adjMatrix[i][j] = 0;
    
    addVertex('S');   // 0
    addVertex('A');   // 1
    addVertex('B');   // 2
    addVertex('C');   // 3
    addVertex('D');   // 4
    
    addEdge(0, 1);    // S - A
    addEdge(0, 2);    // S - B
    addEdge(0, 3);    // S - C
    addEdge(1, 4);    // A - D
    addEdge(2, 4);    // B - D
    addEdge(3, 4);    // C - D
    
    printf("Depth First Search: \n");
    depthFirstSearch();
    
    return 0;
}

————————————————————— Returning structure from function - 
#include <unistd.h>

//structure
struct familytree {
    char name;
    struct familytree *son;
    struct familytree *daughter;
};
//instance of the structure
struct familytree* detailedfun(char fullname){
    struct familytree* myfamily = (struct familytree*) malloc(sizeof(struct familytree));
    myfamily->name = fullname;
    myfamily->son  = 'A';
    myfamily->daughter = 'C';
    return myfamily;
}


int main() {
//main - fill structure and return structure
    struct familytree *tree = detailedfun('M');
    
//print structure
    printf("Full name %c-\n", tree->name );
    printf("name of the son - %c\n", tree->son);
    printf("name of the daughter - %c\n", tree->daughter);
    
}
——output - 
Full name M-
name of the son - A
name of the daughter - C
————————————————————— Deep First search traversal 
// C program for different tree traversals
//Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to
// traverse them, trees can be traversed in different ways. Following are the generally used ways for traversing trees.

// https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/
//    Depth First Traversals:
//(a) Inorder (Left, Root, Right) : 4 2 5 1 3
//(b) Preorder (Root, Left, Right) : 1 2 4 5 3
//(c) Postorder (Left, Right, Root) : 4 5 2 3 1

#include <stdio.h>
#include <stdlib.h>

/* A binary tree node has data, pointer to left child
 and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* Helper function that allocates a new node with the
 given data and NULL left and right pointers. */
struct node* newNode(int data)
{
    struct node* node = (struct node*) malloc(sizeof(struct node));
    node->data = data;
    node->left = NULL;
    node->right = NULL;
    
    return(node);
}

/* Given a binary tree, print its nodes according to the
 "bottom-up" postorder traversal. */
void printPostorder(struct node* node)
{
    if (node == NULL)
        return;
    
    // first recur on left subtree
    printPostorder(node->left);
    
    // then recur on right subtree
    printPostorder(node->right);
    
    // now deal with the node
    printf("%d ", node->data);
}

/* Given a binary tree, print its nodes in inorder*/
void printInorder(struct node* node)
{
    if (node == NULL)
        return;
    
    /* first recur on left child */
    printInorder(node->left);
    
    /* then print the data of node */
    printf("%d ", node->data);
    
    /* now recur on right child */
    printInorder(node->right);
}

/* Given a binary tree, print its nodes in preorder*/
void printPreorder(struct node* node)
{
    if (node == NULL)
        return;
    
    /* first print data of node */
    printf("%d ", node->data);
    
    /* then recur on left sutree */
    printPreorder(node->left);
    
    /* now recur on right subtree */
    printPreorder(node->right);
}

/* Driver program to test above functions*/
int main()
{
    struct node *root  = newNode(1);
    
    root->left             = newNode(2);
    root->right           = newNode(3);
    root->left->left     = newNode(4);
    root->left->right   = newNode(5);
    root->left->left->left   = newNode(6);
    
    printf("\nPreorder traversal of binary tree is \n");
    printPreorder(root);
    
    printf("\nInorder traversal of binary tree is \n");
    printInorder(root);
    
    printf("\nPostorder traversal of binary tree is \n");
    printPostorder(root);
    
    getchar();
    return 0;
}
———————— 

Preorder traversal of binary tree is 
1 2 4 6 5 3 
Inorder traversal of binary tree is 
6 4 2 5 1 3 
Postorder traversal of binary tree is 
6 4 5 2 3 1 
————————————————————— ————————— Linked list and How to use malloc on structure 
#include <stdio.h>
#include <stdlib.h>
//struct

struct node {
    int data;
    struct node *next;
};

//print
void printlist(struct node *getdata) {
    while (getdata != NULL) {
        printf("print the list %d\n ", getdata->data);
        getdata = getdata->next;
    }
}
//main
int main() {
    
   struct node *head = ( struct node*) malloc(sizeof(struct node));
    struct node *second = ( struct node*) malloc (sizeof(struct node));
    struct node *third = (struct node *) malloc(sizeof(struct node));
    
    head->data = 1;
    head->next = second;
    
    second->data = 2;
    second->next = third;
    
    third->data = 3;
    third->next = NULL;
    
    printlist(head);
    
}

————————— 
print the list 1
 print the list 2
 print the list 3
————————————————————— —————————  
What is structure padding in C - In order to align the data in memory, one or more empty bytes (addresses) are inserted (or left empty) between memory addresses which are allocated for other structure members while memory allocation. This concept is called structure padding.

Read below post - https://fresh2refresh.com/c-programming/c-structure-padding/

Every field in structure going to take some byte in 4 byte (32 bit processor) or 8 byte ( in 64 bit processor) so if we use Char data type in structure then it wil use only 1 byte out of 4 and , 3 byte remain empty which can remain unused. So we can use #pragma pack(1) directive as shown below to remove those empty spaces . If we remove pragma directive then it wil keep empty bytes (unusable) 

#include <stdio.h>
#include <string.h>
 
/*  Below structure1 and structure2 are same. 
    They differ only in member's allignment */
#pragma pack(1) 
struct structure1 
{
       int id1;
       int id2;
       char name;
       char c;
       float percentage;
};
 
struct structure2 
{
       int id1;
       char name;
       int id2;
       char c;
       float percentage;                      
};
 
int main() 
{
    struct structure1 a;
    struct structure2 b;
 
    printf("size of structure1 in bytes : %d\n", 
            sizeof(a));
    printf ( "\n   Address of id1        = %u", &a.id1 );
    printf ( "\n   Address of id2        = %u", &a.id2 );
    printf ( "\n   Address of name       = %u", &a.name );
    printf ( "\n   Address of c          = %u", &a.c );
    printf ( "\n   Address of percentage = %u",
                   &a.percentage );
 
    printf("   \n\nsize of structure2 in bytes : %d\n",
                   sizeof(b));
    printf ( "\n   Address of id1        = %u", &b.id1 );
    printf ( "\n   Address of name       = %u", &b.name );
    printf ( "\n   Address of id2        = %u", &b.id2 );
    printf ( "\n   Address of c          = %u", &b.c );
    printf ( "\n   Address of percentage = %u",
                   &b.percentage );
    getchar();
    return 0;
}

——— ——— output ———— ————— 
size of structure1 in bytes : 14

   Address of id1        = 2455124416
   Address of id2        = 2455124420
   Address of name       = 2455124424
   Address of c          = 2455124425
   Address of percentage = 2455124426   

size of structure2 in bytes : 14

   Address of id1        = 2455124400
   Address of name       = 2455124404
   Address of id2        = 2455124405
   Address of c          = 2455124409
   Address of percentage = 2455124410

——— ——— ———— ——qsort function————————  ———— ————— 

#include <stdio.h>
#include <stdlib.h>

// A sample comparator function that is used
// for sorting an integer array in ascending order.
// To sort any array for any other data type and/or
// criteria, all we need to do is write more compare
// functions.  And we can use the same qsort()
int compare (const void * a, const void * b)
{
    return ( *(int*)a - *(int*)b );
}

int main ()
{
    int arr[] = {10, 5, 15, 12, 90, 80};
    int n = sizeof(arr)/sizeof(arr[0]), i;

    qsort (arr, n, sizeof(int), compare);
    
    for (i=0; i<n; i++)
        printf ("%d ", arr[i]);
    return 0;
}
——output —— 
5 10 12 15 80 90
——————— ——— - — — CASTING AND POINTER - —— 
int main() { 
  float i = 300;
  int*  p = (int*) &i;
  printf("%p\n", p);
  return 0;
}

&i : means to take the address of i (which is a char*)

(int*)&i : casts that pointer to be a pointer to integer (which is bad/wrong to do, 
but you told the compiler to do it so it won't even give a warning)

int* p = (int*)&i; : a statement that says to store the pointer of i in p (and cast 
it too: the compiler won't even complain)

p* = 1234567892; : write this value, which is several bytes to the base location 
pointed to by p (which although p thinks it points to an int, is to char!).

—— — OUTPUT
> 0x7ffc391eb594
——————— ——— - — — Dangling pointers  - —— 
A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer. 
1. De-allocation of memory 
2. Function call 
3. Variable goes out of scope

1. De-allocating of memory - 
// Deallocating a memory pointed by ptr causes
// dangling pointer
#include <stdlib.h>
#include <stdio.h>
int main()
{
    int *ptr = (int *)malloc(sizeof(int));
 
    // After below free call, ptr becomes a 
    // dangling pointer
    free(ptr); 
    printf("printing memory address %p\n", ptr);
    // No more a dangling pointer
    ptr = NULL;
    printf("printing memory address %p\n", ptr);
}
—— output —
printing memory address 0xf34010
printing memory address (nil)

—— —2. Function call 
#include <stdio.h>
int *fun(int ad){ 
 ad += 5;
  return &ad;
}


int main(){  
  int *p = fun(30);
//  fflush(stdin);  //this will make pointer dangling ...
  printf("new value %d\n", *p);
  return 0;
}

—Output — 
new value  35 , if we use fflush then new value will be 0


—— ———3. Variable goes out of scope
#include<stdlib.h>
 
int main()
{
    int x = 4;
    float y = 5.5;
    char c[5] = "allan";
    
    //A void pointer
    void *ptr;
    ptr = &x;
 
    // (int*)ptr - does type casting of void 
    // *((int*)ptr) dereferences the typecasted 
    // void pointer variable.
    //below after printing , we will dereference int type of ptr so that we
    //can use it for float printing. if we dont then it will print some garbage
    printf("Integer variable is = %d\n", *( (int*) ptr) );
    // void pointer is now float
    
    ptr = &y;  
    //below after printing , we will dereference float tile of ptr so that we
    //can use it for char.
    printf("\nFloat variable is= %f\n", *( (float*) ptr) ); 
    
    ptr = &c;
    printf("\nCharacter variable is= %s\n", ( (char*) ptr));\
    return 0;
}
—output — 
Integer variable is = 4
Float variable is= 5.500000
Character variable is= allan

————————— Using pointer in the function ——————— 
#include <stdio.h>
void salaryhike(int  *var, int b)
{
    *var = *var+b;  // here we are doing operation on only address which is void data type.
}
int main()
{
    int salary=0, bonus=0;
    printf("Enter the employee current salary:"); 
    scanf("%d", &salary);
    printf("%d\n", &salary); //here we are passing address of salary to pointer
    printf("%d\n", salary);
    printf("Enter bonus:"); //here we are passing value to anthor int variable b
    scanf("%d\n", &bonus);
    salaryhike(&salary, bonus);   
    printf("Final salary: %d\n", salary); //here we are picking what is newly updated at salary address
    return 0;
}

-------output - 
Enter your salary : 100
734484343994
100
Enter bonus: 200 
Final salary: 300

—————————— simple pointer ————— 
#include <stdio.h>
int main() { 

  int v = 100; 
  int *a = &v; //we can only assign address to pointer not a value, so *a = v not possible
  printf("address stored at pointer %d\n", a); //this is address of variable
  printf("address of a variable %d\n", &v); //this is original variable address
  printf("value of pointer %d\n", *a); //this stores the value of the variable
  return 0;
}
—————output ————— 
address stored at pointer -2137135004
address of a variable -2137135004
value of pointer 100
—————————— using pointer in function ————— 
#include <stdio.h>

void fun1(int *x) {  //here definitio says x is pointer , pointed to address of f1. just a reference
    *x = *x + 5; //here we are now dealing with actual value stored at f1 address. * means value now.
    printf("what is x %d\n", x);  //here naked x means address. so * means value and naked variable means address
}
int main() { 
  int f1 = 20;   
  printf("original value func1 value %d\n", f1); 
  fun1(&f1);
  printf("value func1 value %d\n", f1); 
  return 0;
}
———output ————— 
original value func1 value 20
what is x 1870475468
value func1 value 25
——————— ——— - — — extern ——————— ——— - —
------main.c file where we have value of count is set. Variables of this storage class are “Global variables”
    Global Variables are declared outside the function and are accessible to all functions in the program
    Generally , External variables are declared again in the function using keyword extern
    In order to Explicit declaration of variable use ‘extern’ keyword

#include <stdio.h>
int count ;
extern void write_extern();
 
main() {
   count = 5;
   write_extern();
}


----support.c file where we have declare count variable.
#include <stdio.h>
extern int count;
 
void write_extern(void) {
   printf("count is %d\n", count);
}
—output — 
> gcc main.c support.c 
>./a.out
>count is 5

——————— ——— - — — gets/EOF/feof  ——————— ——— - —
#include <stdio.h>
 
int main()
{
  FILE *fp = fopen("test.txt", "r");
  int ch = getc(fp);
  while (ch != EOF) 
  {
    /* display contents of file on screen */
    putchar(ch); 
 
    ch = getc(fp);
  }
   
  if (feof(fp))
     printf("\n End of file reached.");
  else
     printf("\n Something went wrong.");
  fclose(fp);
     
  getchar();
  return 0;
}
——output ——
> this data came from file 
> End of the file reached.

——————————— Endian-ness – Little Vs Big ——————— ————— 
#include <stdio.h>
/* function to show bytes in memory, from location start to start+n*/
void show_mem_rep(char *start, int n) 
{
    int i;
    for (i = 0; i < n; i++)
         printf(" %.2x", start[i]);
    printf("\n");
}
/*Main function to call above function for 0x01234567*/
int main()
{
   int i = 0x01234567;
   show_mem_rep((char*)&i, sizeof(i));
   return 0;
}

——————— output ————— 
 67 45 23 01
——————— binary operations ————— 
#include <stdio.h>
main() {
    unsigned int a = 60;    /* 60 = 0011 1100 */
    unsigned int b = 13;    /* 13 = 0000 1101 */
    int c = 0;
    c = a & b;       /* 12 = 0000 1100 */
    printf("Line 1 - Value of c is %d\n", c );
    c = a | b;       /* 61 = 0011 1101 */
    printf("Line 2 - Value of c is %d\n", c );
    c = a ^ b;       /* 49 = 0011 0001 */
    printf("Line 3 - Value of c is %d\n", c );
    c = ~a;          /*-61 = 1100 0011 */
    printf("Line 4 - Value of c is %d\n", c );
    c = a << 2;     /* 240 = 1111 0000 */
    printf("Line 5 - Value of c is %d\n", c );
    c = a >> 2;     /* 15 = 0000 1111 */
    printf("Line 6 - Value of c is %d\n", c );
}
——————— ——Bitfield ——— ————— 

#include <stdio.h>
#include <string.h>

struct {
    unsigned int age : 4; 
    //here 4 means bits expressed in 2^4 = 16 so upto 0-15 values compiler will
    //take. example below it will print all 4,8 but only 15.0 instead of 15.2 since bits 
    //can store 16 values only(0-15) so .2 is ignored. Try int agt : 5 then it will print upto 0-31
} Age;

/* example in structure below - unnamed bit field can be used to push boundary to next slot example 2^4
struct test2
{
   unsigned int x: 5;
   unsigned int: 0;   //this will take it to 8 byte but combined of 5 and 8 bits can stay under 16 which is 4 byte ( 2^4) .
   unsigned int y: 8;
};
*/
int main( ) {

   Age.age = 4;
   printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
   printf( "Age.age : %d\n", Age.age );

   Age.age = 8;
   printf( "Age.age : %d\n", Age.age );
      Age.age = 15.2;
      printf( "Age.age : %.1f\n", (float) Age.age );

   // below address of bitfield is not permitted. it will give error
   printf("Address of test2.x is %p", &t.x);
   return 0;
}
———Output ——— ————— 
Sizeof( Age ) : 4
Age.age : 4
Age.age : 8
Age.age : 15.0

——————— ——Bitfield interesting example ——— ————— 

#include <stdio.h>
struct test
{
   unsigned int x;
   long int y: 33;
   unsigned int z;
};
int main()
{
   struct test t;
   unsigned int *ptr1 = &t.x;
   unsigned int *ptr2 = &t.z;
   printf("%d", ptr2 - ptr1);
   return 0;
}
———Output ——— ————— 
4 
——————— —gets() and fgets() — gets() is more dangerous can result in buffer overflow, use only fgets() ———  

———————— Format specifier ——————— -   —— - - 
The % specifiers that you can use in ANSI C are:
Usual variable type Display
%c char single character
%d (%i) int signed integer
%e (%E) float or double exponential format
%f float or double signed decimal
%g (%G) float or double use %f or %e as required
%o int unsigned octal value
%p pointer address stored in pointer
%s array of char sequence of characters
%u int unsigned decimal
%x (%X) int unsigned hex value
 ——— ————— ——— ————— ——— ————— 
Direct Access Memory - https://en.wikipedia.org/wiki/Direct_memory_access


 ——— ————— ———Array ————— ——— ————— 

————————— Scenario = Assigning structure as a array element ———— 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct info { 
  char typeofstorm;
  int category;
};

int main() {
  struct info structarray[2];
  int i=0;

  structarray[0].typeofstorm = 'h'; 
  structarray[0].category = 5;

  structarray[1].typeofstorm = 'T'; 
  structarray[1].category = 4;

  for (i=0 ; i< 2; i++) {
    printf("storm name %c\n",structarray[i].typeofstorm);
    printf("catgeory %d\n", structarray[i].category);
  }
  return 0;
}

———— output —— 
storm name h
catgeory 5
storm name T
catgeory 4


—————————— scenario 2 - Array of Char Pointers —————————— 
#include <stdio.h>

int main() { 
  char *p1 = "whats a day";
  char *p2 = "holiday";
  char *p3 = "Thursday";

  char*  a[3];      // here * is next to char so this is array of 3 character pointer.
  a[0] = p1;
  a[1] = p2;
  a[2] = p3;
  int i=0;

  for (i=0; i<3; i++) { 
    printf("array values %s\n", a[i]);
  }
  return 0;
}

————— output 

array values whats a day
array values holiday
array values Thursday

————————————— Pointer to Arrays (we need to deference array before printing , first time in history :) ———————


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main() { 
  char simplearray[3];
  simplearray[0] = 'a';
  simplearray[1] = 'b';
  simplearray[2] = 'c';

//pointer to simplearray
  char (*pointertosimplearray)[3];

  pointertosimplearray = &simplearray;
  printf("array elements %c\n", (*pointertosimplearray)[0]); //before printing array needs to be dereferenced.
  printf("array elements %c\n", (*pointertosimplearray)[1]);
  printf("array elements %c\n", (*pointertosimplearray)[2]);
  return 0;
}

———— output —— 
array elements a
array elements b
array elements c

—————————————Static vs Dynamic Array ——————————— 


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() { 
  int n=0;
  printf("Enter number of elements for array : ");
  scanf("%d", &n);

  //Dynamic memory assignment in heap, if we speicy [3] then it goes on stack
  char *ptr = (char*) malloc(n);
  

  int i=0;

  for(i=0; i<n; i++) { 
    ptr[i] = i;
    printf("array elements %d\n", ptr[i]);  
  }
  free(ptr);
  return 0;
}

———— output ——— 
Enter number of elements for array : 4
array elements 0
array elements 1
array elements 2
array elements 3

—————————————— Decomposing Array into Pointers ——————— 

Internally, arrays aren’t treated specially, they are decomposed into pointers and operated there-on. For example an array like :
char arr[10];
When accessed like :
arr[4] = 'e';
is decomposed as :
*(arr + 4) = 'e'

——————————————— Character Arrays and Strings——————— 
‘\0’ . If this is present after a series of characters in an array, then that array becomes a string.
This is an array:  char arr[] = {'a', 'b', 'c'};
This is a string:   char arr[] = {'a', 'b', 'c', '\0'};

——————————————— Bi-dimensional and Multi-dimensional Arrays——————— 
Example below - 5 rows for names ; 10 characters for each name and 50 characters for each address 
char arr[5][10][50];

————— —————— example Bi-dimensional ———————————— 
#include <stdio.h>
#include <string.h>

int main() { 
  char simplearr[3];
  simplearr[0] = 'a';
  simplearr[1] = 'b'; 
  simplearr[2] = 'c';
  int i=0;
  for ( i=0 ; i<2; i++) {
    printf("array elements %c\n", simplearr[i]);
  }
      printf("array as string %s\n", simplearr); //this will put ? mark at the end because it doesnot 
//find \0 as last character. so technically it is not a string.
  i= 0;
  memset(simplearr, '\0', sizeof(simplearr));
  simplearr[0] = 'a';
  simplearr[1] = 'b';  
  //simplearr[2] = '\0' this will be automatically filled up due to memset command.
    printf("array elements %s\n", simplearr);  //printing array as string

  return 0;
}


———— output — 
array elements a
array elements b
array as string abcw?
array elements ab

———————————— Use of strncpy library ———————— 
#include <stdio.h>
#include <string.h>

int main () {  
  char simplearray[20];

  memset(simplearray, '\0', sizeof(simplearray));
  char *ptr = "Gonsalves"; 
  strncpy(simplearray, ptr, 15);  //here 15 is sizeof
  printf("array - %s\n", simplearray );
  return 0;
}

———output ——— 
array - Gonsalves

—————————————————— Two dimensional array——————————— 

Internally, arrays aren’t treated specially, they are decomposed into pointers and operated there-on. For example an array like :
char arr[10];
When accessed like :
arr[4] = 'e';
is decomposed as :
*(arr + 4) = 'e'

————————— example —— 
#include <stdio.h>
#include <string.h>

int main() { 
  int multiarray[3][4] = { 
              { 4, 2, 5, 2},
              { 6, 2, 4, 5},
              { 8, 6, 3, 2}
              };
  int *pointertomultiarray = &multiarray[0][0];
  int i=0;
  for(i=0; i<12; i++) { 
    printf("array shown - %d\n", *(pointertomultiarray + i));
  }
  return 0;
}

——— output ——— 
array shown - 4
array shown - 2
array shown - 5
array shown - 2
array shown - 6
array shown - 2
array shown - 4
array shown - 5
array shown - 8
array shown - 6
array shown - 3
array shown - 2

——————————————————  y——————————— 









————————————— C ++ ——————————————————

———————— Simple data types printing —————————— 
#include <iostream>
using namespace std;
 
extern int a, b;
extern int c;
extern float f;
  
int main () { 
   int a = 20 , b = 20;
   int c = a+ b;
   float f;
 
   cout << c << endl ;  //here endl is like \n new line and flush() 

   f = 70.0/3.0;
   cout << f << endl ;  //there is no %d like we used in C 
   return 0;
}
———— output ——— 
40
23.3333
———————————— Alternative way to use standard literary ———————— 

#include <iostream>
//using namespace std  - we can use std:: also as shown below

static int c = 5;
void fun(void);

int main() { 
  while(c--) { 
    fun();
  }
  return 0;
}

void fun(void) { 
  std::cout << "Value of c is : " << c << std::endl;
}

————— output —————— 
Value of c is : 4
Value of c is : 3
Value of c is : 2
Value of c is : 1
Value of c is : 0

—————————— Forever loop - —————————— 
#include <iostream>
using namespace std;
 
int main () {
   for( ; ; ) {
      printf("This loop will run forever.\n");
   }

   return 0;
}

———————————— Few standard functions - ————— 
#include <iostream>
#include <cmath>
using namespace std;
 
int main () {
   // number definition:
   short  s = 10;
   int    i = -1000;
   long   l = 100000;
   float  f = 230.47;
   double d = 200.374;

   // mathematical operations;
   cout << "sin(d) :" << sin(d) << endl;
   cout << "abs(i)  :" << abs(i) << endl;
   cout << "floor(d) :" << floor(d) << endl;
   cout << "sqrt(f) :" << sqrt(f) << endl;
   cout << "pow( d, 2) :" << pow(d, 2) << endl;
 
   return 0;
}
——output ——— 
sin(d) :-0.634939
abs(i)  :1000
floor(d) :200
sqrt(f) :15.1812
pow( d, 2) :40149.7

———————————————— Generate Random numbers ————————— 

#include <iostream>
#include <ctime>
#include <cstdlib>
using namespace std;
int main () {
   int i,j;
   // set the seed
   srand( (unsigned)time( NULL ) );
   /* generate 5  random numbers. */
   for( i = 0; i < 5; i++ ) {
      // generate actual random number
      j = rand();
      cout <<" Random Number : " << j << endl;
   }
   return 0;
}
———— output —————— 
 Random Number : 866241598
 Random Number : 2091619569
 Random Number : 1545570698
 Random Number : 1782012089
 Random Number : 931262115

——————————— set base/setw/setfill functions — —————————— 

// CPP Program to illustrate 
// std::setbase manipulator 
#include <iostream> 
#include <iomanip> // std::setbase 
using namespace std;


int main() 
{ 
    // set base to hexadecimal 
    cout << setbase(16); 

    // displaying 255 in hexadecimal 
    cout << 255 << endl; 
  
    // set base to Octal 
    cout << setbase(8); 
  
    // displaying 255 in Octal 
    cout << 255 << endl; 
    string str = "what a day";
    cout << str << endl;
    cout << setw(20); 
    cout << setfill('x');
    cout << str << endl;
    return 0; 
} 
————— output ————— 
ff
377
what a day
xxxxxxxxxxwhat a day

————————————— String operations ——————————— 
#include <iostream>
#include <cstring>
using namespace std;

int main() { 

  char s1[10] = "First";
  char s2[10] = "Second";
  char s3[20] ;
  char s4[20];
  int len;
  
//strcpy . strcat . strlen
  strcpy(s3, s1);
  strcat(s1,s2);
  len = strlen(s1);

  cout << "Strcpy from s1 to s3 : " << s3 << endl ;
  cout << "Strcat of s1 and s2 : " << s1 << endl ;
  cout << "strlen(s1) : " << len << endl;
  return 0;
 }
—————— output —————— 
Strcpy from s1 to s3 : First
Strcat of s1 and s2 : FirstSecond
strlen(s1) : 11

————————————— Reference vs Pointer  ——————————— 

A reference variable is an alias, that is, another name for an already existing variable. Once a reference is initialized with a variable, 
either the variable name or the reference name may be used to refer to the variable.

#include <iostream>
using namespace std;

int main() { 

  int i=20;
  int& ref_of_i_variable = i;   //we use & for reference variable . It is not a pointer 

  cout << "Value of i : " << i << endl;
  cout << "Reference value of i : " << ref_of_i_variable << endl ;
  return 0;
}
———— output ——— 
Value of i : 20
Reference value of i : 20

——————————— Pointer ——————————— 
#include <iostream>
#include <cstring>
using namespace std;
int main()  { 
  int *pointer; 
  int var = 300;
  pointer = &var;
  cout << "Value of variables - " << *pointer << endl;
  cout << "Address of pointer - " << pointer << endl;
  return 0;
}
——————— output ——————
Value of variables - 300
Address of pointer - 0x7ffc829a8d44

——————————— Ctime functions ——————————— 
#include <iostream>
#include <ctime>
using namespace std ; 

int main()  { 

  time_t gettime = time(0) ;
  char *stringtime = ctime(&gettime); //ctime it char type

  cout << "String time is : " << stringtime << endl;

  tm* structtime = localtime(&gettime); //localtime or gmtime are tm structure type, rest are char types
  cout << "year " << 1970 + structtime->tm_year << endl ; //time elapsed since January 1, 1970

  return 0;
}

———— output ———————— 
year 2088
——————————— Basic input/output ——————————— 

<iostream > - This file defines the cin, cout, cerr and clog objects, which correspond to the standard input stream, the standard output stream, 
the un-buffered standard error stream and the buffered standard error stream, respectively
<fstream> - This file declares services for user-controlled file processing
<iomainp> - This file declares services useful for performing formatted I/O with so-called parameterized stream manipulators, such as setw and setprecision.

#include <iostream>
using namespace std;
 
int main() {
   char name[50];
   char str[25] = "this will be buffered";
   cout << "Please enter your name: ";
   cin >> name; 
   cout << "Your name is: " << name << endl;
   clog << "Error message : " << str << endl;   //this output will be buffered
}

—— output —— 
Please enter your name: Alan
Your name is: Alan
Error message : this will be buffered
————————————— *this pointer ————————————— 
 this pointer is used to represent the address of an object inside a member function. For example, consider an object obj calling one of its member function say method() as obj.method(). Then, this pointer will hold the address of object obj inside the member function method(). 
It should be noted that, friend function and static function cannot have this pointer. It's because friend function is not a member function of the class. 
And static function can be invoked without initialization of an object, i.e, static functions are not associated with any object.  

class ClassName {

       private:   
         int dataMember;
 
       public:
           method(int a) {

   // this pointer stores the address of object obj and access dataMember
               this->dataMember = a;
               ... .. ...
           } 
}

int main() {

    ClassName obj;
    obj.method(5);
    ... .. ...
————update simple object as follows - ———— 
#include <iostream>
using namespace  std;

class testbike { 
public : 
  char* bikename;
  int bikeid;

  void getbikedata(char *pointer) {  
    cout << "NAme of the biked passed in object : " << pointer << endl;
    cout << "Original name of the bike : " << this->bikename << endl;
    this->bikename = pointer;
    cout << "New name got updated is this->bikename is : " << this->bikename << endl;
  }

};

int main() { 
  testbike mybike; 
  mybike.getbikedata("Apache2-Suzuki");
  return 0;
}
—————— output ———— 
NAme of the biked passed in object : Apache2-Suzuki
Original name of the bike : 
New name got updated is this->bikename is : Apache2-Suzuki
—————— ———— exercise 2 ——————————— 
#include<iostream> 
using namespace std; 
  
/* local variable is same as a member's name */
class Test 
{ 
  private: 
     int x; 
  public: 
     void setX (int x) 
       { 
           // The 'this' pointer is used to retrieve the object's x 
           // hidden by the local variable 'x' 
           cout << "before this :" << this->x << endl;
           this->x = x; 
           cout << "after this :" << this->x << endl;
       } 
     void print() { cout << "final x = " << x << endl; } 
}; 
  
int main() 
{ 
   Test obj; 
   int x = 20; 
   obj.setX(x); 
   obj.print(); 
   return 0; 
} 
————output ———— 
before this :1059436624
after this :20
final x = 20
——————————— exercise 3 - this pointer ———— 
#include<iostream> 
using namespace std; 
  
class Test 
{ 
private: 
  int x ; 
  int y ; 
public: 
  Test(int x = 0, int y = 0) {   //this is constructor since there is no return type.
    this->x = x; this->y = y; 
  } 
  Test setX(int a) {  //here return type of this setX menthod is class Test itself.
      this->x = a; 
      return *this; 
  } 
  Test setY(int b) {  
    this->y = b; 
    return *this; 
  } 
  void print() { 
    cout << "x = " << x << " y = " << y << endl; 
    cout << "this->x :" << this->x << endl;
    cout << "this->y :" << this->y << endl;    
  } 
}; 
  
int main() 
{ 
  Test obj1(5, 5); 
  // Chained function calls.  All calls modify the same object 
  // as the same object is returned by reference 
  obj1.setX(10).setY(20); 
  
  obj1.print(); 
  return 0; 
} 
—————— output ———— 
x = 10 y = 5
this->x :10
this->y :5
——————————— exercise 4 - this pointer ———— 
#include <iostream>
using namespace std;

class racer {
char name[20];
int score; 
public: 
  void getracerinfo() { 
    cout << "Enter racer name :" << endl;
    cin >> name ;
    cout << "Enter score of the racer : " << endl;
    cin >> score ;
    }
  racer findwinner(racer r2, racer r3) { 
    if ( r2.score > r3.score && r2.score > this->score) 
        return r2;
    else if  ( r3.score > r2.score && r3.score > this->score) 
        return r3;
    else if  ( this->score > r3.score && this->score > r2.score) 
        return *this;
  }

  void displaywinner() { 
    cout << "Name of the racer : " << this->name << endl;
    cout << "Final score :" << this->score  << endl;
  }
};

int main() { 
  racer final, r1, r2, r3;
  r1.getracerinfo();
  r2.getracerinfo();
  r3.getracerinfo();
  final = r1.findwinner(r2, r3);
  final.displaywinner();
  return 0;
}

———— output ———— 
Enter racer name :
Allan
Enter score of the racer : 
40
Enter racer name :
Rick 
Enter score of the racer : 
49
Enter racer name :
Orion
Enter score of the racer : 
65
Name of the racer : Orion
Final score :65

———————————— Excercise 5 - this pointer with class and constructor ———— 
#include<iostream> 
using namespace std; 
  
class Test 
{ 
private: 
  int x; 
public: 
  Test(int x) { this->x = x; }  //this is class constructor , there is no return type.
  void change(Test *t) {  //this is function since it has return type
  this->x = t->x; 
  } 
  void print() { cout << "x = " << x << endl; } 
}; 
  
int main() 
{ 
  Test obj(30); 
  Test *ptr = new Test (100); //new way to initialize pointer to class.
  obj.change(ptr); 
  obj.print(); 
  return 0; 
}
———————output ———————
x = 100
————— ———————— Classes and objects ————————— —————— 
————— Scenario 1 = Simple class ————— 
#include <iostream>
using namespace std;

class myblueprint { 
  public : 
    char *name;
    int id;
};

int main() { 
  myblueprint A;
  A.name = "Allan";
  A.id = 2000;
  cout << "First candidate name: "<< A.name << endl;
  cout << "First candidate id : "<< A.id << endl;
  return 0;
}
—————— output —————— 
First candidate name: Allan
First candidate id : 2000

————— Scenario 2 = Base and Derived class ————— 
class derived-class: access-specifier base-class

Where access-specifier is one of public, protected, or private, and base-class is the name of a previously defined class. If the access-specifier is not used, then it is private by default.

#include <iostream>
using namespace std;

class baseclass { 
  public: 
  //function 
      void setname(char n){ 
        publicname = n;
        protectedname = n;
        privatename = n;
     }

      void setid(int i) { 
        publicid = i;
        protectedid = i;
        privateid = i;
      }  
    char publicname;
    int  publicid;
  protected:
    char protectedname;
    int  protectedid;
  private:
    char privatename;
    int  privateid;

};

class derivedclass: public baseclass { 
  public: 
    char getname() { 
//      return publicname; //this will print a
//      return protectedname ; //this will print a
        return privatename;  //this will error out since other classes cannot access private objects
        
    }
    int getid() { 
//      return publicid;  //this will print 10
//      return protectedid; //this will print 10
        return privateid;  //this will error out since other classes cannot access private objects
    }

};

int main() { 
  derivedclass myinfo;
  myinfo.setname('a');
  myinfo.setid(10);
  
  cout << "Name : " << myinfo.getname() << endl;
  cout << "Id : "  << myinfo.getid() << endl;

  return 0;
}
————————————— Scenario 3 — Multiple Inheritance—————————————— 

#include <iostream> 
using namespace std;

 
//set parameters
class areaclass {
  public : 
    float width;
    float height;
    void setdata(int w, int h) {  
      width = w;
      height = h;
    }
};

//function
class costclass { 
public: 
  double costnumber(double area) {  
    return area * 90;
  }
};

//get the value
class derivedclass : public areaclass , public costclass { 
public:
  int getarea() {  
    return (width * height); 
  }
};

int main() { 
  double finalcost;
  double area;
  derivedclass ref;
  ref.setdata(200,100);
  area = ref.getarea();
  finalcost = ref.costnumber(area); 
  cout << "Area : " <<  area << endl;
  cout << "Cost : " << finalcost << endl;
  return 0;
}

———— output ———— 
Area : 20000
Cost : 1.8e+06

————————————— Scenario 4— Overloading —————————————— 

You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You cannot overload function declarations that differ only by return type.

#include <iostream>
using namespace std;
 
class printData {
   public:
      void print(int i) {
        cout << "Printing int: " << i << endl;
      }
      void print(double  f) {
        cout << "Printing float: " << f << endl;
      }
      void print(char* c) {
        cout << "Printing character: " << c << endl;
      }
};

int main(void) {
  printData ptf;
  ptf.print(4) ;
  ptf.print("what a day");
  ptf.print(43.993);

  return 0;
}
————— output ————— 
Printing int: 4
Printing character: whats a day
Printing float: 43.993

————————————— Scenario  —  Overloading operator using without constructor and void return type —————————————— 

#include <iostream>
using namespace std;


class printclass { 
  private : 
    int var1 = 100 ; 
    int var2 = 300 ;

  public : 
  void printnow() { 
    cout << "First variable value " << var1 << endl;
    cout << "Second variable value " << var2 << endl;
  }
  
  void operator - () { 
    var1 = (5) * var1;
    var2 = (4) * var2; 
  }
};


int main() { 
  printclass P;
  -P;       //use operator for calculation here
  P.printnow(); 
  return 0;
}

———— output ——— 
First variable value 500
Second variable value 1200

————————————— Scenario  —  Overloading operator using constructor and class as return type —————————————— 
#include <iostream>
using namespace std;

class Distance { 
  public : 
    int length; 
    int height;

    Distance() {  					//this is empty constructor 
      length = 0; 
      height = 0;
    }

    Distance(int a , int b) { 			//this is constructor 
      length = a; 
      height = b;
    }
    void printall() { 
      cout << "Length  : " << length << endl;
      cout << "Height  : " << height << endl;
    }

  Distance operator * () { 					// here class is used as return type 
      length = length * 2;    //here operator is - and actual operation is multipilcation , so doesnt matter
      height = height * 2;
      return Distance( length, height);
  }

}; 
int main() {
  Distance obj(30, 40);
  *obj;   
  obj.printall() ;
  return 0;
}

———— output —— 
Length  : 60
Height  : 80

————————————— Scenario  —  Overloading operator Assignment operator  —————————————— 

#include <iostream>
using namespace std;

class Distance {
    
    public :
    int id ;
    int age;
    
    Distance(){
        id = 0 ; age = 0;
    }
    Distance(int a , int b) {
        id = a; age = b;
    }
    void operator = ( const Distance &o) {
        id = o.age;
        age = o.id;
    }
    void printall() {
        cout << "Id is - " << id << endl << "Age is : " << age << endl;
    }
};

int main() {
    
    Distance o1;
    Distance o2(30 , 40);
    o2.printall();
    o1 = o2;
    cout << "swapping below" << endl;
    o1.printall();
    return 0;
}


——— output ———— 
Id is - 30
Age is : 40
swapping below
Id is - 40
Age is : 30

——————————  Scenario  —  Overloading operator Subscripting [] Operator —————————— 

#include <iostream>
using namespace std;
const int SIZE = 10;

class safearay {
private:
    int arr[SIZE];
    
public:
    safearay() {
        register int i;
        for(i = 0; i < SIZE; i++) {
            arr[i] = i;
        }
    }
    
    int &operator[](int i) {
        if( i > SIZE ) {
            cout << "Index out of bounds" <<endl;
            // return first element.
            return arr[0];
        }
        
        return arr[i];
    }
};

int main() {
    safearay A;
    
    cout << "Value of A[2] : " << A[2] <<endl;
    cout << "Value of A[5] : " << A[5]<<endl;
    cout << "Value of A[12] : " << A[12]<<endl;
    
    return 0;
}

————— output ——— 
Value of A[2] : 2
Value of A[5] : 5
Value of A[12] : Index out of bounds
0

————————————— Scenario  —  Class Member Access Operator (->) Overloading —————————— 

The class member access operator (->) can be overloaded but it is bit trickier. It is defined to give a class type a "pointer-like" behavior. The operator -> must be a member function. If used, its return type must be a pointer or an object of a class to which you can apply. 
The operator-> is used often in conjunction with the pointer-dereference operator * to implement "smart pointers." These pointers are objects that behave like normal pointers except they perform other tasks when you access an object through them, such as automatic object deletion either when the pointer is destroyed, or the pointer is used to point to another object.




————————————— Scenario  —  Overloading operator Function call operator  —————————————— 

#include <iostream>
using namespace std;

class Distance {
    public :
    int id;
    int age;
    int km;
    
    Distance() {
        id = 0 ; age = 0 ;  km = 0;
    }
    Distance(int a, int b, int n) {
        id = a ; age = b ; km = n;
        
    }
    void printall() {
        cout << "Id " << id << " Age " << age << " Km " << km << endl;
    }
    
    Distance operator () ( int aa, int bb, int nn) {
        Distance D1;
        D1.id = aa ; D1.age = bb ; D1.km = nn;
        return D1;
    }
};

int main() {
    Distance f_in(10, 20 , 40);
    Distance f_out;
    f_out.printall();
    f_out = f_in(99, 99 , 99); //Function operator passes values to object
    f_out.printall();
    return 0;
}
——— output ————— 

Id 0 Age 0 Km 0
Id 99 Age 99 Km 99



————————————— Scenario  —  Overloading operator —————————————— 

#include <iostream>
using namespace std;

class overloadnow { 
public: 
  int var;
  overloadnow(int x) { 
    this->var = x;
    cout << "class constructor value " << this->var << endl;
  } 
  void printinfo(int y) { 
      this->var = y;
      cout << "first overload1 " << this->var << endl;
  }

  void printinfo(char *c) { 
    cout << "second overload " << c << endl;
  }

  void printinfo(overloadnow *p) { 
    this->var = p->var;
    cout << "third pointer overload " << this->var << endl;
  }

};

int main () { 
  overloadnow myobj(5);
  myobj.printinfo(50);
  myobj.printinfo("nice");
  overloadnow *ptr = new overloadnow(20);
  ptr->var = 400;
  myobj.printinfo(ptr);
  return 0;
}
———output —— 
class constructor value 5
first overload1 50
second overload nice
class constructor value 20
third pointer overload 400
——————————————Scenario  7 - Simple Polymérisation —————— 
In this example, we have two functions with same name but different number of arguments. Based on how many parameters we pass during function call determines which function is to be called, this is why it is considered as an example of polymorphism because in different conditions the output is different. Since, the call is determined during compile time thats why it is called compile time polymorphism

#include <iostream>
using namespace std;

class Add {
public:
  int sum(int num1, int num2){
     return num1+num2;
  }
  int sum(int num1, int num2, int num3){
     return num1+num2+num3;
  }
};

int main() {
  Add obj;
  //This will call the first function
  cout<<"Output: "<<obj.sum(10, 20)<<endl;
  //This will call the second function
  cout<<"Output: "<<obj.sum(11, 22, 33);
  return 0;
}

———— output ———— 
Output: 30
Output: 66
——————————————Scenario  8 - Runtime Polymérisation —————— 
Function overriding is an example of Runtime polymorphism.
Function Overriding: When child class declares a method, which is already present in the parent class then this is called function overriding, here child class overrides the parent class. In case of function overriding we have two definitions of the same function, one is parent class and one in child class. The call to the function is determined at runtime to decide which definition of the function is to be called, thats the reason it is called runtime polymorphism

#include <iostream>
using namespace std;

class dad { 
public:
  void printnow() { 
    cout << "this is dad print "  << endl;
  }
};

class son : public dad { 
public: 
  void printnow() { 
    cout << "this is son print " << endl;
  }
};

int main () { 
  dad o1;
  son o2;
  o1.printnow();
  o2.printnow();
  return 0;
}
————output ———— 
this is dad print
this is son print 
——————————————Scenario  9 - Simple Polymérisation —————— 
The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in 
more than one form.

#include<iostream> 
using namespace std; 
  
class Test 
{ 
private: 
  int x; 
public: 
  Test(int x) { this->x = x; 
  cout << "original value of x : " << x << endl; }  //this is class constructor , there is no return type.

  void change(Test *t) {  //this is function since it has return type
  this->x = 200; 
  cout << "print updated value of x : " << this->x << endl;
  } 
 
}; 
  
int main() 
{ 
  Test obj(30); 
  Test *ptr = new Test(100); //new way to initialize pointer to class.
  obj.change(ptr);  
  return 0; 
}
———— output ——— 
original value of x : 30
original value of x : 100
print updated value 200
————————————— Polymerization and plus operator ———————— 
#include <iostream>
using namespace std;

class Complex { 
  public : 
  int rank; int image;
  Complex (int x , int y) { this->rank = x ; this->image = y;};
    
  Complex operator + ( Complex const &obj) { 
      Complex final(0,0);
      rank = rank + obj.rank;
      image = image + obj.image;
      final.rank = rank;
      final.image = image;
      return final;
  };
  void printdata(Complex o3) { 
      cout << "print final output "  <<o3.rank << endl ;
      cout << "image is " << o3.image << endl;
    }
};

int main() { 
  Complex o1(10,3), o2(20,4);       //this is constructor
  Complex o3 = o1 + o2;             //this is operator
  o3.printdata(o3);
  return 0;
}

——— output ——— 
print final output 30
image is 7
——————————————— How to use virtual keyword - with pointer and address —————————————— 
#include <iostream> 
using namespace std;
 
class Shape {
   protected:
      int width, height;
      
   public:
      Shape( int a = 0, int b = 0){
         width = a;
         height = b;
      }
      virtual int area() {   //if we dont use virtual then compiler thinks user wants to run this function
      //if we use virtual then compiler connects address of rectangle class to shape pointer and executes that function( Shape *shape; )
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
class Rectangle: public Shape {
   public:
      Rectangle( int a = 0, int b = 0):Shape(a, b) { }
      
      int area () { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      Triangle( int a = 0, int b = 0):Shape(a, b) { }
      
      int area () { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }
};

// Main function for the program
int main() {
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);

   // store the address of Rectangle
   shape = &rec;
   
   // call rectangle area.
   shape->area();

   // store the address of Triangle
   shape = &tri;
   
   // call triangle area.
   shape->area();
   
   return 0;
}
————— output ———— 
Rectangle class area :
Triangle class area :

——————————————— How to use pure virtual keyword - without pointer and address —————————————— 
#include <iostream>
using namespace std;
 
// Base class
class Shape {
   public:
      // pure virtual function providing interface framework.
      virtual int getArea() = 0;
      void setWidth(int w) {
         width = w;
      }
   
      void setHeight(int h) {
         height = h;
      }
   
   protected:
      int width;
      int height;
};
 
// Derived classes
class Rectangle: public Shape {
   public:
      int getArea() { 
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      int getArea() { 
         return (width * height)/2; 
      }
};
 
int main(void) {
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   
   // Print the area of the object.
   cout << "Total Rectangle area: " << Rect.getArea() << endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   
   // Print the area of the object.
   cout << "Total Triangle area: " << Tri.getArea() << endl; 

   return 0;
}
—————— output —— 
Total Rectangle area: 35
Total Triangle area: 17
———————————————— Abstraction and Encapsulation ————————— 
Data abstraction refers to providing only essential information to the outside world and hiding their background details, i.e., to represent the needed information in program without presenting the details. Below class adds numbers together, and returns the sum. The public members - addNum and getTotal are the interfaces to the outside world and a user needs to know them to use the class. The private member total is something that the user doesn't need to know about, but is needed for the class to operate properly.

Data encapsulation is a mechanism of bundling the data, and the functions that use them and data abstraction is a mechanism of exposing only the interfaces and hiding the implementation details from the user.

#include <iostream>
using namespace std;

class Adder {
   public:
      // constructor
      Adder(int i = 0) {
         total = i;
      }
      
      // interface to outside world
      void addNum(int number) {
         total += number;
      }
      
      // interface to outside world
      int getTotal() {
         return total;
      };
      
   private:
      // hidden data from outside world
      int total;
};

int main() {
   Adder a;
   
   a.addNum(100);
   a.addNum(200);
   a.addNum(300);

   cout << "Total " << a.getTotal() <<endl;
   return 0;
}
——— output ——— 
Total 600 
—————————————— another example but this time using constructor and all in one class. No child class ————————— 
#include <iostream>
using namespace std;

class multiplyallnow { 
  private : 
    double onlytothisclasstotal ;
  public : 
    //constructor
    multiplyallnow(int x) { onlytothisclasstotal = x; }

    //multiply method
    double mul(int a) { 
      return ( onlytothisclasstotal * a) ;
    }
}; 

int main() { 
  multiplyallnow A(10);
  
  cout << "Final value " << A.mul(20) << endl;
  
  return 0;
}
————— output ———— 
Final value 200

—————————— Interfaces ( Abstract class)  ——————————— 
The purpose of an abstract class (often referred to as an ABC) is to provide an appropriate base class from which other classes can inherit. Abstract classes cannot be used to instantiate objects and serves only as an interface. Attempting to instantiate an object of an abstract class causes a compilation error.

Thus, if a subclass of an ABC needs to be instantiated, it has to implement each of the virtual functions, which means that it supports the interface declared by the ABC. Failure to override a pure virtual function in a derived class, then attempting to instantiate objects of that class, is a compilation error.

Classes that can be used to instantiate objects are called concrete classes.


#include <iostream>
using namespace std;


class outingteam { 
  public : 
  int boys; int gals; 
  virtual void gettotalsize() = 0; 
  void setboys(int a) {
    boys = a; 
  }
  void setgals(int b) { 
    gals = b;
  }  
  protected:
    int strenth;
}; 

class firstteam : public outingteam { 
  public: 
    void gettotalsize() { 
        cout << "Total : " << boys * gals << endl;     //accessing base class variables
        cout << "Strenth : " << boys + gals << endl;
    }  
}; 
 

int main() {
  firstteam f1;
  f1.setboys(300);   //calling base class method 
  f1.setgals(400);   //calling base class method here 
  f1.gettotalsize();  //calling derived class method
  return 0;
}
————— output ——— 
Total : 120000
Strenth : 700


- —————————————— Files ——————————— 

Data types - 
ofstream = This data type represents the output file stream and is used to create files and to write information to files.
Ifstream = This data type represents the input file stream and is used to read information from files.
fstream = This data type represents the file stream generally, and has the capabilities of both ofstream and ifstream which means it can create files, write information to files, and read information from files.

COUT is to write to screen or output 
CIN  is to read from screen or scan user input 

#include <iostream>
#include <fstream> 
using namespace std;


int main() { 
  char data[100];
  ofstream writetothisfile;
  writetothisfile.open("100test.txt");
  cout << "Enter your data that you wish to update to file " << endl;

  cin.getline(data, 100);
  writetothisfile << data << endl;
  writetothisfile.close();
  
  
  ifstream readfromthisfile;
  readfromthisfile.open("100test.txt");
  readfromthisfile >> data ;
  cout << data << endl;

  readfromthisfile.close();
  return 0;
}
———— output ——— 
Enter your data that you wish to update to file 
allan gonsalves
allan

——————————— Exception handling ————————————— 
try {
   // protected code
} catch( ExceptionName e1 ) {
   // catch block
} catch( ExceptionName e2 ) {
   // catch block
} catch( ExceptionName eN ) {
   // catch block
}

The exception handler is declared with the catch keyword immediately after the closing brace of the try block. The syntax for catch is similar to a regular function with one parameter. The type of this parameter is very important, since the type of the argument passed by the throw expression is checked against it, and only in the case they match, the exception is caught by that handler. Multiple handlers (i.e., catch expressions) can be chained; each one with a different parameter type. Only the handler whose argument type matches the type of the exception specified in the throw statement is executed.

If an ellipsis (...) is used as the parameter of catch, that handler will catch any exception no matter what the type of the exception thrown.

—————————— Simple try catch with msg ————————— 
#include <iostream>
using namespace std;

double division(int a , int b) { 
  return a /b ;

}; 

int main() {
  double result;
try { 
  result = division(30,0);
  cout << "result : " << result << endl ;
} catch (const char* msg ) { 
  cerr << msg << endl;
}  
  return 0;
}
————— output ————— 
Floating point exception: 8

—————————— try catch with msg with catch with same parameter type  ————————— 

#include <iostream>
#include <fstream>
using namespace std;


int main () { 
  int num;
  cout << "Enter any number" << endl;
  cin >> num ;

  try { 
    if (num < 0) 
      throw num;
  } catch  ( int n1){  //use same parameter type passed by throw command
//or you use below 
//   Catch ( …)  { 
      cout << "Donot enter less than zero " << n1 << endl;
  }
  return 0;
}
—————output ————— 
Enter any number
-2
Donot enter less than zero -2
———————————————try catch using NULL parameter in function call —————————— 


#include <iostream> 
using namespace std; 
  
// This function signature is fine by the compiler, but not recommended. 
// Ideally, the function should specify all uncaught exceptions and function 
// signature should be "void fun(int *ptr, int x) throw (int *, int)" 
void fun(int *ptr, int x) 
{ 
    if (ptr == NULL) 
        throw ptr; 
    if (x == 0) 
        throw x; 
    /* Some functionality */
} 
  
int main() 
{ 
    try { 
       fun(NULL, 0); 
    } 
    catch(...) { 
        cout << "Caught exception from fun()"; 
    } 
    return 0; 
}
—————— output ————— 
Caught exception from fun()

————————— Class in try -catch block - —————————————— 

When an exception is thrown, all objects created inside the enclosing try block are destructed before the control is transferred to catch block.
#include <iostream> 
using namespace std; 
  
class Test { 
public: 
   Test() { cout << "Constructor of Test " << endl; } 
  ~Test() { cout << "Destructor of Test "  << endl; } 
}; 
  
int main() { 
  try { 
    Test t1; 
    throw 10; 
  } catch(int i) { 
    cout << "Caught " << i << endl; 
  } 
} 

————— output ————————— 
Constructor of Test 
Destructor of Test 
Caught 10

———————————————— Dynamic Memory ———————————— 
The stack − All variables declared inside the function will take up memory from the stack.
The heap − This is unused memory of the program and can be used to allocate the memory dynamically when program runs.

You can allocate memory at run time within the heap for the variable of a given type using a special operator in C++ which returns the address of the space allocated. This operator is called new operator. If you are not in need of dynamically allocated memory anymore, you can use delete operator, which de-allocates memory that was previously allocated by new operator.

#include <iostream>
using namespace std;

int main () {
   double* pvalue  = NULL; // Pointer initialized with null
   pvalue  = new double;   // Request memory for the variable
 
   *pvalue = 29494.99;     // Store value at allocated address
   cout << "Value of pvalue : " << *pvalue << endl;

   delete pvalue;         // free up the memory.

   return 0;
}

———— output —————— 
Value of pvalue : 29495

—————— new cases of Dynamic memory allocation ————— 
char* pvalue  = NULL;         // Pointer initialized with null
pvalue  = new char[20];       // Request memory for the variable

—————— new cases of Dynamic memory allocation ————— 

double** pvalue  = NULL;      // Pointer initialized with null 
pvalue  = new double [3][4];  // Allocate memory for a 3x4 array 

delete [] pvalue;            // Delete array pointed to by pvalue


——————— simple C++ character pointer ————— 

#include <iostream>
using namespace std;

int main() { 
  char str[13] = "What a day” ;

  char *pointer = str;
 
    cout << "print 1 " << pointer << endl;
  return 0 ;
}

——— output ————— 
print 1 What a day

———————————NAMESPACE  ———————————— 
you might be writing some code that has a function called xyz() and there is another library available which is also having same function xyz(). Now the compiler has no way of knowing which version of xyz() function you are referring to within your code. namespace is designed o differentiate similar functions, classes, variables etc. with the same name available in different libraries

#include <iostream>
using namespace std;

namespace first { //this namespace defined like a class
  void fun(int i) { 
    cout << "Value from first " << i << endl;
  }
}

namespace second  { 
  void fun(int i) {
      cout << "Value from second " << i << endl;
  }
}

int main() { 
  first::fun(40) ;   // use :: to call the function within namespace
  second::fun(50);
  return 0;
}
———— output ————— 
Value from first 40
Value from second 50


——————————— TEMPLATES———————————— 

The concept of templates can be used in two different ways:

1) Function Templates
2) Class Templates

The simple idea is to pass data type as a parameter so that we don’t need to write same code for different data types. For example a software company may need sort() for different data types. Rather than writing and maintaining the multiple codes, we can write one sort() and pass data type as a parameter. C++ adds two new keywords to support templates: ‘template’ and ‘typename’. The second keyword can always be replaced by keyword ‘class’. Templates are expanded at compiler time. This is like macros. The difference is, compiler does type checking before template expansion. The idea is simple, source code contains only function/class, but compiled code may contain multiple copies of same function/class.

template <class T>
T someFunction(T arg)
{
   ... .. ...
}


See diagram at https://www.geeksforgeeks.org/templates-cpp/

#include <iostream>
using namespace std;

template <typename sample>
sample function(sample x, sample y) { 
  return (x > y) ? x: y;
}

int main() { 
  cout << "Max of (4,7) --- " << function<int> (4,7) << endl;
  cout << "Ascending order of A and P --- " << function<char> ('A','P') << endl;
  cout << "Max of float(5.4,1.3) --- " << function<float> (5.4,1.3) << endl;
  return 0;
}
————— output ———— 
Max of (4,7) --- 7
Ascending order of A and P --- P
Max of float(5.4,1.3) --- 5.4


———— Example of  Function Template ( passing a value) ———————— 

#include <iostream>
using namespace std;

template <typename mytem>
mytem fun1(mytem x, mytem y) { //defining int type function
  return x * y;
}

template <typename mytem1> //defining second template accepting array type
mytem1 fun2(mytem1 arr[], mytem1 i){ 
  for (int j = 0; j < i ; j++) { 
    cout << " Values of array " << arr[j] << endl;
  }
}

int main() { 
  int arr[] =  { 4,2,6,7,3,7};
  int size = sizeof(arr)/ sizeof(int);
  cout <<  fun1(4,5) << endl;
  fun2(arr, size);
  return 0;
}

——— output ———— 
20
 Values of array 4
 Values of array 2
 Values of array 6
 Values of array 7
 Values of array 3
 Values of array 7

———— Example of  Function Template ( call by reference ) ———————— 

#include <iostream>
using namespace std;

template <typename T>
  void swapfun( T &x , T &y) { 

    T holdvalue;
    holdvalue = y;
    y = x;
    x = holdvalue;

  }
int main() { 
  int i1 = 100, i2 = 200; 
  
  cout << "Before Swap - " << i1 << ": " << i2 << endl;
  swapfun( i1, i2) ;
  cout << "Post Swap - " << i1 << ": " << i2 << endl;
  return 0;
} 

—— output —— 
Before Swap - 100: 200
Post Swap - 200: 100


———— Example of  Class Template ———————— 

Class Templates Like function templates, class templates are useful when a class defines something that is independent of data type. Can be useful for classes like LinkedList, BinaryTre, Stack, Queue, Array, etc. Like function templates, you can also create class templates for generic class operations.Sometimes, you need a class implementation that is same for all classes, only the data types used are different. Normally, you would need to create a different class for each data type OR create different member variables and functions within a single class. In below declaration -  T is the template argument which is a placeholder for the data type used.

Inside the class body, a member variable var and a member function someOperation() are both of type T.

template <class T>
class className
{
   ... .. ...
public:
   T var;
   T someOperation(T arg);
   ... .. ...
};

To create a class template object, you need to define the data type inside a < > when creation
className<dataType> classObject;

—————— Example —————— 
#include <iostream>
using namespace std;

template <class T>
class calculator { 
  public : 
    T num1;
    T num2;
    T result;
      
    calculator(T x, T y) { 
      num1 = x;
      num2 = y;
    }

    T addition() { 
      return result = num1 + num2;
    }
 
};

int main() { 

  calculator<int> obj1(2,4);
  cout << " Addition int value : " << obj1.addition() << endl;
  calculator<float> obj2(4.3, 5.3);
  cout << " Addition float value : " << obj2.addition() << endl;
  
  return 0;
}

——————— output —— 
 Addition int value : 6
 Addition float value : 9.6

—————— Can there be more than one arguments to templates?— YES ———— 

#include <iostream>
using namespace std;

template <class T , class S >
class calculator {
    public :
    T x;
    S y;
    S result;
    
    calculator(T n1, S n2) {
        x = n1;
        y = (T) n2; //This is casting from float to int
    }
    
    S addition() {
        return result =  x + y;
    }
};

int main() {
    calculator<int,float> obj1(3,2.5);  //here 3,2 is for constructor feed.
    cout << " Addition of 2 numbers - " << obj1.addition() << endl;
    return 0;
}
———— output ———— 
 Addition of 2 numbers - 5.5


———————— Can we pass nontype parameters to templates? ———————— 
#include <iostream> 
using namespace std; 
   
template <class T, int max> 
int arrMin(T arr[], int n) 
{ 
   int m = max; 
   for (int i = 0; i < n; i++) 
      if (arr[i] < m) 
         m = arr[i]; 
   return m; 
} 
   
int main() 
{ 
   int arr1[]  = {10, 20, 15, 12}; 
   int n1 = sizeof(arr1)/sizeof(arr1[0]); 
   
   char arr2[] = {1, 2, 3}; 
   int n2 = sizeof(arr2)/sizeof(arr2[0]); 
   
   // Second template parameter to arrMin must be a constant 
   cout << arrMin<int, 10000>(arr1, n1) << endl; 
   cout << arrMin<char, 256>(arr2, n2)  << endl; 
   return 0; 
} 
————output ——— 
10
1


——————————— Void pointers ———————————— 
This is a special type of pointer available in C++ which represents absence of type. void pointers are pointers that point to a value that has no type (and thus also an undetermined length and undetermined dereferencing properties).
This means that void pointers have great flexibility as it can point to any data type. There is payoff for this flexibility. These pointers cannot be directly dereferenced. They have to be first transformed into some other pointer type that points to a concrete data type before being dereferenced.

See below how we took value of &c and &I into a void point just to pass address and then used pointer with concrete data type for proper assignment 

#include <iostream>
using namespace std;

//*vp below is called void pointer , it just pass address of incoming parameter to real pointer 
//actualcharpoint and actualintpointer
void decrease (void *vp, int size) { 
  if ( size == sizeof(char)) { 
    char *actualcharpoint = (char*) vp;
    (*actualcharpoint)--;
    cout << "Previoud value of char : " << *actualcharpoint << endl;
  } 
  else if ( size == sizeof(int)) { 
    int *actualintpointer = (int*) vp;
    (*actualintpointer)--;
    cout << "Previous value of int :" << *actualintpointer << endl;
  }
  
}
int main() { 
  char c = 'x';
  int i = 10;
  cout << "Original value of char : " << c << endl;
  decrease(&c, sizeof(char)) ;
  cout << "Orginal value of int : " << i << endl;
  decrease(&i, sizeof(int));
  return 0;
}
————— output ——— 
Original value of char : x
Previoud value of char : w
Orginal value of int : 10
Previous value of int :9

——————————————— String operations ————————————— 

#include <iostream>
using namespace std;


//insert(pos, string) 
//find a target string in s1 = find(target)
//replace(pos, length_of_portion, string_to_replace) 

int main() { 
  string s1 = "What a day"; 
  string s2 = "nice day indeed";
  string sfinal ;

 cout << "size of s1 " << sizeof(s1) << endl;
 sfinal = s1.append(" sunday");
 cout << "Appended string : " << sfinal << endl;

 if ( s1.compare(s2) == 0) { 
    cout << "String compare match " << endl;
 } 
 else { 
    cout << "String compare mismatch " << endl;
 }

  cout << "Inserted new stuff into s1 " << s1.insert(3, "----wow----") << endl;
  cout << "Find day into string position - " << s1.find("day") << endl;
  cout << "Replacement of s2 - " << s2.replace(5,4," ___station___") << endl;
  return 0;
}
——————— output ————— 
size of s1 24
Appended string : What a day sunday
String compare mismatch 
Inserted new stuff into s1 Wha----wow----t a day sunday
Find day into string position - 18
Replacement of s2 - nice  ___station___indeed

———————————————— string operations 2 ———————— 

#include <iostream> 
#include <cstring> 
using namespace std; 
  
int main() 
{ 
    char s1[10] = "Hello"; 
  
    // return length of s1 
    cout << strlen(s1) << endl; 
  
    char s2[50]; 
  
    // copies s1 into s2 
    strcpy(s2, s1); 
    cout << s2 << endl; 
  
    char s3[10] = "World"; 
  
    // concatenates s3 into s2 
    strcat(s2, s3); 
    cout << s2 << endl; 
  
    char s4[50] = "HelloWorld"; 
  
    // return 0 if s2 and s4 are equal. 
    if (strcmp(s2, s4) == 0) 
        cout << "true" << endl; 
    else
        cout << "false" << endl; 
  
    char s5[30]; 
  
    // copies first 5 chars of s2 into s1 
    strncpy(s5, s4, 5); 
    cout << s5 << endl; 
  
    char target[10] = "Hello"; 
  
    // search for target string in s4 
    if (strstr(s4, target) != NULL) 
        cout << "true" << endl; 
    else
        cout << "false" << endl; 
  
    return 0; 
} 
———— output ———— 
5
Hello
HelloWorld
true
Hello? ?8?q??
true

——————————————CONTAINERS ——— STL - Standard Template Library —http://www.cplusplus.com/reference/stl/———————— 
The C++ STL (Standard Template Library) is a powerful set of C++ template classes to provide general-purpose classes and functions with templates that implement many popular and commonly used algorithms and data structures like vectors, lists, queues, and stacks. It has following well structured components - 
1. Container - Containers are used to manage collections of objects of a certain kind. There are several different types of containers like deque, list, vector, map etc.
2. Algorithm - Algorithms act on containers. They provide the means by which you will perform initialization, sorting, searching, and transforming of the contents of containers.
3. Iterators - Iterators are used to step through the elements of collections of objects. These collections may be containers or subsets of containers.

————————— Containers - Array ; Deque ; Forward_list , list , map, queue, set , stack ,unordered_map, unordered set ,  vector ———————— 
A container is a holder object that stores a collection of other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements. The container manages the storage space for its elements and provides member functions to access them, either directly or through iterators (reference objects with similar properties to pointers).Containers replicate structures very commonly used in programming: dynamic arrays (vector), queues (queue), stacks (stack), heaps (priority_queue), linked lists (list), trees (set), associative arrays (map). Many containers have several member functions in common, and share functionalities. stack, queue and priority_queue are implemented as container adaptors. Container adaptors are not full container classes, but classes that provide a specific interface relying on an object of one of the container classes (such as deque or list) to handle the elements. The underlying container is encapsulated in such a way that its elements are accessed by the members of the container adaptor independently of the underlying container class used.

———— Sequence Containers ———— > Array ,vector , list , deque , forward list 

————Container Adapters ————> Stack , queue , priority queue 

———— Associative Adapters ————> Set , Multiset , Map, Multimap 

————Unordered Associative Containers ————> Unordered set , unordered_multiset , unordered_map and unordered_multimap 

————Other Containers ————> bitset and Valarray 


————— 1) Vector —————— 
//https://www.codeguru.com/cpp/cpp/cpp_mfc/stl/article.php/c4027/C-Tutorial-A-Beginners-Guide-to-stdvector-Part-1.htm


Vector is a template class that is a perfect replacement for the good old C-style arrays. It is defined as follows 
#include <vector> using namespace std;
vector<T> v;  

It is a template class that will wrap an array of Ts. In this widely used notation, 'T' stands for any data type, built-in, or user-defined class. The vector will store the Ts in a contiguous memory area that it will handle for you, and let you access the individual Ts simply by writing v[0], v[1], and so on, exactly like you would do for a C-style array.


#include <vector>
#include <iostream> 
using namespace std;
int main() { 
  vector<float> values;    // we can also use values(5) and no reserve required as shown in next line below.
  values.reserve(5);      //use () to allocate memory
  int i;
  
  for(i=0; i< 5; i++ ) { 
    values[i] = i;
    cout << "Value of vector : " << values[i] << endl;  //use [] to access member of vector
  }
  return 0;
}
—————— output ———— 
Value of vector : 0
Value of vector : 1
Value of vector : 2
Value of vector : 3
Value of vector : 4

——————— Vector memory : RESERVE ———— 
Vector dynamically allocates, reallocates memory depending on elements get added and grows into it. We can also reserve memory by following syntax
  values.reserve(5); 

————— Difference between below syntax - ——— 
// snip 1:
std::vector<int> v(10);
// snip 2:
std::vector<int> v;
v.reserve(10);
— The first snippet defines a vector containing 10 integers, and initializes them with their default value (0). If we hadn't integers but some user-defined class, vector would call the default ctor 10 times and contain 10 readily constructed objects. The second snippet defines an empty vector, and then tells it to make room for 10 integers. The vector will allocate enough memory to hold at least 10 integers, but will not initialize this memory. If we had no integers, but some user-defined class, the second snippet wouldn't construct any instance of that class.

——————— Vector memory : CAPACITY and SIZE  ———— 
To find out how many elements would fit in the currently allocated storage of a vector, use the capacity() member function. To find out how many elements are currently contained by the vector, use the size() member function.  

#include <vector>
#include <iostream>
using namespace std;


int main() { 
  vector<int> vec; 
  cout << "Vector capacity : " << vec.capacity() << endl;  //Vector capacity : 3
  cout << "Vector size : " <<  vec.size() << endl;        //Vector size : 0

  vec.push_back(10);    //append an element
  vec.push_back(20);    //append an element
  vec.push_back(30);    //append an element
  vec.push_back(40);    //append an element
  cout << "Vector capacity : " << vec.capacity() << endl;  //Vector capacity : 3
  cout << "Vector size : " <<  vec.size() << endl;        //Vector size : 1

  vec.push_back(50);      //here 
  cout << "Vector capacity : " << vec.capacity() << endl;  //Vector capacity :  
  cout << "Vector size : " <<  vec.size() << endl;        //Vector size :  
  return 0;
}

 ——— output ———— 
Vector capacity : 0
Vector size : 0
Vector capacity : 4
Vector size : 4
Vector capacity : 8
Vector size : 5

See how capacity changes , it happens based on the datatype of vector, as here in this case vector in of type int, as we know size of int is 4 bytes so compiler will allocate 4 block of memory ..and when we try to add 5th element , vector::capacity() is doubled what we have currently.

————————— Using class as a data type for Vector —————— 
#include <vector>
#include <iostream>
using namespace std;

class X { 
  public : 
    void setup(int i) { 
      cout << "From class " << i << endl;
    }

}; 

int main() {
  vector<X> myvec(2);     //here vector data type is a class. X is the class data type. 
  myvec[1].setup(20) ;    //this is creating instance of class
  myvec[2].setup(40) ;     //this is creating instance of class
  return 0;
}

—————— output ———— 
From class 20
From class 40

———— ————— Simple array passing as function parameter ——————— 
#include <iostream>
using namespace std;

double getmean(int *array, size_t S) { 
    double result;
    int i;
    for ( i = 0 ; i< S; i++) { 
      result += array[I];
    }
    return result/S;
}


int main() { 

  int nums[] = { 3, 5, 2 , 6, 7, 8};
  int final;
  final = getmean(nums, 6);
  cout << " Mean value is : " << final << endl;
  return 0;
}
————— output ————— 

 Mean value is : 5
———— ————— Simple Vector passing as function parameter , replacement of array in example above ——————— 

#include <iostream>
#include <vector>

double mean(double *array, size_t n)
{
    double m=0;
    for(size_t i=0; i<n; ++i){
        m += array[i];
    }
    return m/n;
}

int main()
{
    std::vector<double> a;
    a.push_back(3);
    a.push_back(5);
    a.push_back(2);
    a.push_back(6);
    a.push_back(7);
    a.push_back(8);
    std::cout<< "Mean result using vector : " << mean(&a[0], 5)<<std::endl;    // will print 3
    return 0;
}
————— output —————— 
Mean result using vector : 4.6

——————————— Iterator —————————— 
Iterators are the way the Standard Library models a common interface for all containers—vector, list, set, deque, and so on. The reason is that operations that are "natural" for one container (like subscripting for vector) do not make sense for other containers. The Standard Library needs a common way of applying algorithms like iterating, finding, sorting to all containers—thus the concept of iterators. An iterator is a handle to a contained element. 


Understanding the second point is crucial when working with vectors or any other standard containers. The controlled sequence is always expressed in terms of [first, one-past-last)—not only for vectors, but also for every function that operates on a range of elements.

————————————— Sample program using Iterator , Pointer and normal loop counter ——————
#include <vector>
#include <iostream> 
using namespace std;

int main()
{
    vector<double> a1;
    vector<double>::const_iterator i;
    a1.push_back(1);
    a1.push_back(2);
    a1.push_back(3);
    a1.push_back(4);
    a1.push_back(5);
    for(i=a1.begin(); i!=a1.end(); ++i){          //begin() = returns an iterator that "points" to the first element in the sequence and end() returns an iterator that "points" to one-past-the-last-element in the sequence
         cout<< "Using Iterator : " << (*i)<< endl;
    } 
    vector<double> a2;
    const double *p;
    a2.push_back(1);
    a2.push_back(2);
    a2.push_back(3);
    a2.push_back(4);
    a2.push_back(5);
    for(p=&a2[0]; p!=&a2[0]+5; ++p){
        cout<< "Using pointer : "<< (*p)<<endl;
    } 
   vector<double> a3;
    int i1;
    a3.push_back(1);
    a3.push_back(2);
    a3.push_back(3);
    a3.push_back(4);
    a3.push_back(5);
    for(i1=0; i1< a3.size(); ++i1){
        cout<< "Using simple counter : " << a3[i1]<<endl;
    }
    return 0; 
}
————— output —————— 
Using Iterator : 1
Using Iterator : 2
Using Iterator : 3
Using Iterator : 4
Using Iterator : 5
Using pointer : 1
Using pointer : 2
Using pointer : 3
Using pointer : 4
Using pointer : 5
Using simple counter : 1
Using simple counter : 2
Using simple counter : 3
Using simple counter : 4
Using simple counter : 5
———————  — Types of for loops — 
for(int i=0;i<SIZE;i++){
    //do something for each iteration;
}
——————— 
vector<int> scores = {77,91,100,88,85,68,95};

for (auto it = scores.begin(); it != scores.end(); ++it){
    //do something for each iteration;
}
———————— 
for (auto& x: scores) //do something for each iteration;

——————————————— How to use List ——http://www.cplusplus.com/reference/list/list/————————— 
front() – Returns the value of the first element in the list
back() – Returns the value of the last element in the list
push_front(g) – Adds a new element ‘g’ at the beginning of the list
push_back(g) – Adds a new element ‘g’ at the end of the list
pop_front() – Removes the first element of the list, and reduces size of the list by 1
pop_back() – Removes the last element of the list, and reduces size of the list by 1
begin() – Returns an iterator pointing to the first element of the list
end() – Returns an iterator pointing to the theoretical last element which follows the last element
empty() – Returns whether the list is empty(1) or not(0)
insert() – Inserts new elements in the list before the element at a specified position
erase() – Removes a single element or a range of elements from the list
assign() – Assigns new elements to list by replacing current elements and resizes the list
remove() – Removes all the elements from the list, which are equal to given element
reverse() – Reverses the list
size() – Returns the number of elements in the list
sort() – Sorts the list in increasing order

——————— List scenario I - —————http://www.cplusplus.com/reference/list/list/list/————— 

Constructor  - 
(1) Empty container constructor (default constructor)
Constructs an empty container, with no elements.
(2) Fill constructor
Constructs a container with n elements. Each element is a copy of val.
(3) Range constructor
Constructs a container with as many elements as the range [first,last), with each element constructed from its corresponding element in that range, in the same order.
(4) Copy constructor
Constructs a container with a copy of each of the elements in x, in the same order.
(5) Move constructor - This is applicable for forward_list container. 
(6) Initializer list constructor - example this constructs a forward_list from initialize list. Example is below
#include <iostream>
#include <forward_list>
using namespace std;
int main(void) {
   auto il = {1, 2, 3, 4, 5};
   forward_list<int> fl(il);
   cout << "List contains following elements" << endl;
   for (auto it = fl.begin(); it != fl.end(); ++it)
      cout << *it << endl;
   return 0;
}



——— see all of the parameter use in example below ——— 
#include <iostream>
using namespace std;
#include <list>


int main ()
{
  // constructors used in the same order as described above:
  list<int> first;                                // empty list of ints
  list<int> second (4,300);                       // four ints with value 100
  list<int> third (second.begin(),second.end());  // iterating through second 
  list<int> fourth (third);                       // a copy of third 
 
  cout << " Dealing with fourth list " << endl;
  for(list<int>::iterator i = fourth.begin(); i != fourth.end() ; ++i) 
      cout << " Fourth list printing " << *i << endl ;
  

  // the iterator constructor can also be used to construct from arrays:
  int myints[] = {16,2,77,29};
  cout << "Size of myints array " << sizeof(myints) << endl;
  cout << "Start location of myints " << myints  << endl;  
  cout << "  End location of myints " << myints + sizeof(myints) / sizeof(int)  << endl;
  list<int> fifth (myints, myints + sizeof(myints) / sizeof(int) );

  cout << "The contents of fifth are: ";
  for (list<int>::iterator it = fifth.begin(); it != fifth.end(); it++) //here list<int> is a data type.
    cout << *it << ' ';
  cout << '\n';
  return 0;
}

————— output ————— see how we iterate a list . 
> g++ sample.c 
> ./a.out 

 Dealing with fourth list 
 Fourth list printing 300
 Fourth list printing 300
 Fourth list printing 300
 Fourth list printing 300
Size of myints array 16
Start location of myints 0x7ffcda972510
  End location of myints 0x7ffcda972520
The contents of fifth are: 16 2 77 29 

——————— list::operator= Member function ——————————— 
Copies all the elements from x into the container. The container preserves its current allocator, which is used to allocate additional storage if needed.

// assignment operator with lists
#include <iostream>
#include <list>

int main ()
{
  std::list<int> first (3);      // list of 3 zero-initialized ints
  std::list<int> second (5);     // list of 5 zero-initialized ints

  second = first;
  first = std::list<int>();

  std::cout << "Size of first: " << int (first.size()) << '\n';
  std::cout << "Size of second: " << int (second.size()) << '\n';
  return 0;
}
———— output ——— 
Size of first: 0
Size of second: 3

—————————— Assign member function - http://www.cplusplus.com/reference/list/list/insert/ ————— 
// list::assign
#include <iostream>
#include <list>

int main ()
{
  std::list<int> first;			//this is empty constructor 
  std::list<int> second;

  first.assign (7,100);                      // 7 ints with value 100, this is range constructor 

  second.assign (first.begin(),first.end()); // a copy of first , this is copy constructor 

  int myints[]={1776,7,4};
  first.assign (myints,myints+3);            // assigning from array

  std::cout << "Size of first: " << int (first.size()) << '\n';
  std::cout << "Size of second: " << int (second.size()) << '\n';
  return 0;
}
———— output ——— 
Size of first: 3
Size of second: 7

—————————— Non member function - swap ( Exchanges the contents of two lists) ———————— 
#include <list>
#include <iostream>
using namespace std;

int main() { 

  list<float> first(3,40.4);		//this is fill constructor 
  list<float> second(6, 54.5);

  first.swap(second);

  for(list<float> :: iterator i = first.begin() ; i != first.end() ; ++i) 
    cout << "First list values " << *i << endl;

  for(list<float> :: iterator j = second.begin(); j != second.end() ; j++) 
     cout << "Second list values " << *j << endl; 
  return 0;
}
———— output ———— 
First list values 54.5
First list values 54.5
First list values 54.5
First list values 54.5
First list values 54.5
First list values 54.5
Second list values 40.4
Second list values 40.4
Second list values 40.4
———All other member and non member function - http://www.cplusplus.com/reference/list/list/insert/ ————— 

————————— Deque - ———————— 
Double ended queues are sequence containers with the feature of expansion and contraction on both the ends. They are similar to vectors, but are more efficient in case of insertion and deletion of elements at the end, and also the beginning. Unlike vectors, contiguous storage allocation may not be guaranteed.

#include <deque>
#include <iostream>
using namespace std;


int main() { 
  deque<int> first;		//this is empty constructor 
  first.push_front(30);
  first.push_back(20);
  first.push_front(40);
  first.push_back(10);
  first.push_front(50);
  first.push_back(5);
  for(deque<int>:: iterator i = first.begin() ; i!= first.end() ; i++) 
    cout << "Deque values " << *i << endl;
  return 0;
}
——— output ——— 
Deque values 50
Deque values 40
Deque values 30
Deque values 20
Deque values 10
Deque values 5

———————— one more example of Deque —using pop function ———— 

#include <deque>
#include <iostream>
using namespace std;


int main() { 
  deque<int> first;		//this is empty constructor 
  first.push_front(30);
  first.push_back(20);
  first.push_front(40);
  first.push_back(10);
  first.push_front(50);
  first.push_back(5); 
  for(deque<int>:: iterator i = first.begin() ; i!= first.end() ; i++) 
    cout << "Deque values " << *i << endl;
  first.at(2);
  first.pop_front();
  first.pop_back();
  for(deque<int>:: iterator i = first.begin() ; i!= first.end() ; i++) 
    cout << "new Deque values " << *i << endl;
  return 0;
}
———— output ——— 
Deque values 50
Deque values 40
Deque values 30
Deque values 20
Deque values 10
Deque values 5
new Deque values 40
new Deque values 30
new Deque values 20
new Deque values 10

—————————— Forward_list ——————— 

forward_list container is implemented as singly linked-list, hence it provides unidirectional sequential access to it's data.forward_list doesn't provide fast random access, it only supports sequential access in only one directions. forward_list allows insertion and deletion operation anywhere within a sequence in constant time.Elements of forward_list can be scattered in different chunks of memory. Container stores necessary information to allow sequential access to it's data. forward_lists can shrink or expand as needed from both ends at run time. The storage requirement is fulfilled automatically by internal allocator. Forward list in STL implements singly linked list.It differs from list by the fact that forward list keeps track of location of only next element while list keeps track to both next and previous elements, thus increasing the storage space required to store each element. The drawback of forward list is that it cannot be iterated backwards and its individual elements cannot be accessed directly.

Definition - 
template < class T, class Alloc = allocator<T> > class forward_list;

T − Type of the element contained. T may be substituted by any other data type including user-defined type. Alloc − Type of allocator object.
By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.

#include <forward_list>
#include <iostream>
using namespace std;


int main() { 

  forward_list<int> l1;
  l1.assign({12,31,3});   //note { } brackets here  — this is fill constructor 
 

  for(forward_list<int> :: iterator i = l1.begin() ; i != l1.end() ; i++) 
    cout << " FList using iterator loop " << *i << endl;

  for(int &a : l1)
    cout << "FList using different loop " << a << endl;
  
  return 0;
}
————— output ——— 
FList using iterator loop 12
FList using iterator loop 31
FList using iterator loop 3
FList using different loop 12
FList using different loop 31
FList using different loop 3
 
—————————— Map container ————————— 
std::map is an associative container that store elements in key-value pair.
It stores only unique keys and that too in sorted order based on its assigned sorting criteria.
As keys are in sorted order therefore searching element in map through key is very fast i.e. it takes logarithmic time.
In std::map there will be only one value attached with the every key.
std::map can be used as associative arrays.
It might be implemented using balanced binary trees.

#include <map>
#include <iostream>
#include <string>
#include <iterator>
using namespace std;


int main() { 
//map<string , string, int> mydb;  //this wil not work. it works only with string and int - 2 para
  map<string ,int> mydb;
  mydb.insert(make_pair( "Key1",  1)); 
//mydb.insert(make_pair( 1, "Key1" ));  // will not work. it is always string first and then int
//mydb.insert(make_pair( "Key1", "Private" , 1)); //will not work. it takes only 2 parameters 
  mydb.insert(make_pair( "Key2", 2));
  mydb.insert(make_pair( "Key3", 3));


  for(map<string, int> :: iterator i = mydb.begin() ; i != mydb.end() ; i++) 
    cout << "DB Values USING FOR LOOP " << i->first << " and " << i->second << endl;

  mydb["Key1"] = 5;   //this is allowed but below line is not 
  mydb.insert(make_pair("Key3", 7)).second;  //this is not allowed
  map<string,int> :: iterator j = mydb.begin();
  while (j != mydb.end()) { 
    cout << "DB Values USING WHILE LOOP " << j->first << " and " << j->second << endl;
    j++;
  }
  return 0;
}

———output ——— 
DB Values USING FOR LOOP Key1 and 1
DB Values USING FOR LOOP Key2 and 2
DB Values USING FOR LOOP Key3 and 3
DB Values USING WHILE LOOP Key1 and 5
DB Values USING WHILE LOOP Key2 and 2
DB Values USING WHILE LOOP Key3 and 3

————————— Queue ——————————— 
Queues are a type of container adaptor, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other. queues are implemented as containers adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed into the "back" of the specific container and popped from its "front".The underlying container may be one of the standard container class template or some other specifically designed container class.


 
#include <iostream> 
#include <queue> 
using namespace std; 
  
int main() 
{ 
    // Empty Queue 
    queue<int> myqueue; 
    myqueue.push(0); 
    myqueue.push(1); 
    myqueue.push(2); 

    // Printing content of queue 
    while (!myqueue.empty()) { 
        cout << ' ' << myqueue.front();  //here printing starts from first element 
        myqueue.pop(); //here it is FIFO so always first element is out 
    } 
    myqueue.push(0); 
    myqueue.push(1); 
    myqueue.push(2); 
    // Printing content of queue 
    while (!myqueue.empty()) { 
        cout << ' ' << myqueue.back(); //here printing starts from last element 
        myqueue.pop(); //here it is FIFO so always first element is out 
    } 
} 
————output ——— 

 0 1 2
 2 2 2
———————————— STACK —————————— 
Stacks are a type of container adaptors with LIFO(Last In First Out) type of working, where a new element is added at one end and (top) an element is removed from that end only.

The functions associated with stack are:
empty() – Returns whether the stack is empty – Time Complexity : O(1)
size() – Returns the size of the stack – Time Complexity : O(1)
top() – Returns a reference to the top most element of the stack – Time Complexity : O(1)
push(g) – Adds the element ‘g’ at the top of the stack – Time Complexity : O(1)
pop() – Deletes the top most element of the stack – Time Complexity : O(1)

#include <iostream>
#include <stack>
using namespace std;

int main() { 

  stack<int> s;
  s.push(10);
  s.push(20);
  s.push(30);
  s.push(40);

  while(!s.empty()) { 
    cout << " Original top value " << s.top() <<endl ; //this brings the cursor reference to top most element 
    s.pop() ; //here last element 40 is poped out first so LIFO
    if (!s.empty()) { 
      cout << " New top value now" << s.top() <<endl;
    }
  }

  return 0;
}
——output —— 
 Original top value 40
 New top value now30
 Original top value 30
 New top value now20
 Original top value 20
 New top value now10
 Original top value 10
——————— ———— Unordered Map ——————————

unordered_map is an associated container that stores elements formed by combination of key value and a mapped value. The key value is used to uniquely identify the element and mapped value is the content associated with the key. Both key and value can be of any type predefined or user-defined

Internally unordered_map is implemented using Hash Table, the key provided to map are hashed into indices of hash table that is why performance of data structure depends on hash function a lot but on an average the cost of search, insert and delete from hash table is O(1)

 
#include <iostream> 
#include <unordered_map> 
using namespace std; 
  
int main() 
{ 
  //  unordered_map<int, string> umap; //here < any data type , any data type works>
    unordered_map<int, string> umap;
    
    // inserting values by using [] operator 
    umap[1] = "first"; 
    umap[2] = "second"; 
    umap[3] = "third"; 
  
    // Traversing an unordered map 
    for (auto x : umap) 
      cout << x.first << " " << x.second << endl; 
  
} 
——— output —— 

3 third
2 second
1 first

——————————— before moving to next example of unordered map , lets cover stringstream ————— 
#include <bits/stdc++.h> 
using namespace std; 
  
int countWords(string str) 
{ 
    stringstream s(str); // Used for breaking words 
    string storewordshere; // to store individual words , right  now empty
    int count = 0; 
    while (s >> storewordshere)  { //here we are reading s into string 
        cout << "Values of storewordshere " << storewordshere << endl; //printing each word
        count++; 
    }
    return count; 
} 
  
// Driver code 
int main() 
{ 
    string s = "it is possible to develop "
               "and a deploy";   //it is possible to continue string on second line
    cout << " Number of words are: " << countWords(s); 
    return 0; 
}
——output ——— 
Values of storewordshere it
Values of storewordshere is
Values of storewordshere possible
Values of storewordshere to
Values of storewordshere develop
Values of storewordshere and
Values of storewordshere a
Values of storewordshere deploy
 Number of words are: 8

——————— unordered map to count frequency of word ————— 
#include <string> 
#include <bits/stdc++.h>
#include <unordered_map>
using namespace std;

void wordfrequency(string &str) { 
  stringstream ss(str) ;
  string readhere;

  unordered_map<string, int> mycount;
  while(ss >> readhere) { 
    mycount[readhere]++;  //this is just building map db.
  }
  for(unordered_map<string, int> :: iterator i = mycount.begin() ; i != mycount.end(); i++) { 
      cout  << i->first << "  : " << i->second << endl;
  }
};

int main() { 
  string str = "therefore is development it design communit "
        "therefore it needs design is ";
  wordfrequency(str);
  return 0;
}

——— output ———  
 needs  : 1
communit  : 1
it  : 2
design  : 2
development  : 1
is  : 2
therefore  : 2

—————— Unordered Set ————————— 
unordered_set is implemented using hash table where keys are hashed into indices of this hash table so it is not possible to maintain an order. All operation on unordered_set takes constant time O(1) on an average which can go up to linear time in worst case which depends on the internally used hash function but practically they perform very well and generally provide constant time lookup operation.The unordered-set can contain key of any type – predefined or user-defined data structure but when we define key of type user define type, we need to specify our comparison function according to which keys will be compared.

set vs unordered_set
Set set is an ordered sequence of unique keys whereas unordered_set is a set in which key can be stored in any order, so unordered.
Set is implemented as balanced tree structure that is why it is possible to maintain an order between the elements (by specific tree traversal). Time complexity of set operations is O(Log n) while for unordered_set, it is O(1).

Methods on unordered_set
For unordered_set many function are defined among which most useful are size and empty for capacity, find for searching a key, insert and erase for modification.
The Unordered_set allows only unique keys, for duplicate keys unordered_multiset should be used.


#include <bits/stdc++.h> 
using namespace std; 

int main() { 
 
  unordered_set<string> stringpool;

  stringpool.insert("This");
  stringpool.insert("is"); 
  stringpool.insert("my");
  stringpool.insert("updated");
  stringpool.insert("text");
  
  string key = "what"; //"key" word is fixed.
  //find returns end iterator if key is not found, 
  //  else it returns iterator to that key 
  if (stringpool.find(key) == stringpool.end())
      cout << "Not Found " << key << endl;
  else
      cout << "Found " << key << endl;
  key = "my";
  if (stringpool.find(key) == stringpool.end())
      cout << "Not Found " << key << endl;
  else
      cout << "Found " << key << endl;

  unordered_set<string> :: iterator i ;
  for (i = stringpool.begin() ; i != stringpool.end() ; i++ ) { 
      cout << *i << endl;
  }
  return 0;
}
——— output ——— 
Not Found what
Found my
text
updated
my
is
This

———————— Finding duplicates using unordered_Set ———————— 

#include <bits/stdc++.h>  
using namespace std;

void printdup(int arr[], int i) { 
int j;
unordered_set<int> intset;
unordered_set<int> duplicates;

for(j=0 ; j< i; j++ ) { 
  if ( intset.find(arr[j]) == intset.end()) //always check if iterator reaches at the end first, else other condition
    intset.insert(arr[j]);
  else 
    duplicates.insert(arr[j]);
}
unordered_set<int> :: iterator loopcount;
for(loopcount = duplicates.begin() ; loopcount != duplicates.end() ; loopcount++) 
    cout << "Duplicates are : " << *loopcount << endl;
}

int main() { 

int arr[] = { 10, 29 , 20,10,80,29,32,80,30};
int size = sizeof(arr) / sizeof(int); 
printdup(arr , size);

  return 0;

}

————— output ——— 
Duplicates are : 80
Duplicates are : 29
Duplicates are : 10

————————— Signal Handling ——————— 
C++ signal-handling library provides function signal to trap unexpected events.

SIGABRT - Abnormal termination of the program, such as a call to abort.
SIGFPE - An erroneous arithmetic operation, such as a divide by zero or an operation resulting in overflow.
SIGILL - Detection of an illegal instruction.
SIGINT - Receipt of an interactive attention signal.
SIGSEGV - An invalid access to storage.
SIGTERM - A termination request sent to the program.


void (*signal (int sig, void (*func)(int)))(int); 

—————— Example - simple user manual interruption —————— 
#include <iostream>
#include <csignal>
#include <unistd.h>
#include <stdlib.h>
using namespace std;


void signalprocess(int signum) { 
  cout << "Signal received" << signum << endl;
  exit(signum);
}
int main() { 
  signal(SIGINT, signalprocess);
  while(1) { 
    cout << " We are sleeping right now "  << endl;
    sleep(1);
  }
  return 0;
}
——— output ——— 
 We are sleeping right now 
 We are sleeping right now 
 We are sleeping right now 
^CSignal received2

—————— Example - preconfigured system interruption using Raise—————— 
#include <iostream>
#include <csignal>

using namespace std;

void signalHandler( int signum ) {
   cout << "Interrupt signal (" << signum << ") received.\n";

   // cleanup and close up stuff here  
   // terminate program  

   exit(signum);  
}

int main () {
   int i = 0;
   // register signal SIGINT and signal handler  
   signal(SIGINT, signalHandler);  

   while(++i) {
      cout << "Going to sleep...." << endl;
      if( i == 3 ) {
         raise( SIGINT);
      }
      sleep(1);
   }

   return 0;
}

—————————— Lambda Expressions ——————————— 
 
[ captures ] (parameters) -> returnTypesDeclaration { lambdaStatements; }


[ captures ]: The capture clause, also known as the lambda introducer, specifies which outside variables are available for the lambda function and whether they should be captured by value (copying) or by reference. You will always be able to identify the start of a lambda expression with the presence of the capture clause. An empty capture clause [] means capture nothing, in which case the lambda expression body doesn't access variables in the enclosing scope.

( parameters ): This is the optional parameters list, also known as the lambda declarator. You can omit the parameters list if you want a function that takes zero arguments.

-> returnTypeDeclaration: This is the return type. Most of the time, compilers can deduce the return type of the lambda expression when you have zero or one return statement. However, if it makes it easier to understand the code, you can specify the return type.

{ lambdaStatements; }: This is the lambda body. The statements within the lambda body can access the captured variables and the parameters.


#include <iostream>
using namespace std;
int main()
  {
      auto lambda = []( int x , int y)  -> int {  return x + y; };  //here ( int x , int y) is parameters, -> int is return type and return x + y is the lambda statements.
      cout << lambda(3 ,4) << endl;
      return 0;
  }



——————— ———— Posix thread—————————— 

POSIX Threads, or Pthreads, is a POSIX standard for threads. Use pthread.h header file and add -lpthread during execution of the program. main() program is a single, default thread. All other threads must be explicitly created by the programmer.
1. Thread management - create, detach , join. Joinable, etc 
2. Mutexes - synchronization, locking , unlocking etc 
3. Condition variables - communication between threads that share mutex
4. Synchronisation - routines that manage read/write locks and barriers.


pthread_create (pthread_t *thread,        // pointer to pthread_t structure . When a thread is created, an identifier is written to the memory location to which this variable points. This identifier enables us to refer to the thread.

			 pthread_attr_t *attr,    // An attribute object that may be used to set thread attributes.
			 void *(*start_routine)(void *),   // The routine that the thread will execute once it is created. We should pass the address of a function taking a pointer to void as a parameter and the function will return a pointer to void. So, we can pass any type of single argument and return a pointer to any type. 
			 void *arg)    // A single argument that may be passed to start_routine. It must be passed as a void pointer 

—————— Simple Thread Management Example - ———— 

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

void *worker_thread(void *arg)
{
       printf("This is worker_thread()\n");
       pthread_exit(NULL);
}

int main()
{
       pthread_t my_thread; 

       printf("In main: creating thread\n");
       pthread_create(&my_thread, NULL, &worker_thread,  NULL);

       pthread_exit(NULL);
}
————— output ———— 
In main: creating thread
This is worker_thread()

———————————————— Multi-threading —————————————— 

Multithreading is a specialised form of multitasking and a multitasking is the feature that allows your computer to run two or more programs concurrently. In general, there are two types of multitasking: process-based and thread-based. Process-based multitasking handles the concurrent execution of programs. Thread-based multitasking deals with the concurrent execution of pieces of the same program.

Std::thread is the thread class that represents a single thread in C++. To start a thread we simply need to create a new thread object and pass the executing code to be called (i.e, a callable object) into the constructor of the object. Once the object is created a new thread is launched which will execute the code specified in callable.

A callable can be either of the three

A function pointer
A function object
A lambda expression
After defining callable, pass it to the constructor.

import<thread> 
std::thread thread_object(callable) 

1) Callable Function Pointer = 
void foo(param) 
{ 
	// Do something 
} 

// The parameters to the function are put after the comma 
std::thread thread_obj(foo, params); 

2) Callable Function Object  = 
// Define the class of function object 
class fn_object_class { 
    // Overload () operator 
    void operator()(params) 
    { 
        // Do Something 
    } 
} 
  
// Create thread object 
std::thread thread_object(fn_class_object(), params) 

3) Callable Lambda Expression = 
// Define a lamda expression 
auto f = [](params) { 
	// Do Something 
}; 

// Pass f and its parameters to thread 
// object constructor as 
std::thread thread_object(f, params); 




——————— ———— CGI - Web programming —————————— 
Before you proceed with CGI Programming, make sure that your Web Server supports CGI and it is configured to handle CGI Programs. All the CGI Programs to be executed by the HTTP server are kept in a pre-configured directory. This directory is called CGI Directory and by convention it is named as /var/www/cgi-bin. By convention, CGI files have extension as. cgi, but you can keep your files with python extension .py as well.To understand the concept of CGI, let's see what happens when we click a hyperlink to browse a particular web page or URL.Your browser contacts the HTTP web server and demand for the URL ie. filename.

Web Server will parse the URL and will look for the filename. If it finds requested file then web server sends that file back to the browser otherwise sends an error message indicating that you have requested a wrong file.Web browser takes response from web server and displays either the received file or error message based on the received response.However, it is possible to set up the HTTP server in such a way that whenever a file in a certain directory is requested, that file is not sent back; instead it is executed as a program, and produced output from the program is sent back to your browser to display.

The Common Gateway Interface (CGI) is a standard protocol for enabling applications (called CGI programs or CGI scripts) to interact with Web servers and with clients. These CGI programs can be a written in Python, PERL, Shell, C or C++ etc.

Web client <—> web server —> server side scripting —> database

//https://franklingu.github.io/programming/2015/12/21/C++-CGI-setup-on-CentOS/

There are basically 2 choices for setting up web server to serve CGI scripts. Apache and httpd support execution of CGI scripts by default and you can just simply enable “+ExecCGI” option. Or you can try Nginx, which does not support CGI execution but supports FastCGI. So in this tutorial we will be exploring the easier option and we will be install htttpd to server CGI scripts.

—————————— include libraries —————— download those files from ———— https://github.com/JackieXie168/cgicc/tree/master/cgicc
All library .h files can be loaded at /var/www/cgi-bin/ folder and then refer to those as follows - 
#include </var/www/cgi-bin/CgiDefs.h>  


——————— Install httpd and then navigate to /var/www/cgi-bin and place below code there in a .cpp file 
#include <iostream>
using namespace std;

int main () {
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>Hello World - First CGI Program</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<h2>Hello World! This is my first CGI program</h2>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
———— To execute above code , use  g++ -o < name of the file>.cgi <name of the file>.cpp 
Example g++ -o start.cgi start.cpp -lcgicc
————— curl localhost/cgi-bin/start.cgi

The line Content-type:text/html\r\n\r\n is a part of HTTP header, which is sent to the browser to understand the content type to be displayed on the browser. 
—————— Headers————————— 
Content-type:  = A MIME string defining the format of the file being returned. Example is Content-type:text/html
Expires: Date = The date the information becomes invalid. This should be used by the browser to decide when a page needs to be refreshed
Location: URL = The URL that should be returned instead of the URL requested. You can use this filed to redirect a request to any file.
Content-length: N  = The length, in bytes, of the data being returned. The browser uses this value to report the estimated download time for a file.
Set-Cookie: String = Set the cookie passed through the string.

 —————— Cgi Environmental variables - 

All the CGI program will have access to the following environment variables. 
CONTENT_TYPE
CONTENT_LENGTH = The length of the query information that is available only for POST requests.
HTTP_COOKIE = Returns the set cookies in the form of key & value pair.
HTTP_USER_AGENT = The User-Agent request-header field contains information about the user agent originating the request. It is a name of the web browser.
PATH_INFO = The path for the CGI script.
QUERY_STRING = The URL-encoded information that is sent with GET method request.
REMOTE_ADDR = The IP address of the remote host making the request. This can be useful for logging or for authentication purpose
REMOTE_HOST = The fully qualified name of the host making the request. If this information is not available then REMOTE_ADDR can be used to get IR address.
REQUEST_METHOD = The method used to make the request. The most common methods are GET and POST.
SCRIPT_FILENAME = The full path to the CGI script.
SCRIPT_NAME = The name of the CGI script.
SERVER_NAME = The server's hostname or IP Address.
SERVER_SOFTWARE = The name and version of the software the server is running.

———— List all CGI variables /// https://andres.jaimes.net/811/how-to-install-a-fcgi-nginx-in-centos-6/— —— 
#include <iostream>
#include <stdlib.h>
using namespace std;

const string ENV[ 24 ] = {
   "COMSPEC", "DOCUMENT_ROOT", "GATEWAY_INTERFACE",   
   "HTTP_ACCEPT", "HTTP_ACCEPT_ENCODING",             
   "HTTP_ACCEPT_LANGUAGE", "HTTP_CONNECTION",         
   "HTTP_HOST", "HTTP_USER_AGENT", "PATH",            
   "QUERY_STRING", "REMOTE_ADDR", "REMOTE_PORT",      
   "REQUEST_METHOD", "REQUEST_URI", "SCRIPT_FILENAME",
   "SCRIPT_NAME", "SERVER_ADDR", "SERVER_ADMIN",      
   "SERVER_NAME","SERVER_PORT","SERVER_PROTOCOL",     
   "SERVER_SIGNATURE","SERVER_SOFTWARE" };   

int main () {
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI Environment Variables</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<table border = \"0\" cellspacing = \"2\">";

   for ( int i = 0; i < 24; i++ ) {
      cout << "<tr><td>" << ENV[ i ] << "</td><td>";
      
      // attempt to retrieve value of environment variable
      char *value = getenv( ENV[ i ].c_str() );  
      if ( value != 0 ) {
         cout << value;                                 
      } else {
         cout << "Environment variable does not exist.";
      }
      cout << "</td></tr>\n";
   }
   
   cout << "</table><\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}

———— output ——— 
<html>
<head>
<title>CGI Environment Variables</title>
</head>
<body>
<table border = "0" cellspacing = "2"><tr><td>COMSPEC</td><td>Environment variable does not exist.</td></tr>
<tr><td>DOCUMENT_ROOT</td><td>/var/www/html</td></tr>
<tr><td>GATEWAY_INTERFACE</td><td>CGI/1.1</td></tr>
<tr><td>HTTP_ACCEPT</td><td>*/*</td></tr>
<tr><td>HTTP_ACCEPT_ENCODING</td><td>Environment variable does not exist.</td></tr>
<tr><td>HTTP_ACCEPT_LANGUAGE</td><td>Environment variable does not exist.</td></tr>
<tr><td>HTTP_CONNECTION</td><td>Environment variable does not exist.</td></tr>
<tr><td>HTTP_HOST</td><td>localhost</td></tr>
<tr><td>HTTP_USER_AGENT</td><td>curl/7.56.0</td></tr>
<tr><td>PATH</td><td>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin</td></tr>
<tr><td>QUERY_STRING</td><td></td></tr>
<tr><td>REMOTE_ADDR</td><td>::1</td></tr>
<tr><td>REMOTE_PORT</td><td>46688</td></tr>
<tr><td>REQUEST_METHOD</td><td>GET</td></tr>
<tr><td>REQUEST_URI</td><td>/cgi-bin/cgisample.cgi</td></tr>
<tr><td>SCRIPT_FILENAME</td><td>/var/www/cgi-bin/cgisample.cgi</td></tr>
<tr><td>SCRIPT_NAME</td><td>/cgi-bin/cgisample.cgi</td></tr>
<tr><td>SERVER_ADDR</td><td>::1</td></tr>
<tr><td>SERVER_ADMIN</td><td>root@localhost</td></tr>
<tr><td>SERVER_NAME</td><td>localhost</td></tr>
<tr><td>SERVER_PORT</td><td>80</td></tr>
<tr><td>SERVER_PROTOCOL</td><td>HTTP/1.1</td></tr>
<tr><td>SERVER_SIGNATURE</td><td></td></tr>
<tr><td>SERVER_SOFTWARE</td><td>Apache/2.4.6 (CentOS)</td></tr>
</table><
</body>
</html>

—————————— GET /POST Method ————————— ON HOLD DUE TO ERROR ——————
You must have come across many situations when you need to pass some information from your browser to web server and ultimately to your CGI Program. Most frequently browser uses two methods to pass this information to web server. The GET method is the default method to pass information from browser to web server and it produces a long string that appears in your browser's Location.


———————————— API Requests using Python ————————— 
//https://www.pythonforbeginners.com/requests/using-requests-in-python
Requests is an Apache2 Licensed HTTP library, written in Python. Requests will allow you to send HTTP/1.1 requests using Python. With it, you can add content like headers, form data, multipart files, and parameters via simple Python libraries. It also allows you to access the response data of Python in the same way.

———————— GET requests using Requests library —

import requests
# api-endpoint
URL = "http://maps.googleapis.com/maps/api/geocode/json"
# location given here
location = "delhi technological university"
# defining a params dict for the parameters to be sent to the API
PARAMS = {'address': location}
# sending get request and saving the response as response object
r = requests.get(url=URL, params=PARAMS)
# extracting data in json format
data = r.json()
print(data)


———————— POST requests using Requests library —

# importing the requests library 
import requests 
# defining the api-endpoint  
API_ENDPOINT = "http://pastebin.com/api/api_post.php"
# your API key here 
API_KEY = "XXXXXXXXXXXXXXXXX"
  
# your source code here 
source_code = ''' 
print("Hello, world!") 
a = 1 
b = 2 
print(a + b) 
'''
  
# data to be sent to api 
data = {'api_dev_key':API_KEY, 
        'api_option':'paste', 
        'api_paste_code':source_code, 
        'api_paste_format':'python'} 
  
# sending post request and saving response as response object 
r = requests.post(url = API_ENDPOINT, data = data) 
  
# extracting response text  
pastebin_url = r.text 
print("The pastebin URL is:%s"%pastebin_url) 

















