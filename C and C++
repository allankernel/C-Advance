———— Advance C programming - https://www.sanfoundry.com/advanced-c-programming-training/
https://pebble.gitbooks.io/learning-c-with-pebble/content/chapter10.html

Compile c program use - gcc code.c -o c
./c  —> to run program 
Compile c++ program use g++ code.cpp
> ./a.out  —> to run the program
————— POINTER — READ THIS — ——— 
https://www.thegeekstuff.com/2011/12/c-pointers-fundamentals


Number system - Binary , Octal , Decimal , Hexadecimal 
To represent a number in binary you need to follow the universal rule: break down the number to a sum of exact powers of 2. 10010 = 1 * 26 + 1 * 25 + 0 * 24 + 0 * 23 + 1 * 22 + 0 * 21 + 0 * 20

The octal numeral system, or oct for short, is the base-8 number system

In the decimal system each decimal place is a power of ten.

To represent a number as a hex in the source code use the “0x”(zero x) prefix. This tells the compiler that the number is in hex. The number will be converted to its decimal representation before compilation. We use a base of 16. 100 = 6 * 16 + 4 = 6 * 161 + 4 * 160

	▪	Storage Class Specifiers
	▪	Scope of a Variable
	▪	Register, Auto, Static, Extern
	▪	Why Register Class and Practical Examples
	▪	Automatic Variables and Stack
	▪	Static Variables and Functions
	▪	True meaning of Extern
	▪	How to Use extern across Multiple Files with Examples
	▪	Best Practices for Extern Usage
	▪	Local/Block/Global Scope
	▪	Nesting of Scope
	▪	Lifetime of a Variable
	▪	Linkage of a Variable
	▪	What is Const?

————————————— File ———————————— 
fopen()     create a new file or open a existing file
fclose()    closes a file 
getc()  reads a character from a file 
putc() writes a character to a file 
fscanf()    reads a set of data from a file 
fprintf()   writes a set of data to a file 
getw() reads a integer from a file 
putw() writes a integer to a file 
fseek() set the position to desire point 
ftell() gives current position in the file 
rewind() set the position to the beginning point 

————————— ————— 
Enumeration - this is just a key value pair db. Where values are in code and key are internal to complier 
enum mydbname { value1, value2 …} ;


#include <stdio.h>
enum State {WORKING = 0, FAILED, FREEZED};
enum State currState = 2;
 
enum State FindState() {
    return currState;
}
 
int main() {
   (FindState() == WORKING)? printf("WORKING"): printf("NOT WORKING");
   return 0;
}
— output — —— 
NOT WORKING
—— another example. 
#include <stdio.h>

enum db {a, c , g }; 

int main() { 
  enum db myask;
  myask = c;
  printf("value to be printed %d", myask);
  return 0;
}

—output — 
value to be printed 1

——————————— pass function by value(. Is used)  and by reference (-> used) but in case of pointer data and reference both uses -> 
   ———————— 
#include <stdio.h>
#include <string.h>

struct stdstructure { 				//union has same syntax as structure , only difference is union elements share memory location , structure is a record
  char nameofsociety[20];
  int numofpeoplestaying;
};

// typedef works exactly same as structure except definition is bit different as shown below
typedef struct Books {
   char title[50];
   int book_id;
} Book;
//

int printbyvalue(struct stdstructure getdata) { 
    printf("name of the society %s\n", getdata.nameofsociety);
    printf("number of folks staying %d\n", getdata.numofpeoplestaying);
    return 0;
}

void printbyref(struct stdstructure *getref) { 
    printf("name of society by ref %s\n", getref->nameofsociety);
    printf("num of folks by ref %d\n", getref->numofpeoplestaying);
}

int main() { 
  struct stdstructure setdata;
  struct stdstructure refdata;
  
  strcpy(setdata.nameofsociety,"Pink city");
  setdata.numofpeoplestaying = 50;
  printbyvalue(setdata);  //this is pass structure by value
  printf("-----------up by value----below by reference---\n");

  strcpy(refdata.nameofsociety,"Ref Pink city");
  refdata.numofpeoplestaying = 150;
  printbyref(&refdata); //structure pass by reference
  return 0;
}

————— output ——— 
name of the society Pink city
number of folks staying 50
-----------up by value----below by reference---
name of society by ref Ref Pink city
num of folks by ref 150

———————— Simple linked list -here casting ( struct mylink* ) malloc is also bit different and we use -> for both , to post and reference data  ————— 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct mylink{ 
  char data[30]; 
  int pointer;
};
int main() { 
  struct mylink *first;
  struct mylink *second;
  struct mylink *third;
  first = (struct mylink*) malloc(sizeof(struct mylink));
  second = (struct mylink*) malloc(sizeof(struct mylink));
  third = (struct mylink*) malloc(sizeof(struct mylink));
  strcpy(first->data, "Allan");
  strcpy(second->data, "Michael");
  strcpy(third->data, "Gonsalves");
  first->pointer = second;
  second->pointer = third;
  third->pointer = NULL;
  printf("value of first %s\n", first->data );
  printf("value of second %s\n", second->data );
  printf("value of third %s\n", third->data );
  return 0;
}

——— — output ——— 
value of first Allan
value of second Michael
value of third Gonsalves
———————— nested structure ———————— 
#include <stdio.h>

struct insidestruct { 
  int dimid;
  char charname[20];
};
struct mainstruct { 
  int sid;
  struct insidestruct in;
} driver;
int main() { 
  struct mainstruct driver = { 100, 200, strcpy( driver.in.charname, "product")};
  printf("print structure data %d , %d , %s\n", driver.sid, driver.in.dimid,driver.in.charname);
  return 0;
} 
——— — output ——— 
print structure data 100 , 200 , product

————— POINTER ——— 
https://www.thegeekstuff.com/2011/12/c-pointers-fundamentals

	•	    Constant pointer and pointer to constant.
	•	    Pointer to pointer  
	•	    Array of pointers  
	•	    Pointer to functions  

——————————— For constant pointer and pointer constant , try below rule to remember  ——————— 
A C P ( Address cannot be changed - Constant - Pointer ) 
       P C V  ( Pointer - Constant - Value cannot be changed ) 

Remove P so now it becomes AC - CV 
AC (P) - (P) CV 

—— Constant pointer - 
#include <stdio.h>
int main() { 
  float Var = 20.33;
  float jam = 32.34;
  float *const pointer = &Var;  //note the *const — this is how we define constant pointer.
//  pointer = &jam;  -- not allowed, we cannot assign new address to constant pointer
  printf("%.2f",*pointer );
  return 0;
}
—— Pointer  Constant - 
#include <stdio.h>
int main() { 
  char var1 = 'a';
  const char *pointer = &var1;
//  *pointer = 'b';  in case of constant pointer, value cannot be changed
  printf("value stored %c", *pointer);
  return 0;
}
—— Pointer  to Pointer  - 
#include <stdio.h> 
int main() { 
  const char *firstpointer = NULL;
  const char **secondpointer = NULL;
  firstpointer = "well done double pointer";
  secondpointer = &firstpointer;
  printf("print : %s\n", *secondpointer ); //for %s , we dont use * , we use only pointer name e.g. firstpointer but for double pointer we have to use one *
  
  return 0;
} 
—— Array of Pointer  - 
#include<stdio.h> 

int main(void)
{
    char *p1 = "Allan";
    char *p2 = "Gonsalves";
    char *p3 = "India"; 

    char *arr[3]; 

    arr[0] = p1;
    arr[1] = p2;
    arr[2] = p3; 

   printf("\n p1 = [%s] \n",p1);
   printf("\n p2 = [%s] \n",p2);
   printf("\n p3 = [%s] \n",p3); 

   printf("\n arr[0] = [%s] \n",arr[0]);
   printf("\n arr[1] = [%s] \n",arr[1]);
   printf("\n arr[2] = [%s] \n",arr[2]); 

   return 0;
}
—— Function Pointer  - 
int (*fptr)(int, int)

— example below 
#include<stdio.h> 

int func (int a, int b)
{
    printf("\n a = %d\n",a);
    printf("\n b = %d\n",b); 
    return 0;
} 

int main(void)
{
    int(*fptr)(int,int); // Function pointer 
    fptr = func; // Assign address to function pointer  . Note that, name of the function can be treated as starting address of the function so
// we can assign the address of function to function pointer using function’s name.
    func(2,3);
    fptr(2,3); 
    return 0;
}
—————————— How to pass class to function ——————— 
#include <iostream>
using namespace std;
class myclass{ 
  public : 
    int id = 20;
};

void fun(myclass *b) { 
  cout << "class passed to function" << b->id << endl;
}

int main() { 
  myclass *c = new myclass();
  fun(c);
  return 0;
}
————— output ——— 
class passed to function. 20
————————————— 
int main(void) 
{ 

    char *ptr = "I am a string"; 

    printf("[%c], [%s]\n",  *ptr, ptr);  // Asterisk means value of the pointer. By default 
//any character pointer pointing to a string stores the address of the first character of the string. In the code above, ‘ptr’ holds the address 
of the character ‘I’ ie 1001. Now, when we apply the ‘value of’ operator ‘*’ to ‘ptr’, we intend to fetch the value at address 1001 which is 
‘I’ and hence when we print ‘*ptr’, we get ‘I’ as the output. The concept is that %s specifier requires the address of the beginning byte 
of string to display the complete string, which we provided using ‘ptr’ (which we know holds the beginning byte address of the string).

    return 0; 
}
—— output — 
[I], [I am a string]

——————— how to use structure pointer ————— 
#include<stdio.h> 

struct st{ 
int a; 
char ch; 
}; 

int main(void) 
{ 
    struct st obj; 
    struct st *stobj = &obj; 

    stobj->a = 5; 
    stobj->ch = 'a'; 

    printf("\n [%d] [%c]\n", stobj->a, stobj->ch); 
    return 0; 
}
——————— 
———————————— nested structure with pointer variable ————————— 
#include <stdio.h>
#include <string.h>
 
struct student_college_detail
{
    int college_id;
};
 
struct student_detail 
{
    float percentage; 
    struct student_college_detail clg_data; 
}stu_data, *stu_data_ptr;
 
int main() 
{
  struct student_detail stu_data = { 90.5, 71145};
    stu_data_ptr = &stu_data;
    printf(" Percentage is: %f \n\n", 
                         stu_data_ptr->percentage);
    printf(" College Id is: %d \n", 
                         stu_data_ptr->clg_data.college_id);
    return 0;
}
——— — output ——— 
 Percentage is: 90.500000 
 College Id is: 71145 
—————————— using dot notation in structure with pointer variables ——————— 

#include <stdio.h>
#include <string.h>
 
struct student_college_detail
{
    int college_id;
    int another_id;
};
 
struct student_detail 
{
    float percentage; 
    struct student_college_detail clg_data; 
}stu_data, *stu_data_ptr;
 
int main() 
{
  struct student_detail stu_data = { 
    .percentage = 200, 
    .clg_data.college_id = 300   };
    
    stu_data_ptr = &stu_data;
    printf(" Percentage is: %f \n\n", 
                         stu_data_ptr->percentage);
    printf(" College Id is: %d \n", 
                         stu_data_ptr->clg_data.college_id);
    return 0;
}

————— output ————— 
 Percentage is: 200.000000 
 College Id is: 300 

————— passing structure to function pointer ( single character ) —————— 
#include <stdio.h>

struct pro { 
  char name;
  int id;
};
void dosomething(struct pro *getinfo) { 
      printf("%c\n", getinfo->name);
      printf("%d\n", getinfo->id);
}

int main() { 
  struct pro info;
  info.name = 'a';
  info.id = 300;
  void(*funpointer)(struct pro *);
  funpointer = dosomething;
  funpointer(&info);
  return 0;
}

——output —- 
a
300

————— passing structure to function pointer ( with string ) —————— 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct pro {
    char *name;
    int id;
};

struct pro* dosomething(int j) {
    struct pro *infostruct;
    infostruct = (struct pro *) malloc(sizeof(struct pro));
    infostruct->name = "alan gonsalves";
    infostruct->id = j;
    return infostruct;
}


int main() {
    struct pro *mainfun;
    struct pro* (*funpointer)(int i);
    
    funpointer  = dosomething;
    mainfun = funpointer(30);
    printf("print name %s\n", mainfun->name);
    printf("print id %d\n", mainfun->id);
    return 0;
}
————— output ———— 
print name alan gonsalves
print id 30
——more such examples at below ———— 
//http://www.cs.utsa.edu/~wagner/CS2213/structs/structs_pass.html
—— Passing structure as a return type in the Function Pointer  - 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct pro {
    char name;
    int id;
};

struct pro* dosomething(int j) {
    struct pro *infostruct;
    infostruct = (struct pro *) malloc(sizeof(struct pro));
    infostruct->name = 'a';
    infostruct->id = j;
    return infostruct;
}

int main() {
    struct pro *mainfun;
    struct pro* (*funpointer)(int i);
    
    funpointer  = dosomething;
    mainfun = funpointer(30);
    printf("print name %c\n", mainfun->name);
    printf("print id %d\n", mainfun->id);
    return 0;
}
————— output ————— 
print name a
print id 30
——————  —— Extern ————— - - 
#include <stdio.h>
int x = 10;
int z = 5;
int main()
{
    extern int y; // line 2
    extern int z;
    printf("%d %d %d", x, y, z);
}
int y = 2;
————— output ————— 
10 2 5.  We define 2 variables x and z in global scope. By default, all of them have external linkage. When we use extern int z, we tell the compiler to use the same z as the global one. In main, we declare y as externally linked and tell the compiler to look for definition of y elsewhere. It has local scope upto when line 2 is compiled.The compiler reaches the end of the program and finds the definition of y. Since it is declared outside main, it is now promoted to global scope. Thus, the linker does not complain of not finding definition of y and the program runs.
————— ———Preprocessors———— ———————
//https://pebble.gitbooks.io/learning-c-with-pebble/content/chapter15.html

#define
#include
#undef
#pragma
#ifdef
#ifndef
#if
#else
#elif
#endif
#error 

———— Few examples on preprocessor————— ————
#define APWIDTH 20
#define BASWIDTH 30
#define CHWIDTH 50
#define WIDTHS APWIDTH, BASWIDTH, CHWIDTH
int widths[] =  { WIDTHS } ;

int main() { 
  int i;
  for(i= 0; i<4; i++) { 
    printf("values %d\n", widths[i]);
  }
  return 0;
}
—————output ————— 
values 20
values 30
values 50
values 0

———— Example 2 - preprocessor conditional code ————— ————

#if defined(TABLE_SIZE)
  #if TABLE_SIZE > 100 
    #undef TABLE_SIZE
    #define TABLE_SIZE 100
    int boundary = 200;
  #else
    int boundary = 100;
  #endif
#else 
  #define TABLE_SIZE 50;
  int boundary = 100;
#endif 
————— ———Pointer arithmetic ———— ———————
Here we can do integer type operation on pointer as shown below 

#include <stdio.h>
const int MAX = 3;
int main () {
   int  var[] = {10, 100, 200};
   int  i, *ptr;
   /* let us have address of the first element in pointer */
   ptr = &var;
   i = 0;
   while ( ptr <= &var[MAX - 1] ) {
      printf("Address of var[%d] = %x\n", i, ptr );
      printf("Value of var[%d] = %d\n", i, *ptr );

      /* point to the previous location */
      ptr++;
      i++;
   }
   return 0;
}
———— output ————— 
Address of var[0] = f2f4b0e0
Value of var[0] = 10
Address of var[1] = f2f4b0e4
Value of var[1] = 100
Address of var[2] = f2f4b0e8
Value of var[2] = 200
————— ———Heap memory (this is global , configured using malloc, free is must to avoid memory leak) and stack memory (normal variables lives during function)  ———— ———————
#include <stdio.h>
#include <stdlib.h>
int main() { 
  int *whatever = malloc(sizeof(int));
  *whatever = 30;
  printf("print %d", *whatever);
  free(whatever);
  return 0;
}
--output -- 
print 30


———— Some examples —— 
#undef FILE_SIZE
#define FILE_SIZE 42 
It tells the CPP ( C pre-processor ) to undefine existing FILE_SIZE and define it as 42.

#ifndef MESSAGE 
	#define MESSAGE “You wish”
#endif
It tells the CPP to define MESSAGE only if MESSAGE isn't already defined.

Predefined Macros as follows - 
__DATE__
__TIME__
__FILE__
__STDC__

————— ——————— ——————— 
There are two types of macros - Object-like (do not take parameters) and function-like (Can take parameters)
// object-like macro
#define        
// function-like macro          
#define () 
To delete macro use #undef 

We can write multi-line macro same like function, but each statement ends with “\”. 
#include <stdio.h>
  
#define MACRO(num, str) {\
            printf("%d", num);\
            printf(" is");\
            printf(" %s number", str);\
            printf("\n");\
           }

———— example 1- 
#include <stdio.h>

#define M1
#define M2

int main(void) { 
#ifdef M1
  printf("this is macro M1\n");
#endif 

#ifdef M2
  printf("this is M2 micro\n");
#endif
  return 0;
}

------- Output — 
this is macro M1
this is M2 micro
—————Below macro value is passed in the code 
#include <stdio.h>
#define M1(x)  x * (x+5)
int main() { 
#ifdef M1
  printf("macro M1 is active\n");
#endif
  int res = M1(2);
  printf("new value based on macro %d - \n ", res);
  return 0;
}
———To pass macro value from command line use below - 
> gcc -Wall -DMACRO1=25 macro.c -o macro

————— ———Macro functions———— ———————
#include <stdio.h>
#define PRINT(i, limit) while (i < limit) \
                        { \
                            printf("GeeksQuiz "); \
                            i++; \
                        }
int main()
{
    int i = 0;
    PRINT(i, 3);
    return 0;
}
// Output: GeeksQuiz  GeeksQuiz  GeeksQuiz

Stringize operator is # as shown below #a and #b.
#define  message_for(a, b)  \
   printf(#a " and " #b ": We love you!\n")

int main(void) {
   message_for(Carole, Debra);
   return 0;
}

—— Token pasting operator (##) —— 
#include <stdio.h>

#define tokenpaster(n) \
  printf ("token" #n " = %d", token##n)

int main(void) {
   int token34 = 400;
   tokenpaster(34);
   return 0;
}
—— output 
token34 = 400

————— ———Endian-ness – Little Vs Big ——— ———————
Little and big endian are two ways of storing multibyte data-types ( int, float, etc).
\\ https://www.geeksforgeeks.org/little-and-big-endian-mystery/

————— ———All about file ———— ———————
#include <stdio.h>
#include <string.h>


int main() { 
  char c[100];
  char buffer[100];
  FILE *pointer;
  pointer  = fopen("/root/c_world/sample.txt", "w+") ; 
  fgets(c, 100, stdin);
  fwrite(c, strlen(c) + 1, 1, pointer); 
  fseek(pointer, 3, SEEK_SET);
  fread(buffer, strlen(c) + 1, 1, pointer);
  printf("%s", buffer);
  fclose(pointer);

  return 0 ;

}
————— output ——————— 
> this is my life 
> s is my life 

————— ———Inline functions - (inline code of function gets when called)———— ———————
#include <stdio.h>
int inline func1(int a) { 
  return ( a + 10 );
}

void inline func2() { 
  printf("Printing value : %d", func1(30) );
}

int main() { 
  func2();
  return 0;  
}
———— Output - 
Printing value : 40
————— ——————— ——————— 
//constant pointer, pointer to constant and constant pointer to constant.
/*constant pointer = A constant pointer is a pointer that cannot change the address its holding. In other words, we can say that once a constant pointer points to a variable then it cannot point to any other variable

int main(void)
{
    int var1 = 0, var2 = 0;
    int *const ptr = &var1;
 //   ptr = &var2;   this is not possible
    printf("%d\n", *ptr);
    
    return 0;
} */
/*Pointer to constant - a pointer through which one cannot change the value of variable it points is known as a pointer to constant. These type of pointers can change the address they point to but cannot change the value kept at those address.


int main(void)
{
    int var1 = 10;
    const int* ptr = &var1;
//    *ptr = 1;           //changing value of the pointer now possible
    printf("%d\n", *ptr);
    
    return 0;
} */

/* Constant pointer to constant - A constant pointer to constant is a pointer that can neither change the address its pointing to and nor it can change the value kept at that address. */

#include<stdio.h>

int main(void)
{
    int var1 = 20,var2 = 0;
    const int* const ptr = &var1;
//    *ptr = 1;
//    ptr = &var2;
    printf("%d\n", *ptr);
    
    return 0;
}


——————— - —————— Function pointer —————— —————— 
//https://www.geeksforgeeks.org/function-pointer-in-c/

#include <stdio.h>
int fun(int a)
{
    printf("Value of a is %d\n", a);
    return a * 2;

}
 
int main()
{
    // fun_ptr is a pointer to function fun() 
    int (*fun_ptr)(int) = &fun;
 
    /* The above line is equivalent of following two
       int (*fun_ptr)(int);
       fun_ptr = &fun; 
    */
 
     printf("new value %d\n", (*fun_ptr) (10));
    return 0;
}
—output - 
Value of a is 10
new value 20



—————————————— How to return string from a function ———————— 
#include <stdio.h>
char* displayString(char str[]){
    str = "now this is new statement";
    return(str);
}
int main()
{ 
    printf("new value %s\n", displayString("this is  statement"));  
    return 0;
}
————— output ————— 
new value  : now this is new statement
——————————————————— How to use malloc on simple characteristics and on structure 
#include <stdio.h>
#include <stdlib.h>

int main () {
    char *str;
    
    /* Initial memory allocation */
    str = (char *) malloc(15);
    strcpy(str, "tutorialspoint");
    printf("String = %s,  Address = %u\n", str, str);
    
    /* Reallocating memory */
    str = (char *) realloc(str, 25);
    strcat(str, ".com");
    printf("String = %s,  Address = %u\n", str, str);
    
    free(str);
    
    return(0);
}
————— 
String = tutorialspoint,  Address = 7566976
String = tutorialspoint.com,  Address = 7567600
Program ended with exit code: 0 


——————————————————— Depth first search 
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>

#define MAX 5

struct Vertex {
    char label;
    bool visited;
};

//stack variables
int stack[MAX];
int top = -1;

//array of vertices
struct Vertex*  firstVertices[MAX];

//adjacency matrix
int adjMatrix[MAX][MAX];

//vertex count
int vertexCount = 0;

//stack functions
void push(int item) {
    stack[++top] = item;
}

int pop() {
    return stack[top--];
}

int peek() {
    return stack[top];
}

bool isStackEmpty() {
    return top == -1;
}

//add vertex to the vertex list
void addVertex(char label) {
    struct Vertex* vertex = (struct Vertex*) malloc(sizeof(struct Vertex));
    vertex->label = label;
    vertex->visited = false;
    firstVertices[vertexCount++] = vertex;
}

//add edge to edge array
void addEdge(int start,int end) {
    adjMatrix[start][end] = 1;
    adjMatrix[end][start] = 1;
}

//display the vertex
void displayVertex(int vertexIndex) {
    printf("%c ",firstVertices[vertexIndex]->label);
}

//get the adjacent unvisited vertex
int getAdjUnvisitedVertex(int vertexIndex) {
    int i;
    
    for(i = 0; i < vertexCount; i++) {
        if(adjMatrix[vertexIndex][i] == 1 && firstVertices[i]->visited == false) {
            return i;
        }
    }
    
    return -1;
}

void depthFirstSearch() {
    int i;
    
    //mark first node as visited
    firstVertices[0]->visited = true;
    
    //display the vertex
    displayVertex(0);
    
    //push vertex index in stack
    push(0);
    
    while(!isStackEmpty()) {
        //get the unvisited vertex of vertex which is at top of the stack
        int unvisitedVertex = getAdjUnvisitedVertex(peek());
        
        //no adjacent vertex found
        if(unvisitedVertex == -1) {
            pop();
        } else {
            firstVertices[unvisitedVertex]->visited = true;
            displayVertex(unvisitedVertex);
            push(unvisitedVertex);
        }
    }
    
    //stack is empty, search is complete, reset the visited flag
    for(i = 0;i < vertexCount;i++) {
        firstVertices[i]->visited = false;
    }
}

int main() {
    int i, j;
    
    for(i = 0; i < MAX; i++)    // set adjacency {
        for(j = 0; j < MAX; j++) // matrix to 0
            adjMatrix[i][j] = 0;
    
    addVertex('S');   // 0
    addVertex('A');   // 1
    addVertex('B');   // 2
    addVertex('C');   // 3
    addVertex('D');   // 4
    
    addEdge(0, 1);    // S - A
    addEdge(0, 2);    // S - B
    addEdge(0, 3);    // S - C
    addEdge(1, 4);    // A - D
    addEdge(2, 4);    // B - D
    addEdge(3, 4);    // C - D
    
    printf("Depth First Search: \n");
    depthFirstSearch();
    
    return 0;
}

————————————————————— Returning structure from function - 
#include <unistd.h>

//structure
struct familytree {
    char name;
    struct familytree *son;
    struct familytree *daughter;
};
//instance of the structure
struct familytree* detailedfun(char fullname){
    struct familytree* myfamily = (struct familytree*) malloc(sizeof(struct familytree));
    myfamily->name = fullname;
    myfamily->son  = 'A';
    myfamily->daughter = 'C';
    return myfamily;
}


int main() {
//main - fill structure and return structure
    struct familytree *tree = detailedfun('M');
    
//print structure
    printf("Full name %c-\n", tree->name );
    printf("name of the son - %c\n", tree->son);
    printf("name of the daughter - %c\n", tree->daughter);
    
}
——output - 
Full name M-
name of the son - A
name of the daughter - C
————————————————————— Deep First search traversal 
// C program for different tree traversals
//Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to
// traverse them, trees can be traversed in different ways. Following are the generally used ways for traversing trees.

// https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/
//    Depth First Traversals:
//(a) Inorder (Left, Root, Right) : 4 2 5 1 3
//(b) Preorder (Root, Left, Right) : 1 2 4 5 3
//(c) Postorder (Left, Right, Root) : 4 5 2 3 1

#include <stdio.h>
#include <stdlib.h>

/* A binary tree node has data, pointer to left child
 and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* Helper function that allocates a new node with the
 given data and NULL left and right pointers. */
struct node* newNode(int data)
{
    struct node* node = (struct node*) malloc(sizeof(struct node));
    node->data = data;
    node->left = NULL;
    node->right = NULL;
    
    return(node);
}

/* Given a binary tree, print its nodes according to the
 "bottom-up" postorder traversal. */
void printPostorder(struct node* node)
{
    if (node == NULL)
        return;
    
    // first recur on left subtree
    printPostorder(node->left);
    
    // then recur on right subtree
    printPostorder(node->right);
    
    // now deal with the node
    printf("%d ", node->data);
}

/* Given a binary tree, print its nodes in inorder*/
void printInorder(struct node* node)
{
    if (node == NULL)
        return;
    
    /* first recur on left child */
    printInorder(node->left);
    
    /* then print the data of node */
    printf("%d ", node->data);
    
    /* now recur on right child */
    printInorder(node->right);
}

/* Given a binary tree, print its nodes in preorder*/
void printPreorder(struct node* node)
{
    if (node == NULL)
        return;
    
    /* first print data of node */
    printf("%d ", node->data);
    
    /* then recur on left sutree */
    printPreorder(node->left);
    
    /* now recur on right subtree */
    printPreorder(node->right);
}

/* Driver program to test above functions*/
int main()
{
    struct node *root  = newNode(1);
    
    root->left             = newNode(2);
    root->right           = newNode(3);
    root->left->left     = newNode(4);
    root->left->right   = newNode(5);
    root->left->left->left   = newNode(6);
    
    printf("\nPreorder traversal of binary tree is \n");
    printPreorder(root);
    
    printf("\nInorder traversal of binary tree is \n");
    printInorder(root);
    
    printf("\nPostorder traversal of binary tree is \n");
    printPostorder(root);
    
    getchar();
    return 0;
}
———————— 

Preorder traversal of binary tree is 
1 2 4 6 5 3 
Inorder traversal of binary tree is 
6 4 2 5 1 3 
Postorder traversal of binary tree is 
6 4 5 2 3 1 
————————————————————— ————————— Linked list and How to use malloc on structure 
#include <stdio.h>
#include <stdlib.h>
//struct

struct node {
    int data;
    struct node *next;
};

//print
void printlist(struct node *getdata) {
    while (getdata != NULL) {
        printf("print the list %d\n ", getdata->data);
        getdata = getdata->next;
    }
}
//main
int main() {
    
   struct node *head = ( struct node*) malloc(sizeof(struct node));
    struct node *second = ( struct node*) malloc (sizeof(struct node));
    struct node *third = (struct node *) malloc(sizeof(struct node));
    
    head->data = 1;
    head->next = second;
    
    second->data = 2;
    second->next = third;
    
    third->data = 3;
    third->next = NULL;
    
    printlist(head);
    
}

————————— 
print the list 1
 print the list 2
 print the list 3
————————————————————— —————————  
What is structure padding in C - In order to align the data in memory, one or more empty bytes (addresses) are inserted (or left empty) between memory addresses which are allocated for other structure members while memory allocation. This concept is called structure padding.

Read below post - https://fresh2refresh.com/c-programming/c-structure-padding/

Every field in structure going to take some byte in 4 byte (32 bit processor) or 8 byte ( in 64 bit processor) so if we use Char data type in structure then it wil use only 1 byte out of 4 and , 3 byte remain empty which can remain unused. So we can use #pragma pack(1) directive as shown below to remove those empty spaces . If we remove pragma directive then it wil keep empty bytes (unusable) 

#include <stdio.h>
#include <string.h>
 
/*  Below structure1 and structure2 are same. 
    They differ only in member's allignment */
#pragma pack(1) 
struct structure1 
{
       int id1;
       int id2;
       char name;
       char c;
       float percentage;
};
 
struct structure2 
{
       int id1;
       char name;
       int id2;
       char c;
       float percentage;                      
};
 
int main() 
{
    struct structure1 a;
    struct structure2 b;
 
    printf("size of structure1 in bytes : %d\n", 
            sizeof(a));
    printf ( "\n   Address of id1        = %u", &a.id1 );
    printf ( "\n   Address of id2        = %u", &a.id2 );
    printf ( "\n   Address of name       = %u", &a.name );
    printf ( "\n   Address of c          = %u", &a.c );
    printf ( "\n   Address of percentage = %u",
                   &a.percentage );
 
    printf("   \n\nsize of structure2 in bytes : %d\n",
                   sizeof(b));
    printf ( "\n   Address of id1        = %u", &b.id1 );
    printf ( "\n   Address of name       = %u", &b.name );
    printf ( "\n   Address of id2        = %u", &b.id2 );
    printf ( "\n   Address of c          = %u", &b.c );
    printf ( "\n   Address of percentage = %u",
                   &b.percentage );
    getchar();
    return 0;
}

——— ——— output ———— ————— 
size of structure1 in bytes : 14

   Address of id1        = 2455124416
   Address of id2        = 2455124420
   Address of name       = 2455124424
   Address of c          = 2455124425
   Address of percentage = 2455124426   

size of structure2 in bytes : 14

   Address of id1        = 2455124400
   Address of name       = 2455124404
   Address of id2        = 2455124405
   Address of c          = 2455124409
   Address of percentage = 2455124410

——— ——— ———— ——qsort function————————  ———— ————— 

#include <stdio.h>
#include <stdlib.h>

// A sample comparator function that is used
// for sorting an integer array in ascending order.
// To sort any array for any other data type and/or
// criteria, all we need to do is write more compare
// functions.  And we can use the same qsort()
int compare (const void * a, const void * b)
{
    return ( *(int*)a - *(int*)b );
}

int main ()
{
    int arr[] = {10, 5, 15, 12, 90, 80};
    int n = sizeof(arr)/sizeof(arr[0]), i;

    qsort (arr, n, sizeof(int), compare);
    
    for (i=0; i<n; i++)
        printf ("%d ", arr[i]);
    return 0;
}
——output —— 
5 10 12 15 80 90
——————— ——— - — — CASTING AND POINTER - —— 
int main() { 
  float i = 300;
  int*  p = (int*) &i;
  printf("%p\n", p);
  return 0;
}

&i : means to take the address of i (which is a char*)

(int*)&i : casts that pointer to be a pointer to integer (which is bad/wrong to do, 
but you told the compiler to do it so it won't even give a warning)

int* p = (int*)&i; : a statement that says to store the pointer of i in p (and cast 
it too: the compiler won't even complain)

p* = 1234567892; : write this value, which is several bytes to the base location 
pointed to by p (which although p thinks it points to an int, is to char!).

—— — OUTPUT
> 0x7ffc391eb594
——————— ——— - — — Dangling pointers  - —— 
A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer. 
1. De-allocation of memory 
2. Function call 
3. Variable goes out of scope

1. De-allocating of memory - 
// Deallocating a memory pointed by ptr causes
// dangling pointer
#include <stdlib.h>
#include <stdio.h>
int main()
{
    int *ptr = (int *)malloc(sizeof(int));
 
    // After below free call, ptr becomes a 
    // dangling pointer
    free(ptr); 
    printf("printing memory address %p\n", ptr);
    // No more a dangling pointer
    ptr = NULL;
    printf("printing memory address %p\n", ptr);
}
—— output —
printing memory address 0xf34010
printing memory address (nil)

—— —2. Function call 
#include <stdio.h>
int *fun(int ad){ 
 ad += 5;
  return &ad;
}


int main(){  
  int *p = fun(30);
//  fflush(stdin);  //this will make pointer dangling ...
  printf("new value %d\n", *p);
  return 0;
}

—Output — 
new value  35 , if we use fflush then new value will be 0


—— ———3. Variable goes out of scope
#include<stdlib.h>
 
int main()
{
    int x = 4;
    float y = 5.5;
    char c[5] = "allan";
    
    //A void pointer
    void *ptr;
    ptr = &x;
 
    // (int*)ptr - does type casting of void 
    // *((int*)ptr) dereferences the typecasted 
    // void pointer variable.
    //below after printing , we will dereference int type of ptr so that we
    //can use it for float printing. if we dont then it will print some garbage
    printf("Integer variable is = %d\n", *( (int*) ptr) );
    // void pointer is now float
    
    ptr = &y;  
    //below after printing , we will dereference float tile of ptr so that we
    //can use it for char.
    printf("\nFloat variable is= %f\n", *( (float*) ptr) ); 
    
    ptr = &c;
    printf("\nCharacter variable is= %s\n", ( (char*) ptr));\
    return 0;
}
—output — 
Integer variable is = 4
Float variable is= 5.500000
Character variable is= allan

————————— Using pointer in the function ——————— 
#include <stdio.h>
void salaryhike(int  *var, int b)
{
    *var = *var+b;  // here we are doing operation on only address which is void data type.
}
int main()
{
    int salary=0, bonus=0;
    printf("Enter the employee current salary:"); 
    scanf("%d", &salary);
    printf("%d\n", &salary); //here we are passing address of salary to pointer
    printf("%d\n", salary);
    printf("Enter bonus:"); //here we are passing value to anthor int variable b
    scanf("%d\n", &bonus);
    salaryhike(&salary, bonus);   
    printf("Final salary: %d\n", salary); //here we are picking what is newly updated at salary address
    return 0;
}

-------output - 
Enter your salary : 100
734484343994
100
Enter bonus: 200 
Final salary: 300

—————————— simple pointer ————— 
#include <stdio.h>
int main() { 

  int v = 100; 
  int *a = &v; //we can only assign address to pointer not a value, so *a = v not possible
  printf("address stored at pointer %d\n", a); //this is address of variable
  printf("address of a variable %d\n", &v); //this is original variable address
  printf("value of pointer %d\n", *a); //this stores the value of the variable
  return 0;
}
—————output ————— 
address stored at pointer -2137135004
address of a variable -2137135004
value of pointer 100
—————————— using pointer in function ————— 
#include <stdio.h>

void fun1(int *x) {  //here definitio says x is pointer , pointed to address of f1. just a reference
    *x = *x + 5; //here we are now dealing with actual value stored at f1 address. * means value now.
    printf("what is x %d\n", x);  //here naked x means address. so * means value and naked variable means address
}
int main() { 
  int f1 = 20;   
  printf("original value func1 value %d\n", f1); 
  fun1(&f1);
  printf("value func1 value %d\n", f1); 
  return 0;
}
———output ————— 
original value func1 value 20
what is x 1870475468
value func1 value 25
——————— ——— - — — extern ——————— ——— - —
------main.c file where we have value of count is set. Variables of this storage class are “Global variables”
    Global Variables are declared outside the function and are accessible to all functions in the program
    Generally , External variables are declared again in the function using keyword extern
    In order to Explicit declaration of variable use ‘extern’ keyword

#include <stdio.h>
int count ;
extern void write_extern();
 
main() {
   count = 5;
   write_extern();
}


----support.c file where we have declare count variable.
#include <stdio.h>
extern int count;
 
void write_extern(void) {
   printf("count is %d\n", count);
}
—output — 
> gcc main.c support.c 
>./a.out
>count is 5

——————— ——— - — — gets/EOF/feof  ——————— ——— - —
#include <stdio.h>
 
int main()
{
  FILE *fp = fopen("test.txt", "r");
  int ch = getc(fp);
  while (ch != EOF) 
  {
    /* display contents of file on screen */
    putchar(ch); 
 
    ch = getc(fp);
  }
   
  if (feof(fp))
     printf("\n End of file reached.");
  else
     printf("\n Something went wrong.");
  fclose(fp);
     
  getchar();
  return 0;
}
——output ——
> this data came from file 
> End of the file reached.

——————————— Endian-ness – Little Vs Big ——————— ————— 
#include <stdio.h>
/* function to show bytes in memory, from location start to start+n*/
void show_mem_rep(char *start, int n) 
{
    int i;
    for (i = 0; i < n; i++)
         printf(" %.2x", start[i]);
    printf("\n");
}
/*Main function to call above function for 0x01234567*/
int main()
{
   int i = 0x01234567;
   show_mem_rep((char*)&i, sizeof(i));
   return 0;
}

——————— output ————— 
 67 45 23 01
——————— binary operations ————— 
#include <stdio.h>
main() {
    unsigned int a = 60;    /* 60 = 0011 1100 */
    unsigned int b = 13;    /* 13 = 0000 1101 */
    int c = 0;
    c = a & b;       /* 12 = 0000 1100 */
    printf("Line 1 - Value of c is %d\n", c );
    c = a | b;       /* 61 = 0011 1101 */
    printf("Line 2 - Value of c is %d\n", c );
    c = a ^ b;       /* 49 = 0011 0001 */
    printf("Line 3 - Value of c is %d\n", c );
    c = ~a;          /*-61 = 1100 0011 */
    printf("Line 4 - Value of c is %d\n", c );
    c = a << 2;     /* 240 = 1111 0000 */
    printf("Line 5 - Value of c is %d\n", c );
    c = a >> 2;     /* 15 = 0000 1111 */
    printf("Line 6 - Value of c is %d\n", c );
}
——————— ——Bitfield ——— ————— 

#include <stdio.h>
#include <string.h>

struct {
    unsigned int age : 4; 
    //here 4 means bits expressed in 2^4 = 16 so upto 0-15 values compiler will
    //take. example below it will print all 4,8 but only 15.0 instead of 15.2 since bits 
    //can store 16 values only(0-15) so .2 is ignored. Try int age : 5 then it will print upto 0-31
} Age;

/* example in structure below - unnamed bit field can be used to push boundary to next slot example 2^4
struct test2
{
   unsigned int x: 5;
   unsigned int: 0;   //this will take it to 8 byte but combined of 5 and 8 bits can stay under 16 which is 4 byte ( 2^4) .
   unsigned int y: 8;
};
*/
int main( ) {

   Age.age = 4;
   printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
   printf( "Age.age : %d\n", Age.age );

   Age.age = 8;
   printf( "Age.age : %d\n", Age.age );
      Age.age = 15.2;
      printf( "Age.age : %.1f\n", (float) Age.age );

   // below address of bitfield is not permitted. it will give error
   printf("Address of test2.x is %p", &t.x);
   return 0;
}
———Output ——— ————— 
Sizeof( Age ) : 4
Age.age : 4
Age.age : 8
Age.age : 15.0

——————— ——Bitfield interesting example ——— ————— 

#include <stdio.h>
struct test
{
   unsigned int x;
   long int y: 33;
   unsigned int z;
};
int main()
{
   struct test t;
   unsigned int *ptr1 = &t.x;
   unsigned int *ptr2 = &t.z;
   printf("%d", ptr2 - ptr1);
   return 0;
}
———Output ——— ————— 
4 
——————— —gets() and fgets() — gets() is more dangerous can result in buffer overflow, use only fgets() ———  

———————— Format specifier ——————— -   —— - - 
The % specifiers that you can use in ANSI C are:
Usual variable type Display
%c char single character
%d (%i) int signed integer
%e (%E) float or double exponential format
%f float or double signed decimal
%g (%G) float or double use %f or %e as required
%o int unsigned octal value
%p pointer address stored in pointer
%s array of char sequence of characters
%u int unsigned decimal
%x (%X) int unsigned hex value
 ——— ————— ——— ————— ——— ————— 
Direct Access Memory - https://en.wikipedia.org/wiki/Direct_memory_access


 ——— ————— ———Array ————— ——— ————— 

————————— Scenario = Assigning structure as a array element ———— 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct info { 
  char typeofstorm;
  int category;
};

int main() {
  struct info structarray[2];
  int i=0;

  structarray[0].typeofstorm = 'h'; 
  structarray[0].category = 5;

  structarray[1].typeofstorm = 'T'; 
  structarray[1].category = 4;

  for (i=0 ; i< 2; i++) {
    printf("storm name %c\n",structarray[i].typeofstorm);
    printf("catgeory %d\n", structarray[i].category);
  }
  return 0;
}

———— output —— 
storm name h
catgeory 5
storm name T
catgeory 4


—————————— scenario 2 - Array of Char Pointers —————————— 
#include <stdio.h>

int main() { 
  char *p1 = "whats a day";
  char *p2 = "holiday";
  char *p3 = "Thursday";

  char*  a[3];      // here * is next to char so this is array of 3 character pointer.
  a[0] = p1;
  a[1] = p2;
  a[2] = p3;
  int i=0;

  for (i=0; i<3; i++) { 
    printf("array values %s\n", a[i]);
  }
  return 0;
}

————— output 

array values whats a day
array values holiday
array values Thursday

————————————— Pointer to Arrays (we need to deference array before printing , first time in history :) ———————


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int main() { 
  char simplearray[3];
  simplearray[0] = 'a';
  simplearray[1] = 'b';
  simplearray[2] = 'c';

//pointer to simplearray
  char (*pointertosimplearray)[3];

  pointertosimplearray = &simplearray;
  printf("array elements %c\n", (*pointertosimplearray)[0]); //before printing array needs to be dereferenced.
  printf("array elements %c\n", (*pointertosimplearray)[1]);
  printf("array elements %c\n", (*pointertosimplearray)[2]);
  return 0;
}

———— output —— 
array elements a
array elements b
array elements c

—————————————Static vs Dynamic Array ——————————— 


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() { 
  int n=0;
  printf("Enter number of elements for array : ");
  scanf("%d", &n);

  //Dynamic memory assignment in heap, if we speicy [3] then it goes on stack
  char *ptr = (char*) malloc(n);
  

  int i=0;

  for(i=0; i<n; i++) { 
    ptr[i] = i;
    printf("array elements %d\n", ptr[i]);  
  }
  free(ptr);
  return 0;
}

———— output ——— 
Enter number of elements for array : 4
array elements 0
array elements 1
array elements 2
array elements 3

—————————————— Decomposing Array into Pointers ——————— 

Internally, arrays aren’t treated specially, they are decomposed into pointers and operated there-on. For example an array like :
char arr[10];
When accessed like :
arr[4] = 'e';
is decomposed as :
*(arr + 4) = 'e'

——————————————— Character Arrays and Strings——————— 
‘\0’ . If this is present after a series of characters in an array, then that array becomes a string.
This is an array:  char arr[] = {'a', 'b', 'c'};
This is a string:   char arr[] = {'a', 'b', 'c', '\0'};

——————————————— Bi-dimensional and Multi-dimensional Arrays——————— 
Example below - 5 rows for names ; 10 characters for each name and 50 characters for each address 
char arr[5][10][50];

————— —————— example Bi-dimensional ———————————— 
#include <stdio.h>
#include <string.h>

int main() { 
  char simplearr[3];
  simplearr[0] = 'a';
  simplearr[1] = 'b'; 
  simplearr[2] = 'c';
  int i=0;
  for ( i=0 ; i<2; i++) {
    printf("array elements %c\n", simplearr[i]);
  }
      printf("array as string %s\n", simplearr); //this will put ? mark at the end because it doesnot 
//find \0 as last character. so technically it is not a string.
  i= 0;
  memset(simplearr, '\0', sizeof(simplearr));
  simplearr[0] = 'a';
  simplearr[1] = 'b';  
  //simplearr[2] = '\0' this will be automatically filled up due to memset command.
    printf("array elements %s\n", simplearr);  //printing array as string

  return 0;
}


———— output — 
array elements a
array elements b
array as string abcw?
array elements ab

———————————— Use of strncpy library ———————— 
#include <stdio.h>
#include <string.h>

int main () {  
  char simplearray[20];

  memset(simplearray, '\0', sizeof(simplearray));
  char *ptr = "Gonsalves"; 
  strncpy(simplearray, ptr, 15);  //here 15 is sizeof
  printf("array - %s\n", simplearray );
  return 0;
}

———output ——— 
array - Gonsalves

—————————————————— Two dimensional array——————————— 

#include <stdio.h>
#include <string.h>

int main() { 
  int multiarray[3][4] = { 
              { 4, 2, 5, 2},
              { 6, 2, 4, 5},
              { 8, 6, 3, 2}
              };
  int *pointertomultiarray = &multiarray[0][0];
  int i=0;
  for(i=0; i<12; i++) { 
    printf("array shown - %d\n", *(pointertomultiarray + i));
  }
  return 0;
}

——— output ——— 
array shown - 4
array shown - 2
array shown - 5
array shown - 2
array shown - 6
array shown - 2
array shown - 4
array shown - 5
array shown - 8
array shown - 6
array shown - 3
array shown - 2

——————————————————  y——————————— 









————————————— C ++ ——————————————————
To run program use below command 

> g++ <name of the program > -std=c++11   //add -std=c++11 only if you get error on compiler 
> ./a.out 		// to run program 

———————— Simple data types printing —————————— 
#include <iostream>
using namespace std;
 
extern int a, b;
extern int c;
extern float f;
  
int main () { 
   int a = 20 , b = 20;
   int c = a+ b;
   float f;
 
   cout << c << endl ;  //here endl is like \n new line and flush() 

   f = 70.0/3.0;
   cout << f << endl ;  //there is no %d like we used in C 
   return 0;
}
———— output ——— 
40
23.3333
———————————— Alternative way to use standard literary ———————— 

#include <iostream>
//using namespace std  - we can use std:: also as shown below

static int c = 5;
void fun(void);

int main() { 
  while(c--) { 
    fun();
  }
  return 0;
}

void fun(void) { 
  std::cout << "Value of c is : " << c << std::endl;
}

————— output —————— 
Value of c is : 4
Value of c is : 3
Value of c is : 2
Value of c is : 1
Value of c is : 0

—————————— Forever loop - —————————— 
#include <iostream>
using namespace std;
 
int main () {
   for( ; ; ) {
      printf("This loop will run forever.\n");
   }

   return 0;
}

———————————— Few standard functions - ————— 
#include <iostream>
#include <cmath>
using namespace std;
 
int main () {
   // number definition:
   short  s = 10;
   int    i = -1000;
   long   l = 100000;
   float  f = 230.47;
   double d = 200.374;

   // mathematical operations;
   cout << "sin(d) :" << sin(d) << endl;
   cout << "abs(i)  :" << abs(i) << endl;
   cout << "floor(d) :" << floor(d) << endl;
   cout << "sqrt(f) :" << sqrt(f) << endl;
   cout << "pow( d, 2) :" << pow(d, 2) << endl;
 
   return 0;
}
——output ——— 
sin(d) :-0.634939
abs(i)  :1000
floor(d) :200
sqrt(f) :15.1812
pow( d, 2) :40149.7

———————————————— Generate Random numbers ————————— 

#include <iostream>
#include <ctime>
#include <cstdlib>
using namespace std;
int main () {
   int i,j;
   // set the seed
   srand( (unsigned)time( NULL ) );
   /* generate 5  random numbers. */
   for( i = 0; i < 5; i++ ) {
      // generate actual random number
      j = rand();
      cout <<" Random Number : " << j << endl;
   }
   return 0;
}
———— output —————— 
 Random Number : 866241598
 Random Number : 2091619569
 Random Number : 1545570698
 Random Number : 1782012089
 Random Number : 931262115

——————————— set base/setw/setfill functions — —————————— 

// CPP Program to illustrate 
// std::setbase manipulator 
#include <iostream> 
#include <iomanip> // std::setbase 
using namespace std;


int main() 
{ 
    // set base to hexadecimal 
    cout << setbase(16); 

    // displaying 255 in hexadecimal 
    cout << 255 << endl; 
  
    // set base to Octal 
    cout << setbase(8); 
  
    // displaying 255 in Octal 
    cout << 255 << endl; 
    string str = "what a day";
    cout << str << endl;
    cout << setw(20); 
    cout << setfill('x');
    cout << str << endl;
    return 0; 
} 
————— output ————— 
ff
377
what a day
xxxxxxxxxxwhat a day

————————————— String operations ——————————— 
#include <iostream>
#include <cstring>
using namespace std;

int main() { 

  char s1[10] = "First";
  char s2[10] = "Second";
  char s3[20] ;
  char s4[20];
  int len;
  
//strcpy . strcat . strlen
  strcpy(s3, s1);
  strcat(s1,s2);
  len = strlen(s1);

  cout << "Strcpy from s1 to s3 : " << s3 << endl ;
  cout << "Strcat of s1 and s2 : " << s1 << endl ;
  cout << "strlen(s1) : " << len << endl;
  return 0;
 }
—————— output —————— 
Strcpy from s1 to s3 : First
Strcat of s1 and s2 : FirstSecond
strlen(s1) : 11

————————————— Reference vs Pointer  ——————————— 

A reference variable is an alias, that is, another name for an already existing variable. Once a reference is initialized with a variable, 
either the variable name or the reference name may be used to refer to the variable.

#include <iostream>
using namespace std;

int main() { 

  int i=20;
  int& ref_of_i_variable = i;   //we use & for reference variable . It is not a pointer 

  cout << "Value of i : " << i << endl;
  cout << "Reference value of i : " << ref_of_i_variable << endl ;
  return 0;
}
———— output ——— 
Value of i : 20
Reference value of i : 20

——————————— Pointer ——————————— 
#include <iostream>
#include <cstring>
using namespace std;
int main()  { 
  int *pointer; 
  int var = 300;
  pointer = &var;
  cout << "Value of variables - " << *pointer << endl;
  cout << "Address of pointer - " << pointer << endl;
  return 0;
}
——————— output ——————
Value of variables - 300
Address of pointer - 0x7ffc829a8d44

——————————— Ctime functions ——————————— 
#include <iostream>
#include <ctime>
using namespace std ; 

int main()  { 

  time_t gettime = time(0) ;
  char *stringtime = ctime(&gettime); //ctime it char type

  cout << "String time is : " << stringtime << endl;

  tm* structtime = localtime(&gettime); //localtime or gmtime are tm structure type, rest are char types
  cout << "year " << 1970 + structtime->tm_year << endl ; //time elapsed since January 1, 1970

  return 0;
}

———— output ———————— 
year 2088
——————————— Basic input/output ——————————— 

<iostream > - This file defines the cin, cout, cerr and clog objects, which correspond to the standard input stream, the standard output stream, 
the un-buffered standard error stream and the buffered standard error stream, respectively
<fstream> - This file declares services for user-controlled file processing
<iomainp> - This file declares services useful for performing formatted I/O with so-called parameterized stream manipulators, such as setw and setprecision.

#include <iostream>
using namespace std;
 
int main() {
   char name[50];
   char str[25] = "this will be buffered";
   cout << "Please enter your name: ";
   cin >> name; 
   cout << "Your name is: " << name << endl;
   clog << "Error message : " << str << endl;   //this output will be buffered
}

—— output —— 
Please enter your name: Alan
Your name is: Alan
Error message : this will be buffered

——————— ———— NEW KEYWORD AND OPERATOR ——————— ———— 
When you create a new object, memory is allocated using operator new function and then the constructor is invoked to initialize the memory. Here, The new operator does both the allocation and the initialization, where as the operator new only does the allocation.

——————— ———— NEW KEYWORD  ——————— ———— 
The new operator is an operator which denotes a request for memory allocation on the Heap. If sufficient memory is available, new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable. When you create an object of class using new keyword(normal new).

The memory for the object is allocated using operator new from heap.
The constructor of the class is invoked to properly initialize this memory.

#include<iostream> 
using namespace std; 
class car 
{ 
    string name; 
    int num; 
    public: 
        car(string a, int n) 
        { 
            cout << "Constructor called" << endl; 
            this ->name = a; 
            this ->num = n; 
        } 
        void display() 
        { 
            cout << "Name: " << name << endl; 
            cout << "Num: " << num << endl; 
        } 
}; 
int main() 
{ 
    // Using new keyword 
    car *p = new car("Honda", 2017); 
    p->display(); 
} 
——— output ——— 
Constructor called
Name: Honda
Num: 2017
——————— ———— NEW OPERATOR  ——————— ———— 
Operator new is a function that allocates raw memory and conceptually a bit similar to malloc().
It is the mechanism of overriding the default heap allocation logic.
It doesn’t initializes the memory i.e constructor is not called. However, after our overloaded new returns, the compiler then automatically calls the constructor also as applicable.
It’s also possible to overload operator new either globally, or for a specific class

#include<iostream> 
#include<stdlib.h> 
  
using namespace std; 
class car 
{ 
    string name; 
    int num; 
  
    public: 
        car(string a, int n) 
        { 
            cout << "Constructor called" << endl; 
            this->name = a; 
            this->num = n; 
        } 
        void display() 
        {  
            cout << "Name: " << name << endl; 
            cout << "Num: " << num << endl; 
        } 
        void *operator new(size_t size) 
        { 
            cout << "new operator overloaded" << endl; 
            void *p = malloc(size); 
            return p; 
        } 
        void operator delete(void *ptr) 
        { 
            cout << "delete operator overloaded" << endl; 
            free(ptr); 
        } 
}; 
  
int main() 
{ 
    car *p = new car("HYUNDAI", 2012); 
    p->display(); 
    delete p; 
} 
———— output ————— 
new operator overloaded
Constructor called
Name: HYUNDAI
Num: 2012
delete operator overloaded
—————————— DIFFERENCE BETWEEN NEW KEYWORD AND OPERATOR ————————— 
New operator vs operator new

Operator vs function: new is an operator as well as a keyword whereas operator new is only a function.
New calls “Operator new”: “new operator” calls “operator new()” , like the way + operator calls operator +()
“Operator new” can be Overloaded: Operator new can be overloaded just like functions allowing us to do customized tasks.
Memory allocation: ‘new expression’ call ‘operator new’ to allocate raw memory, then call constructor.


————————————— *this pointer ————————————— 
 this pointer is used to represent the address of an object inside a member function. For example, consider an object obj calling one of its member function say method() as obj.method(). Then, this pointer will hold the address of object obj inside the member function method(). 
It should be noted that, friend function and static function cannot have this pointer. It's because friend function is not a member function of the class. 
And static function can be invoked without initialization of an object, i.e, static functions are not associated with any object.  

class ClassName {

       private:   
         int dataMember;
 
       public:
           method(int a) {

   // this pointer stores the address of object obj and access dataMember
               this->dataMember = a;
               ... .. ...
           } 
}

int main() {

    ClassName obj;
    obj.method(5);
    ... .. ...
————update simple object as follows - ———— 
#include <iostream>
using namespace  std;

class testbike { 
public : 
  char* bikename;
  int bikeid;

  void getbikedata(char *pointer) {  
    cout << "NAme of the biked passed in object : " << pointer << endl;
    cout << "Original name of the bike : " << this->bikename << endl;
    this->bikename = pointer;
    cout << "New name got updated is this->bikename is : " << this->bikename << endl;
  }

};

int main() { 
  testbike mybike; 
  mybike.getbikedata("Apache2-Suzuki");
  return 0;
}
—————— output ———— 
NAme of the biked passed in object : Apache2-Suzuki
Original name of the bike : 
New name got updated is this->bikename is : Apache2-Suzuki
—————— ———— exercise 2 ——————————— 
#include<iostream> 
using namespace std; 
  
/* local variable is same as a member's name */
class Test 
{ 
  private: 
     int x; 
  public: 
     void setX (int x) 
       { 
           // The 'this' pointer is used to retrieve the object's x 
           // hidden by the local variable 'x' 
           cout << "before this :" << this->x << endl;
           this->x = x; 
           cout << "after this :" << this->x << endl;
       } 
     void print() { cout << "final x = " << x << endl; } 
}; 
  
int main() 
{ 
   Test obj; 
   int x = 20; 
   obj.setX(x); 
   obj.print(); 
   return 0; 
} 
————output ———— 
before this :1059436624
after this :20
final x = 20
——————————— exercise 3 - this pointer ———— 
#include<iostream> 
using namespace std; 
  
class Test 
{ 
private: 
  int x ; 
  int y ; 
public: 
  Test(int x = 0, int y = 0) {   //this is constructor since there is no return type.
    this->x = x; this->y = y; 
  } 
  Test setX(int a) {  //here return type of this setX menthod is class Test itself.
      this->x = a; 
      return *this; 
  } 
  Test setY(int b) {  
    this->y = b; 
    return *this; 
  } 
  void print() { 
    cout << "x = " << x << " y = " << y << endl; 
    cout << "this->x :" << this->x << endl;
    cout << "this->y :" << this->y << endl;    
  } 
}; 
  
int main() 
{ 
  Test obj1(5, 5); 
  // Chained function calls.  All calls modify the same object 
  // as the same object is returned by reference 
  obj1.setX(10).setY(20); 
  
  obj1.print(); 
  return 0; 
} 
—————— output ———— 
x = 10 y = 5
this->x :10
this->y :5
——————————— exercise 4 - this pointer ———— 
#include <iostream>
using namespace std;

class racer {
char name[20];
int score; 
public: 
  void getracerinfo() { 
    cout << "Enter racer name :" << endl;
    cin >> name ;
    cout << "Enter score of the racer : " << endl;
    cin >> score ;
    }
  racer findwinner(racer r2, racer r3) { 
    if ( r2.score > r3.score && r2.score > this->score) 
        return r2;
    else if  ( r3.score > r2.score && r3.score > this->score) 
        return r3;
    else if  ( this->score > r3.score && this->score > r2.score) 
        return *this;
  }

  void displaywinner() { 
    cout << "Name of the racer : " << this->name << endl;
    cout << "Final score :" << this->score  << endl;
  }
};

int main() { 
  racer final, r1, r2, r3;
  r1.getracerinfo();
  r2.getracerinfo();
  r3.getracerinfo();
  final = r1.findwinner(r2, r3);
  final.displaywinner();
  return 0;
}

———— output ———— 
Enter racer name :
Allan
Enter score of the racer : 
40
Enter racer name :
Rick 
Enter score of the racer : 
49
Enter racer name :
Orion
Enter score of the racer : 
65
Name of the racer : Orion
Final score :65

———————————— Excercise 5 - this pointer with class and constructor ———— 
#include<iostream> 
using namespace std; 
  
class Test 
{ 
private: 
  int x; 
public: 
  Test(int x) { this->x = x; }  //this is class constructor , there is no return type.
  void change(Test *t) {  //this is function since it has return type
  this->x = t->x; 
  } 
  void print() { cout << "x = " << x << endl; } 
}; 
  
int main() 
{ 
  Test obj(30); 
  Test *ptr = new Test (100); //new way to initialize pointer to class.
  obj.change(ptr); 
  obj.print(); 
  return 0; 
}
———————output ———————
x = 100
————— ———————— Classes and objects ————————— —————— 
————— Scenario 1 = Simple class ————— 
#include <iostream>
using namespace std;

class myblueprint { 
  public : 
    char *name;
    int id;
};

int main() { 
  myblueprint A;
  A.name = "Allan";
  A.id = 2000;
  cout << "First candidate name: "<< A.name << endl;
  cout << "First candidate id : "<< A.id << endl;
  return 0;
}
—————— output —————— 
First candidate name: Allan
First candidate id : 2000

————— Scenario 2 = Base and Derived class ————— 
class derived-class: access-specifier base-class

Where access-specifier is one of public, protected, or private, and base-class is the name of a previously defined class. If the access-specifier is not used, then it is private by default.

#include <iostream>
using namespace std;

class baseclass { 
  public: 
  //function 
      void setname(char n){ 
        publicname = n;
        protectedname = n;
        privatename = n;
     }

      void setid(int i) { 
        publicid = i;
        protectedid = i;
        privateid = i;
      }  
    char publicname;
    int  publicid;
  protected:
    char protectedname;
    int  protectedid;
  private:
    char privatename;
    int  privateid;

};

class derivedclass: public baseclass { 
  public: 
    char getname() { 
//      return publicname; //this will print a
//      return protectedname ; //this will print a
        return privatename;  //this will error out since other classes cannot access private objects
        
    }
    int getid() { 
//      return publicid;  //this will print 10
//      return protectedid; //this will print 10
        return privateid;  //this will error out since other classes cannot access private objects
    }

};

int main() { 
  derivedclass myinfo;
  myinfo.setname('a');
  myinfo.setid(10);
  
  cout << "Name : " << myinfo.getname() << endl;
  cout << "Id : "  << myinfo.getid() << endl;

  return 0;
}
————————————— Scenario 3 — Multiple Inheritance—————————————— 

#include <iostream> 
using namespace std;

 
//set parameters
class areaclass {
  public : 
    float width;
    float height;
    void setdata(int w, int h) {  
      width = w;
      height = h;
    }
};

//function
class costclass { 
public: 
  double costnumber(double area) {  
    return area * 90;
  }
};

//get the value
class derivedclass : public areaclass , public costclass { 
public:
  int getarea() {  
    return (width * height); 
  }
};

int main() { 
  double finalcost;
  double area;
  derivedclass ref;
  ref.setdata(200,100);
  area = ref.getarea();
  finalcost = ref.costnumber(area); 
  cout << "Area : " <<  area << endl;
  cout << "Cost : " << finalcost << endl;
  return 0;
}

———— output ———— 
Area : 20000
Cost : 1.8e+06

————————————— Scenario 4— Overloading —————————————— 

You can have multiple definitions for the same function name in the same scope. The definition of the function must differ from each other by the types and/or the number of arguments in the argument list. You cannot overload function declarations that differ only by return type.

#include <iostream>
using namespace std;
 
class printData {
   public:
      void print(int i) {
        cout << "Printing int: " << i << endl;
      }
      void print(double  f) {
        cout << "Printing float: " << f << endl;
      }
      void print(char* c) {
        cout << "Printing character: " << c << endl;
      }
};

int main(void) {
  printData ptf;
  ptf.print(4) ;
  ptf.print("what a day");
  ptf.print(43.993);

  return 0;
}
————— output ————— 
Printing int: 4
Printing character: whats a day
Printing float: 43.993

————————————— Scenario  —  Overloading operator using without constructor and void return type —————————————— 

#include <iostream>
using namespace std;


class printclass { 
  private : 
    int var1 = 100 ; 
    int var2 = 300 ;

  public : 
  void printnow() { 
    cout << "First variable value " << var1 << endl;
    cout << "Second variable value " << var2 << endl;
  }
  
  void operator - () { 
    var1 = (5) * var1;
    var2 = (4) * var2; 
  }
};


int main() { 
  printclass P;
  -P;       //use operator for calculation here
  P.printnow(); 
  return 0;
}

———— output ——— 
First variable value 500
Second variable value 1200

————————————— Scenario  —  Overloading operator using constructor and class as return type —————————————— 
#include <iostream>
using namespace std;

class Distance { 
  public : 
    int length; 
    int height;

    Distance() {  					//this is empty constructor 
      length = 0; 
      height = 0;
    }

    Distance(int a , int b) { 			//this is constructor 
      length = a; 
      height = b;
    }
    void printall() { 
      cout << "Length  : " << length << endl;
      cout << "Height  : " << height << endl;
    }

  Distance operator - () { 					// here class is used as return type 
      length = length * 2;    //here operator is - and actual operation is multipilcation , so doesnt matter
      height = height * 2;
      return Distance( length, height);
  }

}; 
int main() {
  Distance obj(30, 40);
  -obj;   
  obj.printall() ;
  return 0;
}

———— output —— 
Length  : 60
Height  : 80

————————————— Scenario  —  Overloading operator Assignment operator  —————————————— 

#include <iostream>
using namespace std;

class Distance {
    
    public :
    int id ;
    int age;
    
    Distance(){
        id = 0 ; age = 0;
    }
    Distance(int a , int b) {
        id = a; age = b;
    }
    void operator = ( const Distance &o) {
        id = o.age;
        age = o.id;
    }
    void printall() {
        cout << "Id is - " << id << endl << "Age is : " << age << endl;
    }
};

int main() {
    
    Distance o1;
    Distance o2(30 , 40);
    o2.printall();
    o1 = o2;
    cout << "swapping below" << endl;
    o1.printall();
    return 0;
}


——— output ———— 
Id is - 30
Age is : 40
swapping below
Id is - 40
Age is : 30

——————————  Scenario  —  Overloading operator Subscripting [] Operator —————————— 

#include <iostream>
using namespace std;
const int SIZE = 10;

class safearay {
private:
    int arr[SIZE];
    
public:
    safearay() {
        register int i;
        for(i = 0; i < SIZE; i++) {
            arr[i] = i;
        }
    }
    
    int &operator[](int i) {
        if( i > SIZE ) {
            cout << "Index out of bounds" <<endl;
            // return first element.
            return arr[0];
        }
        
        return arr[i];
    }
};

int main() {
    safearay A;
    
    cout << "Value of A[2] : " << A[2] <<endl;
    cout << "Value of A[5] : " << A[5]<<endl;
    cout << "Value of A[12] : " << A[12]<<endl;
    
    return 0;
}

————— output ——— 
Value of A[2] : 2
Value of A[5] : 5
Value of A[12] : Index out of bounds
0

————————————— Scenario  1 —  Class Member Access Operator (->) Overloading —————————— 

The class member access operator (->) can be overloaded but it is bit trickier. It is defined to give a class type a "pointer-like" behavior. The operator -> must be a member function. If used, its return type must be a pointer or an object of a class to which you can apply. 
The operator-> is used often in conjunction with the pointer-dereference operator * to implement "smart pointers." These pointers are objects that behave like normal pointers except they perform other tasks when you access an object through them, such as automatic object deletion either when the pointer is destroyed, or the pointer is used to point to another object.

#include <iostream>
using namespace std;

class Marks {
  int mark;
  public:
    Marks(int m){
      mark = m;
    }

      void whatsYourMark(){
      cout << "hey i got "<< mark <<" marks" << endl;
      }

      Marks *operator->(){
      return this;
      }
};

int main()
{
  Marks anilsmark(65);
  anilsmark.whatsYourMark();
  anilsmark->whatsYourMark();
  return 0;
}
————— output —————— 
hey i got 65 marks
hey i got 65 marks

——————————— Scenario 2 - Class Member Assess Operator (->) overloading ———————— 
#include <iostream>
#include <string>
using namespace std;

class getdetails {  
public : 
  string name = "Alan Gonsalves";
  void getmarmks(int s) { 
    cout << "My score is - " << s << endl; 
  }
  void myname(string n) { 
      cout << "Name is " << n << endl;
  }
getdetails *operator->() { 
    return this ;
}

};

int main() { 
  getdetails c1;
  c1->getmarmks(300);   		// so class object c1 is assessing function indirectly using -> operator.
  c1->myname("Rick Goru") ;	// so class object c1 is assessing different function indirectly using -> operator.
  cout << "Print name now --> " << c1->name << endl;    	// so class object c1 is assessing parameter member function indirectly using -> operator.
  return 0;
}

———— output ————— 
My score is - 300
Name is Rick Goru
Print name now --> Alan Gonsalves
————————————— Scenario  —  Overloading operator Function call operator  —————————————— 

#include <iostream>
using namespace std;

class Distance {
    public :
    int id;
    int age;
    int km;
    
    Distance() {
        id = 0 ; age = 0 ;  km = 0;
    }
    Distance(int a, int b, int n) {
        id = a ; age = b ; km = n;
        
    }
    void printall() {
        cout << "Id " << id << " Age " << age << " Km " << km << endl;
    }
    
    Distance operator () ( int aa, int bb, int nn) {
        Distance D1;
        D1.id = aa ; D1.age = bb ; D1.km = nn;
        return D1;
    }
};

int main() {
    Distance f_in(10, 20 , 40);
    Distance f_out;
    f_out.printall();
    f_out = f_in(99, 99 , 99); //Function operator passes values to object
    f_out.printall();
    return 0;
}
——— output ————— 

Id 0 Age 0 Km 0
Id 99 Age 99 Km 99



————————————— Scenario  —  Overloading operator —————————————— 

#include <iostream>
using namespace std;

class overloadnow { 
public: 
  int var;
  overloadnow(int x) { 
    this->var = x;
    cout << "class constructor value " << this->var << endl;
  } 
  void printinfo(int y) { 
      this->var = y;
      cout << "first overload1 " << this->var << endl;
  }

  void printinfo(char *c) { 
    cout << "second overload " << c << endl;
  }

  void printinfo(overloadnow *p) { 
    this->var = p->var;
    cout << "third pointer overload " << this->var << endl;
  }

};

int main () { 
  overloadnow myobj(5);
  myobj.printinfo(50);
  myobj.printinfo("nice");
  overloadnow *ptr = new overloadnow(20);
  ptr->var = 400;
  myobj.printinfo(ptr);
  return 0;
}
———output —— 
class constructor value 5
first overload1 50
second overload nice
class constructor value 20
third pointer overload 400
——————————————Scenario  7 - Simple Polymérisation —————— 
In this example, we have two functions with same name but different number of arguments. Based on how many parameters we pass during function call determines which function is to be called, this is why it is considered as an example of polymorphism because in different conditions the output is different. Since, the call is determined during compile time thats why it is called compile time polymorphism

#include <iostream>
using namespace std;

class Add {
public:
  int sum(int num1, int num2){
     return num1+num2;
  }
  int sum(int num1, int num2, int num3){
     return num1+num2+num3;
  }
};

int main() {
  Add obj;
  //This will call the first function
  cout<<"Output: "<<obj.sum(10, 20)<<endl;
  //This will call the second function
  cout<<"Output: "<<obj.sum(11, 22, 33);
  return 0;
}

———— output ———— 
Output: 30
Output: 66
——————————————Scenario  8 - Runtime Polymérisation —————— 
Function overriding is an example of Runtime polymorphism.
Function Overriding: When child class declares a method, which is already present in the parent class then this is called function overriding, here child class overrides the parent class. In case of function overriding we have two definitions of the same function, one is parent class and one in child class. The call to the function is determined at runtime to decide which definition of the function is to be called, thats the reason it is called runtime polymorphism

#include <iostream>
using namespace std;

class dad { 
public:
  void printnow() { 
    cout << "this is dad print "  << endl;
  }
};

class son : public dad { 
public: 
  void printnow() { 
    cout << "this is son print " << endl;
  }
};

int main () { 
  dad o1;
  son o2;
  o1.printnow();
  o2.printnow();
  return 0;
}
————output ———— 
this is dad print
this is son print 
——————————————Scenario  9 - Simple Polymérisation —————— 
The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in 
more than one form.

#include<iostream> 
using namespace std; 
  
class Test 
{ 
private: 
  int x; 
public: 
  Test(int x) { this->x = x; 
  cout << "original value of x : " << x << endl; }  //this is class constructor , there is no return type.

  void change(Test *t) {  //this is function since it has return type
  this->x = 200; 
  cout << "print updated value of x : " << this->x << endl;
  } 
 
}; 
  
int main() 
{ 
  Test obj(30); 
  Test *ptr = new Test(100); //new way to initialize pointer to class.
  obj.change(ptr);  
  return 0; 
}
———— output ——— 
original value of x : 30
original value of x : 100
print updated value 200
————————————— Polymerization and plus operator ———————— 
#include <iostream>
using namespace std;

class Complex { 
  public : 
  int rank; int image;
  Complex (int x , int y) { this->rank = x ; this->image = y;};
    
  Complex operator + ( Complex const &obj) { 
      Complex final(0,0);
      rank = rank + obj.rank;
      image = image + obj.image;
      final.rank = rank;
      final.image = image;
      return final;
  };
  void printdata(Complex o3) { 
      cout << "print final output "  <<o3.rank << endl ;
      cout << "image is " << o3.image << endl;
    }
};

int main() { 
  Complex o1(10,3), o2(20,4);       //this is constructor
  Complex o3 = o1 + o2;             //this is operator
  o3.printdata(o3);
  return 0;
}

——— output ——— 
print final output 30
image is 7
——————————————— How to use virtual keyword - with pointer and address —————————————— 
A virtual function a member function which is declared within base class and is re-defined (Overriden) by derived class. When you refer to a derived class object using a pointer or a reference to the base class, you can call a virtual function for that object and execute the derived class's version of the function.

#include <iostream> 
using namespace std;
 
class Shape {
   protected:
      int width, height;
      
   public:
      Shape( int a = 0, int b = 0){
         width = a;
         height = b;
      }
      virtual int area() {   //if we dont use virtual then compiler thinks user wants to run this function
      //if we use virtual then compiler connects address of rectangle class to shape pointer and executes that function( Shape *shape; )
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
class Rectangle: public Shape {
   public:
      Rectangle( int a = 0, int b = 0):Shape(a, b) { }
      
      int area () { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      Triangle( int a = 0, int b = 0):Shape(a, b) { }
      
      int area () { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }
};

// Main function for the program
int main() {
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);

   // store the address of Rectangle
   shape = &rec;
   
   // call rectangle area.
   shape->area();

   // store the address of Triangle
   shape = &tri;
   
   // call triangle area.
   shape->area();
   
   return 0;
}
————— output ———— 
Rectangle class area :
Triangle class area :

——————————————— How to use pure virtual keyword - without pointer and address —————————————— 
#include <iostream>
using namespace std;
 
// Base class
class Shape {
   public:
      // pure virtual function providing interface framework.
      virtual int getArea() = 0;
      void setWidth(int w) {
         width = w;
      }
   
      void setHeight(int h) {
         height = h;
      }
   
   protected:
      int width;
      int height;
};
 
// Derived classes
class Rectangle: public Shape {
   public:
      int getArea() { 
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      int getArea() { 
         return (width * height)/2; 
      }
};
 
int main(void) {
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   
   // Print the area of the object.
   cout << "Total Rectangle area: " << Rect.getArea() << endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   
   // Print the area of the object.
   cout << "Total Triangle area: " << Tri.getArea() << endl; 

   return 0;
}
—————— output —— 
Total Rectangle area: 35
Total Triangle area: 17

———————————— Virtual destructor———————————— 
Even though destructors are not inherited, if a base class declares its destructor virtual, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base.

class Base {
 public:
    virtual ~Base() { /* releases Base's resources */ }
};
 
class Derived : public Base {
    ~Derived() { /* releases Derived's resources */ }
};
 
int main()
{
    Base* b = new Derived;
    delete b; // Makes a virtual function call to Base::~Base()
              // since it is virtual, it calls Derived::~Derived() which can
              // release resources of the derived class, and then calls
              // Base::~Base() following the usual order of destruction
}

———————————————— Abstraction and Encapsulation ————————— 
Data abstraction refers to providing only essential information to the outside world and hiding their background details, i.e., to represent the needed information in program without presenting the details. Below class adds numbers together, and returns the sum. The public members - addNum and getTotal are the interfaces to the outside world and a user needs to know them to use the class. The private member total is something that the user doesn't need to know about, but is needed for the class to operate properly.

Data encapsulation is a mechanism of bundling the data, and the functions that use them and data abstraction is a mechanism of exposing only the interfaces and hiding the implementation details from the user.

#include <iostream>
using namespace std;

class Adder {
   public:
      // constructor
      Adder(int i = 0) {
         total = i;
      }
      
      // interface to outside world
      void addNum(int number) {
         total += number;
      }
      
      // interface to outside world
      int getTotal() {
         return total;
      };
      
   private:
      // hidden data from outside world
      int total;
};

int main() {
   Adder a;
   
   a.addNum(100);
   a.addNum(200);
   a.addNum(300);

   cout << "Total " << a.getTotal() <<endl;
   return 0;
}
——— output ——— 
Total 600 
—————————————— another example but this time using constructor and all in one class. No child class ————————— 
#include <iostream>
using namespace std;

class multiplyallnow { 
  private : 
    double onlytothisclasstotal ;
  public : 
    //constructor
    multiplyallnow(int x) { onlytothisclasstotal = x; }

    //multiply method
    double mul(int a) { 
      return ( onlytothisclasstotal * a) ;
    }
}; 

int main() { 
  multiplyallnow A(10);
  
  cout << "Final value " << A.mul(20) << endl;
  
  return 0;
}
————— output ———— 
Final value 200

—————————— Interfaces ( Abstract class)  ——————————— 
The purpose of an abstract class (often referred to as an ABC) is to provide an appropriate base class from which other classes can inherit. Abstract classes cannot be used to instantiate objects and serves only as an interface. Attempting to instantiate an object of an abstract class causes a compilation error.

Thus, if a subclass of an ABC needs to be instantiated, it has to implement each of the virtual functions, which means that it supports the interface declared by the ABC. Failure to override a pure virtual function in a derived class, then attempting to instantiate objects of that class, is a compilation error.

Classes that can be used to instantiate objects are called concrete classes.


#include <iostream>
using namespace std;


class outingteam { 
  public : 
  int boys; int gals; 
  virtual void gettotalsize() = 0; 
  void setboys(int a) {
    boys = a; 
  }
  void setgals(int b) { 
    gals = b;
  }  
  protected:
    int strenth;
}; 

class firstteam : public outingteam { 
  public: 
    void gettotalsize() { 
        cout << "Total : " << boys * gals << endl;     //accessing base class variables
        cout << "Strenth : " << boys + gals << endl;
    }  
}; 
 

int main() {
  firstteam f1;
  f1.setboys(300);   //calling base class method 
  f1.setgals(400);   //calling base class method here 
  f1.gettotalsize();  //calling derived class method
  return 0;
}
————— output ——— 
Total : 120000
Strenth : 700


- —————————————— Files ——————————— 

Data types - 
ofstream = This data type represents the output file stream and is used to create files and to write information to files.
Ifstream = This data type represents the input file stream and is used to read information from files.
fstream = This data type represents the file stream generally, and has the capabilities of both ofstream and ifstream which means it can create files, write information to files, and read information from files.

COUT is to write to screen or output 
CIN  is to read from screen or scan user input 

#include <iostream>
#include <fstream> 
using namespace std;


int main() { 
  char data[100];
  ofstream writetothisfile;
  writetothisfile.open("100test.txt");
  cout << "Enter your data that you wish to update to file " << endl;

  cin.getline(data, 100);
  writetothisfile << data << endl;
  writetothisfile.close();
  
  
  ifstream readfromthisfile;
  readfromthisfile.open("100test.txt");
  readfromthisfile >> data ;
  cout << data << endl;

  readfromthisfile.close();
  return 0;
}
———— output ——— 
Enter your data that you wish to update to file 
allan gonsalves
allan

——————————— Exception handling ————————————— 
try {
   // protected code
} catch( ExceptionName e1 ) {
   // catch block
} catch( ExceptionName e2 ) {
   // catch block
} catch( ExceptionName eN ) {
   // catch block
}

The exception handler is declared with the catch keyword immediately after the closing brace of the try block. The syntax for catch is similar to a regular function with one parameter. The type of this parameter is very important, since the type of the argument passed by the throw expression is checked against it, and only in the case they match, the exception is caught by that handler. Multiple handlers (i.e., catch expressions) can be chained; each one with a different parameter type. Only the handler whose argument type matches the type of the exception specified in the throw statement is executed.

If an ellipsis (...) is used as the parameter of catch, that handler will catch any exception no matter what the type of the exception thrown.

—————————— Simple try catch with msg ————————— 
#include <iostream>
using namespace std;

double division(int a , int b) { 
  return a /b ;

}; 

int main() {
  double result;
try { 
  result = division(30,0);
  cout << "result : " << result << endl ;
} catch (const char* msg ) { 
  cerr << msg << endl;
}  
  return 0;
}
————— output ————— 
Floating point exception: 8

—————————— try catch with msg with catch with same parameter type  ————————— 

#include <iostream>
#include <fstream>
using namespace std;


int main () { 
  int num;
  cout << "Enter any number" << endl;
  cin >> num ;

  try { 
    if (num < 0) 
      throw num;
  } catch  ( int n1){  //use same parameter type passed by throw command
//or you use below 
//   Catch ( …)  { 
      cout << "Donot enter less than zero " << n1 << endl;
  }
  return 0;
}
—————output ————— 
Enter any number
-2
Donot enter less than zero -2
———————————————try catch using NULL parameter in function call —————————— 


#include <iostream> 
using namespace std; 
  
// This function signature is fine by the compiler, but not recommended. 
// Ideally, the function should specify all uncaught exceptions and function 
// signature should be "void fun(int *ptr, int x) throw (int *, int)" 
void fun(int *ptr, int x) 
{ 
    if (ptr == NULL) 
        throw ptr; 
    if (x == 0) 
        throw x; 
    /* Some functionality */
} 
  
int main() 
{ 
    try { 
       fun(NULL, 0); 
    } 
    catch(...) { 
        cout << "Caught exception from fun()"; 
    } 
    return 0; 
}
—————— output ————— 
Caught exception from fun()

————————— Class in try -catch block - —————————————— 

When an exception is thrown, all objects created inside the enclosing try block are destructed before the control is transferred to catch block.
#include <iostream> 
using namespace std; 
  
class Test { 
public: 
   Test() { cout << "Constructor of Test " << endl; } 
  ~Test() { cout << "Destructor of Test "  << endl; } 
}; 
  
int main() { 
  try { 
    Test t1; 
    throw 10; 
  } catch(int i) { 
    cout << "Caught " << i << endl; 
  } 
} 

————— output ————————— 
Constructor of Test 
Destructor of Test 
Caught 10

———————————————— Dynamic Memory ———————————— 
The stack − All variables declared inside the function will take up memory from the stack.
The heap − This is unused memory of the program and can be used to allocate the memory dynamically when program runs.

You can allocate memory at run time within the heap for the variable of a given type using a special operator in C++ which returns the address of the space allocated. This operator is called new operator. If you are not in need of dynamically allocated memory anymore, you can use delete operator, which de-allocates memory that was previously allocated by new operator.

#include <iostream>
using namespace std;

int main () {
   double* pvalue  = NULL; // Pointer initialized with null
   pvalue  = new double;   // Request memory for the variable
 
   *pvalue = 29494.99;     // Store value at allocated address
   cout << "Value of pvalue : " << *pvalue << endl;

   delete pvalue;         // free up the memory.

   return 0;
}

———— output —————— 
Value of pvalue : 29495

—————— new cases of Dynamic memory allocation ————— 
char* pvalue  = NULL;         // Pointer initialized with null
pvalue  = new char[20];       // Request memory for the variable

—————— new cases of Dynamic memory allocation ————— 

double** pvalue  = NULL;      // Pointer initialized with null 
pvalue  = new double [3][4];  // Allocate memory for a 3x4 array 

delete [] pvalue;            // Delete array pointed to by pvalue


——————— simple C++ character pointer ————— 

#include <iostream>
using namespace std;

int main() { 
  char str[13] = "What a day” ;

  char *pointer = str;
 
    cout << "print 1 " << pointer << endl;
  return 0 ;
}

——— output ————— 
print 1 What a day

———————————NAMESPACE  ———————————— 
you might be writing some code that has a function called xyz() and there is another library available which is also having same function xyz(). Now the compiler has no way of knowing which version of xyz() function you are referring to within your code. namespace is designed o differentiate similar functions, classes, variables etc. with the same name available in different libraries

#include <iostream>
using namespace std;

namespace first { //this namespace defined like a class
  void fun(int i) { 
    cout << "Value from first " << i << endl;
  }
}

namespace second  { 
  void fun(int i) {
      cout << "Value from second " << i << endl;
  }
}

int main() { 
  first::fun(40) ;   // use :: to call the function within namespace
  second::fun(50);
  return 0;
}
———— output ————— 
Value from first 40
Value from second 50


——————————— TEMPLATES———————————— 

The concept of templates can be used in two different ways:

1) Function Templates
2) Class Templates

The simple idea is to pass data type as a parameter so that we don’t need to write same code for different data types. For example a software company may need sort() for different data types. Rather than writing and maintaining the multiple codes, we can write one sort() and pass data type as a parameter. C++ adds two new keywords to support templates: ‘template’ and ‘typename’. The second keyword can always be replaced by keyword ‘class’. Templates are expanded at compiler time. This is like macros. The difference is, compiler does type checking before template expansion. The idea is simple, source code contains only function/class, but compiled code may contain multiple copies of same function/class.

template <class T>
T someFunction(T arg)
{
   ... .. ...
}


See diagram at https://www.geeksforgeeks.org/templates-cpp/

#include <iostream>
using namespace std;

template <typename sample>
sample function(sample x, sample y) { 
  return (x > y) ? x: y;
}

int main() { 
  cout << "Max of (4,7) --- " << function<int> (4,7) << endl;
  cout << "Ascending order of A and P --- " << function<char> ('A','P') << endl;
  cout << "Max of float(5.4,1.3) --- " << function<float> (5.4,1.3) << endl;
  return 0;
}
————— output ———— 
Max of (4,7) --- 7
Ascending order of A and P --- P
Max of float(5.4,1.3) --- 5.4


———— Example of  Function Template ( passing a value) ———————— 

#include <iostream>
using namespace std;

template <typename mytem>
mytem fun1(mytem x, mytem y) { //defining int type function
  return x * y;
}

template <typename mytem1> //defining second template accepting array type
mytem1 fun2(mytem1 arr[], mytem1 i){ 
  for (int j = 0; j < i ; j++) { 
    cout << " Values of array " << arr[j] << endl;
  }
}

int main() { 
  int arr[] =  { 4,2,6,7,3,7};
  int size = sizeof(arr)/ sizeof(int);
  cout <<  fun1(4,5) << endl;
  fun2(arr, size);
  return 0;
}

——— output ———— 
20
 Values of array 4
 Values of array 2
 Values of array 6
 Values of array 7
 Values of array 3
 Values of array 7

———— Example of  Function Template ( call by reference ) ———————— 

#include <iostream>
using namespace std;

template <typename T>
  void swapfun( T &x , T &y) { 

    T holdvalue;
    holdvalue = y;
    y = x;
    x = holdvalue;

  }
int main() { 
  int i1 = 100, i2 = 200; 
  
  cout << "Before Swap - " << i1 << ": " << i2 << endl;
  swapfun( i1, i2) ;
  cout << "Post Swap - " << i1 << ": " << i2 << endl;
  return 0;
} 

—— output —— 
Before Swap - 100: 200
Post Swap - 200: 100


———— Example of  Class Template ———————— 

Class Templates Like function templates, class templates are useful when a class defines something that is independent of data type. Can be useful for classes like LinkedList, BinaryTre, Stack, Queue, Array, etc. Like function templates, you can also create class templates for generic class operations.Sometimes, you need a class implementation that is same for all classes, only the data types used are different. Normally, you would need to create a different class for each data type OR create different member variables and functions within a single class. In below declaration -  T is the template argument which is a placeholder for the data type used.

Inside the class body, a member variable var and a member function someOperation() are both of type T.

template <class T>
class className
{
   ... .. ...
public:
   T var;
   T someOperation(T arg);
   ... .. ...
};

To create a class template object, you need to define the data type inside a < > when creation
className<dataType> classObject;

—————— Example —————— 
#include <iostream>
using namespace std;

template <class T>
class calculator { 
  public : 
    T num1;
    T num2;
    T result;
      
    calculator(T x, T y) { 
      num1 = x;
      num2 = y;
    }

    T addition() { 
      return result = num1 + num2;
    }
 
};

int main() { 

  calculator<int> obj1(2,4);
  cout << " Addition int value : " << obj1.addition() << endl;
  calculator<float> obj2(4.3, 5.3);
  cout << " Addition float value : " << obj2.addition() << endl;
  
  return 0;
}

——————— output —— 
 Addition int value : 6
 Addition float value : 9.6

—————— Can there be more than one arguments to templates?— YES ———— 

#include <iostream>
using namespace std;

template <class T , class S >
class calculator {
    public :
    T x;
    S y;
    S result;
    
    calculator(T n1, S n2) {
        x = n1;
        y = (T) n2; //This is casting from float to int
    }
    
    S addition() {
        return result =  x + y;
    }
};

int main() {
    calculator<int,float> obj1(3,2.5);  //here 3,2 is for constructor feed.
    cout << " Addition of 2 numbers - " << obj1.addition() << endl;
    return 0;
}
———— output ———— 
 Addition of 2 numbers - 5.5


———————— Can we pass nontype parameters to templates? ———————— 
#include <iostream> 
using namespace std; 
   
template <class T, int max> 
int arrMin(T arr[], int n) 
{ 
   int m = max; 
   for (int i = 0; i < n; i++) 
      if (arr[i] < m) 
         m = arr[i]; 
   return m; 
} 
   
int main() 
{ 
   int arr1[]  = {10, 20, 15, 12}; 
   int n1 = sizeof(arr1)/sizeof(arr1[0]); 
   
   char arr2[] = {1, 2, 3}; 
   int n2 = sizeof(arr2)/sizeof(arr2[0]); 
   
   // Second template parameter to arrMin must be a constant 
   cout << arrMin<int, 10000>(arr1, n1) << endl; 
   cout << arrMin<char, 256>(arr2, n2)  << endl; 
   return 0; 
} 
————output ——— 
10
1


——————————— Void pointers ———————————— 
This is a special type of pointer available in C++ which represents absence of type. void pointers are pointers that point to a value that has no type (and thus also an undetermined length and undetermined dereferencing properties).
This means that void pointers have great flexibility as it can point to any data type. There is payoff for this flexibility. These pointers cannot be directly dereferenced. They have to be first transformed into some other pointer type that points to a concrete data type before being dereferenced.

See below how we took value of &c and &I into a void point just to pass address and then used pointer with concrete data type for proper assignment 

#include <iostream>
using namespace std;

//*vp below is called void pointer , it just pass address of incoming parameter to real pointer 
//actualcharpoint and actualintpointer
void decrease (void *vp, int size) { 
  if ( size == sizeof(char)) { 
    char *actualcharpoint = (char*) vp;
    (*actualcharpoint)--;
    cout << "Previoud value of char : " << *actualcharpoint << endl;
  } 
  else if ( size == sizeof(int)) { 
    int *actualintpointer = (int*) vp;
    (*actualintpointer)--;
    cout << "Previous value of int :" << *actualintpointer << endl;
  }
  
}
int main() { 
  char c = 'x';
  int i = 10;
  cout << "Original value of char : " << c << endl;
  decrease(&c, sizeof(char)) ;
  cout << "Orginal value of int : " << i << endl;
  decrease(&i, sizeof(int));
  return 0;
}
————— output ——— 
Original value of char : x
Previoud value of char : w
Orginal value of int : 10
Previous value of int :9

——————————————— String operations ————————————— 

#include <iostream>
using namespace std;


//insert(pos, string) 
//find a target string in s1 = find(target)
//replace(pos, length_of_portion, string_to_replace) 

int main() { 
  string s1 = "What a day"; 
  string s2 = "nice day indeed";
  string sfinal ;

 cout << "size of s1 " << sizeof(s1) << endl;
 sfinal = s1.append(" sunday");
 cout << "Appended string : " << sfinal << endl;

 if ( s1.compare(s2) == 0) { 
    cout << "String compare match " << endl;
 } 
 else { 
    cout << "String compare mismatch " << endl;
 }

  cout << "Inserted new stuff into s1 " << s1.insert(3, "----wow----") << endl;
  cout << "Find day into string position - " << s1.find("day") << endl;
  cout << "Replacement of s2 - " << s2.replace(5,4," ___station___") << endl;
  return 0;
}
——————— output ————— 
size of s1 24
Appended string : What a day sunday
String compare mismatch 
Inserted new stuff into s1 Wha----wow----t a day sunday
Find day into string position - 18
Replacement of s2 - nice  ___station___indeed

———————————————— string operations 2 ———————— 

#include <iostream> 
#include <cstring> 
using namespace std; 
  
int main() 
{ 
    char s1[10] = "Hello"; 
  
    // return length of s1 
    cout << strlen(s1) << endl; 
  
    char s2[50]; 
  
    // copies s1 into s2 
    strcpy(s2, s1); 
    cout << s2 << endl; 
  
    char s3[10] = "World"; 
  
    // concatenates s3 into s2 
    strcat(s2, s3); 
    cout << s2 << endl; 
  
    char s4[50] = "HelloWorld"; 
  
    // return 0 if s2 and s4 are equal. 
    if (strcmp(s2, s4) == 0) 
        cout << "true" << endl; 
    else
        cout << "false" << endl; 
  
    char s5[30]; 
  
    // copies first 5 chars of s2 into s1 
    strncpy(s5, s4, 5); 
    cout << s5 << endl; 
  
    char target[10] = "Hello"; 
  
    // search for target string in s4 
    if (strstr(s4, target) != NULL) 
        cout << "true" << endl; 
    else
        cout << "false" << endl; 
  
    return 0; 
} 
———— output ———— 
5
Hello
HelloWorld
true
Hello? ?8?q??
true

——————————————CONTAINERS ——— STL - Standard Template Library —http://www.cplusplus.com/reference/stl/———————— 
The C++ STL (Standard Template Library) is a powerful set of C++ template classes to provide general-purpose classes and functions with templates that implement many popular and commonly used algorithms and data structures like vectors, lists, queues, and stacks. It has following well structured components - 
1. Container - Containers are used to manage collections of objects of a certain kind. There are several different types of containers like deque, list, vector, map etc.
2. Algorithm - Algorithms act on containers. They provide the means by which you will perform initialization, sorting, searching, and transforming of the contents of containers.
3. Iterators - Iterators are used to step through the elements of collections of objects. These collections may be containers or subsets of containers.

————————— Containers - Array ; Deque ; Forward_list , list , map, queue, set , stack ,unordered_map, unordered set ,  vector ———————— 
A container is a holder object that stores a collection of other objects (its elements). They are implemented as class templates, which allows a great flexibility in the types supported as elements. The container manages the storage space for its elements and provides member functions to access them, either directly or through iterators (reference objects with similar properties to pointers).Containers replicate structures very commonly used in programming: dynamic arrays (vector), queues (queue), stacks (stack), heaps (priority_queue), linked lists (list), trees (set), associative arrays (map). Many containers have several member functions in common, and share functionalities. stack, queue and priority_queue are implemented as container adaptors. Container adaptors are not full container classes, but classes that provide a specific interface relying on an object of one of the container classes (such as deque or list) to handle the elements. The underlying container is encapsulated in such a way that its elements are accessed by the members of the container adaptor independently of the underlying container class used.

———— Sequence Containers ———— > Array ,vector , list , deque , forward list 

————Container Adapters ————> Stack , queue , priority queue 

———— Associative Adapters ————> Set , Multiset , Map, Multimap 

————Unordered Associative Containers ————> Unordered set , unordered_multiset , unordered_map and unordered_multimap 

————Other Containers ————> bitset and Valarray 


————— 1) Vector —————— 
//https://www.codeguru.com/cpp/cpp/cpp_mfc/stl/article.php/c4027/C-Tutorial-A-Beginners-Guide-to-stdvector-Part-1.htm


Vector is a template class that is a perfect replacement for the good old C-style arrays. It is defined as follows 
#include <vector> using namespace std;
vector<T> v;  

It is a template class that will wrap an array of Ts. In this widely used notation, 'T' stands for any data type, built-in, or user-defined class. The vector will store the Ts in a contiguous memory area that it will handle for you, and let you access the individual Ts simply by writing v[0], v[1], and so on, exactly like you would do for a C-style array.


#include <vector>
#include <iostream> 
using namespace std;
int main() { 
  vector<float> values;    // we can also use values(5) and no reserve required as shown in next line below.
  values.reserve(5);      //use () to allocate memory
  int i;
  
  for(i=0; i< 5; i++ ) { 
    values[i] = i;
    cout << "Value of vector : " << values[i] << endl;  //use [] to access member of vector
  }
  return 0;
}
—————— output ———— 
Value of vector : 0
Value of vector : 1
Value of vector : 2
Value of vector : 3
Value of vector : 4

——————— Vector memory : RESERVE ———— 
Vector dynamically allocates, reallocates memory depending on elements get added and grows into it. We can also reserve memory by following syntax
  values.reserve(5); 

————— Difference between below syntax - ——— 
// snip 1:
std::vector<int> v(10);
// snip 2:
std::vector<int> v;
v.reserve(10);
— The first snippet defines a vector containing 10 integers, and initializes them with their default value (0). If we hadn't integers but some user-defined class, vector would call the default ctor 10 times and contain 10 readily constructed objects. The second snippet defines an empty vector, and then tells it to make room for 10 integers. The vector will allocate enough memory to hold at least 10 integers, but will not initialize this memory. If we had no integers, but some user-defined class, the second snippet wouldn't construct any instance of that class.

——————— Vector memory : CAPACITY and SIZE  ———— 
To find out how many elements would fit in the currently allocated storage of a vector, use the capacity() member function. To find out how many elements are currently contained by the vector, use the size() member function.  

#include <vector>
#include <iostream>
using namespace std;


int main() { 
  vector<int> vec; 
  cout << "Vector capacity : " << vec.capacity() << endl;  //Vector capacity : 3
  cout << "Vector size : " <<  vec.size() << endl;        //Vector size : 0

  vec.push_back(10);    //append an element
  vec.push_back(20);    //append an element
  vec.push_back(30);    //append an element
  vec.push_back(40);    //append an element
  cout << "Vector capacity : " << vec.capacity() << endl;  //Vector capacity : 3
  cout << "Vector size : " <<  vec.size() << endl;        //Vector size : 1

  vec.push_back(50);      //here 
  cout << "Vector capacity : " << vec.capacity() << endl;  //Vector capacity :  
  cout << "Vector size : " <<  vec.size() << endl;        //Vector size :  
  return 0;
}

 ——— output ———— 
Vector capacity : 0
Vector size : 0
Vector capacity : 4
Vector size : 4
Vector capacity : 8
Vector size : 5

See how capacity changes , it happens based on the datatype of vector, as here in this case vector in of type int, as we know size of int is 4 bytes so compiler will allocate 4 block of memory ..and when we try to add 5th element , vector::capacity() is doubled what we have currently.

————————— Using class as a data type for Vector —————— 
#include <vector>
#include <iostream>
using namespace std;

class X { 
  public : 
    void setup(int i) { 
      cout << "From class " << i << endl;
    }

}; 

int main() {
  vector<X> myvec(2);     //here vector data type is a class. X is the class data type. 
  myvec[1].setup(20) ;    //this is creating instance of class
  myvec[2].setup(40) ;     //this is creating instance of class
  return 0;
}

—————— output ———— 
From class 20
From class 40

———— ————— Simple array passing as function parameter ——————— 
#include <iostream>
using namespace std;

double getmean(int *array, size_t S) { 
    double result;
    int i;
    for ( i = 0 ; i< S; i++) { 
      result += array[I];
    }
    return result/S;
}


int main() { 

  int nums[] = { 3, 5, 2 , 6, 7, 8};
  int final;
  final = getmean(nums, 6);
  cout << " Mean value is : " << final << endl;
  return 0;
}
————— output ————— 

 Mean value is : 5
———— ————— Simple Vector passing as function parameter , replacement of array in example above ——————— 

#include <iostream>
#include <vector>

double mean(double *array, size_t n)
{
    double m=0;
    for(size_t i=0; i<n; ++i){
        m += array[i];
    }
    return m/n;
}

int main()
{
    std::vector<double> a;
    a.push_back(3);
    a.push_back(5);
    a.push_back(2);
    a.push_back(6);
    a.push_back(7);
    a.push_back(8);
    std::cout<< "Mean result using vector : " << mean(&a[0], 5)<<std::endl;    // will print 3
    return 0;
}
————— output —————— 
Mean result using vector : 4.6

——————————— Iterator —————————— 
Iterators are the way the Standard Library models a common interface for all containers—vector, list, set, deque, and so on. The reason is that operations that are "natural" for one container (like subscripting for vector) do not make sense for other containers. The Standard Library needs a common way of applying algorithms like iterating, finding, sorting to all containers—thus the concept of iterators. An iterator is a handle to a contained element. 


Understanding the second point is crucial when working with vectors or any other standard containers. The controlled sequence is always expressed in terms of [first, one-past-last)—not only for vectors, but also for every function that operates on a range of elements.

————————————— Sample program using Iterator , Pointer and normal loop counter ——————
#include <vector>
#include <iostream> 
using namespace std;

int main()
{
    vector<double> a1;
    vector<double>::const_iterator i;
    a1.push_back(1);
    a1.push_back(2);
    a1.push_back(3);
    a1.push_back(4);
    a1.push_back(5);
    for(i=a1.begin(); i!=a1.end(); ++i){          //begin() = returns an iterator that "points" to the first element in the sequence and end() returns an iterator that "points" to one-past-the-last-element in the sequence
         cout<< "Using Iterator : " << (*i)<< endl;
    } 
    vector<double> a2;
    const double *p;
    a2.push_back(1);
    a2.push_back(2);
    a2.push_back(3);
    a2.push_back(4);
    a2.push_back(5);
    for(p=&a2[0]; p!=&a2[0]+5; ++p){
        cout<< "Using pointer : "<< (*p)<<endl;
    } 
   vector<double> a3;
    int i1;
    a3.push_back(1);
    a3.push_back(2);
    a3.push_back(3);
    a3.push_back(4);
    a3.push_back(5);
    for(i1=0; i1< a3.size(); ++i1){
        cout<< "Using simple counter : " << a3[i1]<<endl;
    }
    return 0; 
}
————— output —————— 
Using Iterator : 1
Using Iterator : 2
Using Iterator : 3
Using Iterator : 4
Using Iterator : 5
Using pointer : 1
Using pointer : 2
Using pointer : 3
Using pointer : 4
Using pointer : 5
Using simple counter : 1
Using simple counter : 2
Using simple counter : 3
Using simple counter : 4
Using simple counter : 5
———————  — Types of for loops — 
for(int i=0;i<SIZE;i++){
    //do something for each iteration;
}
——————— 
vector<int> scores = {77,91,100,88,85,68,95};

for (auto it = scores.begin(); it != scores.end(); ++it){
    //do something for each iteration;
}
———————— 
for (auto& x: scores) //do something for each iteration;

——————————————— How to use List ——http://www.cplusplus.com/reference/list/list/————————— 
front() – Returns the value of the first element in the list
back() – Returns the value of the last element in the list
push_front(g) – Adds a new element ‘g’ at the beginning of the list
push_back(g) – Adds a new element ‘g’ at the end of the list
pop_front() – Removes the first element of the list, and reduces size of the list by 1
pop_back() – Removes the last element of the list, and reduces size of the list by 1
begin() – Returns an iterator pointing to the first element of the list
end() – Returns an iterator pointing to the theoretical last element which follows the last element
empty() – Returns whether the list is empty(1) or not(0)
insert() – Inserts new elements in the list before the element at a specified position
erase() – Removes a single element or a range of elements from the list
assign() – Assigns new elements to list by replacing current elements and resizes the list
remove() – Removes all the elements from the list, which are equal to given element
reverse() – Reverses the list
size() – Returns the number of elements in the list
sort() – Sorts the list in increasing order

——————— List scenario I - —————http://www.cplusplus.com/reference/list/list/list/————— 

Constructor  - 
(1) Empty container constructor (default constructor)
Constructs an empty container, with no elements.
(2) Fill constructor
Constructs a container with n elements. Each element is a copy of val.
(3) Range constructor
Constructs a container with as many elements as the range [first,last), with each element constructed from its corresponding element in that range, in the same order.
(4) Copy constructor
Constructs a container with a copy of each of the elements in x, in the same order.
(5) Move constructor - This is applicable for forward_list container. 
(6) Initializer list constructor - example this constructs a forward_list from initialize list. Example is below
#include <iostream>
#include <forward_list>
using namespace std;
int main(void) {
   auto il = {1, 2, 3, 4, 5};
   forward_list<int> fl(il);
   cout << "List contains following elements" << endl;
   for (auto it = fl.begin(); it != fl.end(); ++it)
      cout << *it << endl;
   return 0;
}



——— see all of the parameter use in example below ——— 
#include <iostream>
using namespace std;
#include <list>


int main ()
{
  // constructors used in the same order as described above:
  list<int> first;                                // empty list of ints
  list<int> second (4,300);                       // four ints with value 100
  list<int> third (second.begin(),second.end());  // iterating through second 
  list<int> fourth (third);                       // a copy of third 
 
  cout << " Dealing with fourth list " << endl;
  for(list<int>::iterator i = fourth.begin(); i != fourth.end() ; ++i) 
      cout << " Fourth list printing " << *i << endl ;
  

  // the iterator constructor can also be used to construct from arrays:
  int myints[] = {16,2,77,29};
  cout << "Size of myints array " << sizeof(myints) << endl;
  cout << "Start location of myints " << myints  << endl;  
  cout << "  End location of myints " << myints + sizeof(myints) / sizeof(int)  << endl;
  list<int> fifth (myints, myints + sizeof(myints) / sizeof(int) );

  cout << "The contents of fifth are: ";
  for (list<int>::iterator it = fifth.begin(); it != fifth.end(); it++) //here list<int> is a data type.
    cout << *it << ' ';
  cout << '\n';
  return 0;
}

————— output ————— see how we iterate a list . 
> g++ sample.c 
> ./a.out 

 Dealing with fourth list 
 Fourth list printing 300
 Fourth list printing 300
 Fourth list printing 300
 Fourth list printing 300
Size of myints array 16
Start location of myints 0x7ffcda972510
  End location of myints 0x7ffcda972520
The contents of fifth are: 16 2 77 29 

——————— list::operator= Member function ——————————— 
Copies all the elements from x into the container. The container preserves its current allocator, which is used to allocate additional storage if needed.

// assignment operator with lists
#include <iostream>
#include <list>

int main ()
{
  std::list<int> first (3);      // list of 3 zero-initialized ints
  std::list<int> second (5);     // list of 5 zero-initialized ints

  second = first;
  first = std::list<int>();

  std::cout << "Size of first: " << int (first.size()) << '\n';
  std::cout << "Size of second: " << int (second.size()) << '\n';
  return 0;
}
———— output ——— 
Size of first: 0
Size of second: 3

—————————— Assign member function - http://www.cplusplus.com/reference/list/list/insert/ ————— 
// list::assign
#include <iostream>
#include <list>

int main ()
{
  std::list<int> first;			//this is empty constructor 
  std::list<int> second;

  first.assign (7,100);                      // 7 ints with value 100, this is range constructor 

  second.assign (first.begin(),first.end()); // a copy of first , this is copy constructor 

  int myints[]={1776,7,4};
  first.assign (myints,myints+3);            // assigning from array

  std::cout << "Size of first: " << int (first.size()) << '\n';
  std::cout << "Size of second: " << int (second.size()) << '\n';
  return 0;
}
———— output ——— 
Size of first: 3
Size of second: 7

—————————— Non member function - swap ( Exchanges the contents of two lists) ———————— 
#include <list>
#include <iostream>
using namespace std;

int main() { 

  list<float> first(3,40.4);		//this is fill constructor 
  list<float> second(6, 54.5);

  first.swap(second);

  for(list<float> :: iterator i = first.begin() ; i != first.end() ; ++i) 
    cout << "First list values " << *i << endl;

  for(list<float> :: iterator j = second.begin(); j != second.end() ; j++) 
     cout << "Second list values " << *j << endl; 
  return 0;
}
———— output ———— 
First list values 54.5
First list values 54.5
First list values 54.5
First list values 54.5
First list values 54.5
First list values 54.5
Second list values 40.4
Second list values 40.4
Second list values 40.4
———All other member and non member function - http://www.cplusplus.com/reference/list/list/insert/ ————— 

————————— Deque - ———————— 
Double ended queues are sequence containers with the feature of expansion and contraction on both the ends. They are similar to vectors, but are more efficient in case of insertion and deletion of elements at the end, and also the beginning. Unlike vectors, contiguous storage allocation may not be guaranteed.

#include <deque>
#include <iostream>
using namespace std;


int main() { 
  deque<int> first;		//this is empty constructor 
  first.push_front(30);
  first.push_back(20);
  first.push_front(40);
  first.push_back(10);
  first.push_front(50);
  first.push_back(5);
  for(deque<int>:: iterator i = first.begin() ; i!= first.end() ; i++) 
    cout << "Deque values " << *i << endl;
  return 0;
}
——— output ——— 
Deque values 50
Deque values 40
Deque values 30
Deque values 20
Deque values 10
Deque values 5

———————— one more example of Deque —using pop function ———— 

#include <deque>
#include <iostream>
using namespace std;


int main() { 
  deque<int> first;		//this is empty constructor 
  first.push_front(30);
  first.push_back(20);
  first.push_front(40);
  first.push_back(10);
  first.push_front(50);
  first.push_back(5); 
  for(deque<int>:: iterator i = first.begin() ; i!= first.end() ; i++) 
    cout << "Deque values " << *i << endl;
  first.at(2);
  first.pop_front();
  first.pop_back();
  for(deque<int>:: iterator i = first.begin() ; i!= first.end() ; i++) 
    cout << "new Deque values " << *i << endl;
  return 0;
}
———— output ——— 
Deque values 50
Deque values 40
Deque values 30
Deque values 20
Deque values 10
Deque values 5
new Deque values 40
new Deque values 30
new Deque values 20
new Deque values 10

—————————— Forward_list ——————— 

forward_list container is implemented as singly linked-list, hence it provides unidirectional sequential access to it's data.forward_list doesn't provide fast random access, it only supports sequential access in only one directions. forward_list allows insertion and deletion operation anywhere within a sequence in constant time.Elements of forward_list can be scattered in different chunks of memory. Container stores necessary information to allow sequential access to it's data. forward_lists can shrink or expand as needed from both ends at run time. The storage requirement is fulfilled automatically by internal allocator. Forward list in STL implements singly linked list.It differs from list by the fact that forward list keeps track of location of only next element while list keeps track to both next and previous elements, thus increasing the storage space required to store each element. The drawback of forward list is that it cannot be iterated backwards and its individual elements cannot be accessed directly.

Definition - 
template < class T, class Alloc = allocator<T> > class forward_list;

T − Type of the element contained. T may be substituted by any other data type including user-defined type. Alloc − Type of allocator object.
By default, the allocator class template is used, which defines the simplest memory allocation model and is value-independent.

#include <forward_list>
#include <iostream>
using namespace std;


int main() { 

  forward_list<int> l1;
  l1.assign({12,31,3});   //note { } brackets here  — this is fill constructor 
 

  for(forward_list<int> :: iterator i = l1.begin() ; i != l1.end() ; i++) 
    cout << " FList using iterator loop " << *i << endl;

  for(int &a : l1)
    cout << "FList using different loop " << a << endl;
  
  return 0;
}
————— output ——— 
FList using iterator loop 12
FList using iterator loop 31
FList using iterator loop 3
FList using different loop 12
FList using different loop 31
FList using different loop 3
 
—————————— Map container ————————— 
std::map is an associative container that store elements in key-value pair.
It stores only unique keys and that too in sorted order based on its assigned sorting criteria.
As keys are in sorted order therefore searching element in map through key is very fast i.e. it takes logarithmic time.
In std::map there will be only one value attached with the every key.
std::map can be used as associative arrays.
It might be implemented using balanced binary trees.

#include <map>
#include <iostream>
#include <string>
#include <iterator>
using namespace std;


int main() { 
//map<string , string, int> mydb;  //this wil not work. it works only with string and int - 2 para
  map<string ,int> mydb;
  mydb.insert(make_pair( "Key1",  1)); 
//mydb.insert(make_pair( 1, "Key1" ));  // will not work. it is always string first and then int
//mydb.insert(make_pair( "Key1", "Private" , 1)); //will not work. it takes only 2 parameters 
  mydb.insert(make_pair( "Key2", 2));
  mydb.insert(make_pair( "Key3", 3));


  for(map<string, int> :: iterator i = mydb.begin() ; i != mydb.end() ; i++) 
    cout << "DB Values USING FOR LOOP " << i->first << " and " << i->second << endl;

  mydb["Key1"] = 5;   //this is allowed but below line is not 
  mydb.insert(make_pair("Key3", 7)).second;  //this is not allowed
  map<string,int> :: iterator j = mydb.begin();
  while (j != mydb.end()) { 
    cout << "DB Values USING WHILE LOOP " << j->first << " and " << j->second << endl;
    j++;
  }
  return 0;
}

———output ——— 
DB Values USING FOR LOOP Key1 and 1
DB Values USING FOR LOOP Key2 and 2
DB Values USING FOR LOOP Key3 and 3
DB Values USING WHILE LOOP Key1 and 5
DB Values USING WHILE LOOP Key2 and 2
DB Values USING WHILE LOOP Key3 and 3

————————— Queue ——————————— 
Queues are a type of container adaptor, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other. queues are implemented as containers adaptors, which are classes that use an encapsulated object of a specific container class as its underlying container, providing a specific set of member functions to access its elements. Elements are pushed into the "back" of the specific container and popped from its "front".The underlying container may be one of the standard container class template or some other specifically designed container class.


 
#include <iostream> 
#include <queue> 
using namespace std; 
  
int main() 
{ 
    // Empty Queue 
    queue<int> myqueue; 
    myqueue.push(0); 
    myqueue.push(1); 
    myqueue.push(2); 

    // Printing content of queue 
    while (!myqueue.empty()) { 
        cout << ' ' << myqueue.front();  //here printing starts from first element 
        myqueue.pop(); //here it is FIFO so always first element is out 
    } 
    myqueue.push(0); 
    myqueue.push(1); 
    myqueue.push(2); 
    // Printing content of queue 
    while (!myqueue.empty()) { 
        cout << ' ' << myqueue.back(); //here printing starts from last element 
        myqueue.pop(); //here it is FIFO so always first element is out 
    } 
} 
————output ——— 

 0 1 2
 2 2 2
———————————— STACK —————————— 
Stacks are a type of container adaptors with LIFO(Last In First Out) type of working, where a new element is added at one end and (top) an element is removed from that end only.

The functions associated with stack are:
empty() – Returns whether the stack is empty – Time Complexity : O(1)
size() – Returns the size of the stack – Time Complexity : O(1)
top() – Returns a reference to the top most element of the stack – Time Complexity : O(1)
push(g) – Adds the element ‘g’ at the top of the stack – Time Complexity : O(1)
pop() – Deletes the top most element of the stack – Time Complexity : O(1)

#include <iostream>
#include <stack>
using namespace std;

int main() { 

  stack<int> s;
  s.push(10);
  s.push(20);
  s.push(30);
  s.push(40);

  while(!s.empty()) { 
    cout << " Original top value " << s.top() <<endl ; //this brings the cursor reference to top most element 
    s.pop() ; //here last element 40 is poped out first so LIFO
    if (!s.empty()) { 
      cout << " New top value now" << s.top() <<endl;
    }
  }

  return 0;
}
——output —— 
 Original top value 40
 New top value now30
 Original top value 30
 New top value now20
 Original top value 20
 New top value now10
 Original top value 10
——————— ———— Unordered Map ——————————

unordered_map is an associated container that stores elements formed by combination of key value and a mapped value. The key value is used to uniquely identify the element and mapped value is the content associated with the key. Both key and value can be of any type predefined or user-defined

Internally unordered_map is implemented using Hash Table, the key provided to map are hashed into indices of hash table that is why performance of data structure depends on hash function a lot but on an average the cost of search, insert and delete from hash table is O(1)

 
#include <iostream> 
#include <unordered_map> 
using namespace std; 
  
int main() 
{ 
  //  unordered_map<int, string> umap; //here < any data type , any data type works>
    unordered_map<int, string> umap;
    
    // inserting values by using [] operator 
    umap[1] = "first"; 
    umap[2] = "second"; 
    umap[3] = "third"; 
  
    // Traversing an unordered map 
    for (auto x : umap) 
      cout << x.first << " " << x.second << endl; 
  
} 
——— output —— 

3 third
2 second
1 first

——————————— before moving to next example of unordered map , lets cover stringstream ————— 
#include <bits/stdc++.h> 
using namespace std; 
  
int countWords(string str) 
{ 
    stringstream s(str); // Used for breaking words 
    string storewordshere; // to store individual words , right  now empty
    int count = 0; 
    while (s >> storewordshere)  { //here we are reading s into string 
        cout << "Values of storewordshere " << storewordshere << endl; //printing each word
        count++; 
    }
    return count; 
} 
  
// Driver code 
int main() 
{ 
    string s = "it is possible to develop "
               "and a deploy";   //it is possible to continue string on second line
    cout << " Number of words are: " << countWords(s); 
    return 0; 
}
——output ——— 
Values of storewordshere it
Values of storewordshere is
Values of storewordshere possible
Values of storewordshere to
Values of storewordshere develop
Values of storewordshere and
Values of storewordshere a
Values of storewordshere deploy
 Number of words are: 8

——————— unordered map to count frequency of word ————— 
#include <string> 
#include <bits/stdc++.h>
#include <unordered_map>
using namespace std;

void wordfrequency(string &str) { 
  stringstream ss(str) ;
  string readhere;

  unordered_map<string, int> mycount;
  while(ss >> readhere) { 
    mycount[readhere]++;  //this is just building map db.
  }
  for(unordered_map<string, int> :: iterator i = mycount.begin() ; i != mycount.end(); i++) { 
      cout  << i->first << "  : " << i->second << endl;
  }
};

int main() { 
  string str = "therefore is development it design communit "
        "therefore it needs design is ";
  wordfrequency(str);
  return 0;
}

——— output ———  
 needs  : 1
communit  : 1
it  : 2
design  : 2
development  : 1
is  : 2
therefore  : 2

—————— Unordered Set ————————— 
unordered_set is implemented using hash table where keys are hashed into indices of this hash table so it is not possible to maintain an order. All operation on unordered_set takes constant time O(1) on an average which can go up to linear time in worst case which depends on the internally used hash function but practically they perform very well and generally provide constant time lookup operation.The unordered-set can contain key of any type – predefined or user-defined data structure but when we define key of type user define type, we need to specify our comparison function according to which keys will be compared.

set vs unordered_set
Set set is an ordered sequence of unique keys whereas unordered_set is a set in which key can be stored in any order, so unordered.
Set is implemented as balanced tree structure that is why it is possible to maintain an order between the elements (by specific tree traversal). Time complexity of set operations is O(Log n) while for unordered_set, it is O(1).

Methods on unordered_set
For unordered_set many function are defined among which most useful are size and empty for capacity, find for searching a key, insert and erase for modification.
The Unordered_set allows only unique keys, for duplicate keys unordered_multiset should be used.


#include <bits/stdc++.h> 
using namespace std; 

int main() { 
 
  unordered_set<string> stringpool;

  stringpool.insert("This");
  stringpool.insert("is"); 
  stringpool.insert("my");
  stringpool.insert("updated");
  stringpool.insert("text");
  
  string key = "what"; //"key" word is fixed.
  //find returns end iterator if key is not found, 
  //  else it returns iterator to that key 
  if (stringpool.find(key) == stringpool.end())
      cout << "Not Found " << key << endl;
  else
      cout << "Found " << key << endl;
  key = "my";
  if (stringpool.find(key) == stringpool.end())
      cout << "Not Found " << key << endl;
  else
      cout << "Found " << key << endl;

  unordered_set<string> :: iterator i ;
  for (i = stringpool.begin() ; i != stringpool.end() ; i++ ) { 
      cout << *i << endl;
  }
  return 0;
}
——— output ——— 
Not Found what
Found my
text
updated
my
is
This

———————— Finding duplicates using unordered_Set ———————— 

#include <bits/stdc++.h>  
using namespace std;

void printdup(int arr[], int i) { 
int j;
unordered_set<int> intset;
unordered_set<int> duplicates;

for(j=0 ; j< i; j++ ) { 
  if ( intset.find(arr[j]) == intset.end()) //always check if iterator reaches at the end first, else other condition
    intset.insert(arr[j]);
  else 
    duplicates.insert(arr[j]);
}
unordered_set<int> :: iterator loopcount;
for(loopcount = duplicates.begin() ; loopcount != duplicates.end() ; loopcount++) 
    cout << "Duplicates are : " << *loopcount << endl;
}

int main() { 

int arr[] = { 10, 29 , 20,10,80,29,32,80,30};
int size = sizeof(arr) / sizeof(int); 
printdup(arr , size);

  return 0;

}

————— output ——— 
Duplicates are : 80
Duplicates are : 29
Duplicates are : 10

————————— Signal Handling ——————— 
C++ signal-handling library provides function signal to trap unexpected events.

SIGABRT - Abnormal termination of the program, such as a call to abort.
SIGFPE - An erroneous arithmetic operation, such as a divide by zero or an operation resulting in overflow.
SIGILL - Detection of an illegal instruction.
SIGINT - Receipt of an interactive attention signal.
SIGSEGV - An invalid access to storage.
SIGTERM - A termination request sent to the program.


void (*signal (int sig, void (*func)(int)))(int); 

—————— Example - simple user manual interruption —————— 
#include <iostream>
#include <csignal>
#include <unistd.h>
#include <stdlib.h>
using namespace std;


void signalprocess(int signum) { 
  cout << "Signal received" << signum << endl;
  exit(signum);
}
int main() { 
  signal(SIGINT, signalprocess);
  while(1) { 
    cout << " We are sleeping right now "  << endl;
    sleep(1);
  }
  return 0;
}
——— output ——— 
 We are sleeping right now 
 We are sleeping right now 
 We are sleeping right now 
^CSignal received2

—————— Example - preconfigured system interruption using Raise—————— 
#include <iostream>
#include <csignal>

using namespace std;

void signalHandler( int signum ) {
   cout << "Interrupt signal (" << signum << ") received.\n";

   // cleanup and close up stuff here  
   // terminate program  

   exit(signum);  
}

int main () {
   int i = 0;
   // register signal SIGINT and signal handler  
   signal(SIGINT, signalHandler);  

   while(++i) {
      cout << "Going to sleep...." << endl;
      if( i == 3 ) {
         raise( SIGINT);
      }
      sleep(1);
   }

   return 0;
}

—————————— Lambda Expressions ——————————— 
 
[ captures ] (parameters) -> returnTypesDeclaration { lambdaStatements; }


[ captures ]: The capture clause, also known as the lambda introducer, specifies which outside variables are available for the lambda function and whether they should be captured by value (copying) or by reference. You will always be able to identify the start of a lambda expression with the presence of the capture clause. An empty capture clause [] means capture nothing, in which case the lambda expression body doesn't access variables in the enclosing scope.

( parameters ): This is the optional parameters list, also known as the lambda declarator. You can omit the parameters list if you want a function that takes zero arguments.

-> returnTypeDeclaration: This is the return type. Most of the time, compilers can deduce the return type of the lambda expression when you have zero or one return statement. However, if it makes it easier to understand the code, you can specify the return type.

{ lambdaStatements; }: This is the lambda body. The statements within the lambda body can access the captured variables and the parameters.


#include <iostream>
using namespace std;
int main()
  {
      auto lambda = []( int x , int y)  -> int {  return x + y; };  //here ( int x , int y) is parameters, -> int is return type and return x + y is the lambda statements.
      cout << lambda(3 ,4) << endl;
      return 0;
  }

—————————— CONSTANT  ——————————— 
A function becomes const when const keyword is used in function’s declaration. The idea of const functions is not allow them to modify the object on which they are called. It is recommended practice to make as many functions const as possible so that accidental changes to objects are avoided.


#include<iostream> 
using namespace std; 
  
class Test { 
    int value; 
public: 
    Test(int v = 0) {value = v;} 
      
    // We get compiler error if we add a line like "value = 100;" 
    // in this function. 
    int getValue() const {
    //value = 10 this wil fail , not allowed to change
    return value;
    }   
}; 
  
int main() { 
    Test t(20); 
    cout<<t.getValue(); 
    return 0; 
} 
———— Output ————— 
20 
—————————— CONST CAST  ——————————— 
#include <iostream> 
class myclass{ 
    
};
int main() { 
  const myclass *c1 = new myclass() ;
  myclass *c2 = c1;       //this is not allowed since c1 is constant
  myclass *c2 = const_cast<myclass*> (c1); //to fix above error, use casting of constant, here casting to myclass
  delete c1;
  return 0;
}

—————————— STATIC CAST ( HAPPENS AT COMPILE TIME) ——————————— 
#include <iostream>
#include <cstdlib>
using namespace std;

class B{} ;
class D : public B{};
class E : public B{};

int main() { 
  B* b1 = new D;
//E* e1 = new b1;  //this is not allowed so fix issue below
  E* e1 = static_cast<E*> (b1); //here casting b1 to e1 . this will happen at compile time
  //static means compile time
  return 0;
}

— example below where return of square root can be integer , or long or double .. if we don’t tell compiler what we need then it gives error
#include <iostream>
#include <cstdlib>
using namespace std;

int main() { 
  int i = 25;
//d = sqrt(i) //this will throw error at compile time 
  double d = sqrt(static_cast<double>(i)); 
  cout << d << endl;
  return 0;
}
—————————— DYNAMIC CAST  ( RUN TIME TYPE IDENTIFICATION ) ——————————— 
This is mainly between base and derived class. RTTI is short for Run-time Type Identification. When dealing with polymorphism, you’ll often encounter cases where you have a pointer to a base class, but you want to access some information that exists only in a derived class. RTTI is to provide a standard way for a program to determine the type of object during runtime. In other words, RTTI allows programs that use pointers or references to base classes to retrieve the actual derived types of the objects to which these pointers or references refer.

RTTI is provided through two operators:

1. The typeid operator, which returns the actual type of the object referred to by a pointer (or a reference).
2. The dynamic_cast operator, which safely converts from a pointer (or reference) to a base type to a pointer (or reference) to a derived type.

In below program, function getObject() always returns a Base pointer, but that pointer may be pointing to either a Base or a Derived object. In the case where the pointer is pointing to a Derived object, how would we call Derived::getName()?

One way would be to add a virtual function to Base called getName() (so we could call it with a Base object, and have it dynamically resolve to Derived::getName()). But what would this function return if you called it with a Base object? There isn’t really any value that makes sense.  C++ provides a casting operator named dynamic_cast that can be used for just this purpose , using a dynamic_cast to convert our Base pointer back into a Derived pointer.

#include <iostream>
#include <string>
using namespace std;

class Base {
  protected : 
    int m_value;
  public: 
    Base(int value) : m_value(value) { }
    virtual ~Base() { } //this is required when we do dynamic_cast
};

class Derived : public Base {
  protected: 
    string m_name;
  public: 
    Derived(int value, string name) : Base(value), m_name(name){ 
    cout << "From Derived constructor" << endl;
    }
    string getName() { return m_name; }
};

Base* getObject(bool bReturnDerived) { //this function wil return Derived class 
    if (bReturnDerived)
      return new Derived(1,"Alan");  //new is to get memory allocated
    else
      return new Base(2);
}

int main()  { 
  Base *b = getObject(true); //even if we get memory allocated of derived , pointer is at base class only

  Derived* d = dynamic_cast<Derived*>(b); //here pointer is now casted to Derived which will solve below issue

  cout << "Derived class getName function - " << d->getName() << '\n'; //will give error - class base has no getName
  delete b;     //release memory 
  return 0;
}

———— output —— 
From Derived constructor
Derived class getName function - Alan

The above example works because b is actually pointing to a Derived object, so converting b into a Derived pointer is successful. However, we’ve made quite a dangerous assumption: that b is pointing to a Derived object. What if b wasn’t pointing to a Derived object? This is easily tested by changing the argument to getObject() from true to false. In that case, getObject() will return a Base pointer to a Base object. When we try to dynamic_cast that to a Derived, it will fail, because the conversion can’t be made. Rule: Always ensure your dynamic casts actually succeeded by checking for a null pointer result.

—————————— DOWN CASTING WITH STATIC CAST  ——————————— 
As seen above , Dynamic cast is at runtime and it does check which class it is using for final printing cout but static cast does not do any check of the class so there will be issue if Base class isn’t pointing to Derived then program will crash. Static cast does not do any of that check thats why we have to do extra check as shown below which is not required had it been dynamic cast. In case of dynamic cast we just checked if d is not null pointer but in case of static cast we need to check if class is Derived only to proceed with cout printing statement 

#include <iostream>
#include <string>
using namespace std;

enum DB { BASE, DERIVED };
class Base { 
public:
  virtual ~Base() { }
  virtual DB getclassid() { return BASE; }
};

class Derived : public Base {  
protected:
  string m_name;
public:
  Derived(string name) : m_name(name) { }
  string getName() { return m_name; }
  virtual DB getclassid() { return DERIVED; }
};

Base* GetObject(bool bReturnclass) { 
  if(bReturnclass)
    return new Derived("Apple");
  else
    return new Base(); 
};

int main() { 
  Base* b = GetObject(true);
  if (b->getclassid() == DERIVED) { //this is required cause static cast will not check if Base is pointed to some other class
    Derived* d = static_cast<Derived*>(b); 
    cout << "Name of the derived is " << d->getName() << '\n';
  }
  
  return 0;
}
———— output ——— 
Name of the derived is Apple

—————————— DYNAMIC CAST  WITH REFERENCE——————————— 

Because C++ does not have a “null reference”, dynamic_cast can’t return a null reference upon failure. Instead, if the dynamic_cast of a reference fails, an exception of type std::bad_cast is thrown.

#include <iostream>
#include <string>
 
class Base{
protected:
	int m_value;
public:
	Base(int value)
		: m_value(value){ }
	virtual ~Base() {}
};
 
class Derived : public Base{
protected:
	std::string m_name;
public:
	Derived(int value, std::string name)
		: Base(value), m_name(name){}
 
	const std::string& getName() { return m_name; }
};
 
int main(){
	Derived apple(1, "Apple"); // create an apple
	Base &b = apple; // set base reference to object
	Derived &d = dynamic_cast<Derived&>(b); // dynamic cast using a reference instead of a pointer
	std::cout << "The name of the Derived is: " << d.getName() << '\n';  
	return 0;
}
——— output ——— 
The name of the Derived is: Apple

—————————— REINTERPRET CAST  ——————————— 
It is used to convert one pointer of another pointer of any type, no matter either the class is related to each other or not. It does not check if the pointer type and data pointed by the pointer is same or not. This is very dangerous casting, not recommended to use.


#include <iostream> 
using namespace std; 
  
int main() 
{ 
    int* p = new int(65); 
    char* ch = reinterpret_cast<char*>(p); 
    cout << *p << endl; 
    cout << *ch << endl; 
    cout << p << endl; 
    cout << ch << endl; 
    return 0; 
} 

—— output ——— 
65
A
0x2353010
A
—— class Reinterpret cast  ——— 
#include <iostream>
using namespace std;

class A { 
  public : 
    void fun_A() { 
      cout << " From Class A - Function " << endl ; }
};

class B { 
  public:
    void fun_B() { 
      cout << "From class B function " << endl; }
};

int main() { 
  A *o1 = new A(); 

  B* o2 = reinterpret_cast<B*> (o1);
  o2->fun_B();
  
  return 0;
}
—————— output ———— 
From class B function 


—————————— TYPEID ——————————— 

#include <iostream>
#include <typeinfo>
using namespace std;
class Animal{
    public:
        virtual void display(){}
};

class Cow:public Animal{};
class Dog:public Animal {};

int main(){
    Animal *anm;
    Cow cw;
    Dog dg;

    cout << "type of anm is : "<<typeid(anm).name()<<endl;
    cout << "type of cw is : "<<typeid(cw).name()<<endl;
    cout << "type of dg is : "<<typeid(dg ).name()<<endl;

    //after initializing base pointer with address of derived class object
    anm = &cw; //assigns anm with address of cw.since Animal is virtual, anm is now type of //Cow
    cout<<"type of  *anm when pointing to cw is: "<<typeid(*anm).name()<<endl;
    anm = &dg;
    cout<<"type of  *anm when pointing to dg is: "<<typeid(*anm).name()<<endl;
}
————— output ————— in below P6 , 3C etc is a internal presentation of compiler ——— 
type of anm is : P6Animal.   
type of cw is : 3Cow
type of dg is : 3Dog
type of  *anm when pointing to cw is: 3Cow
type of  *anm when pointing to dg is: 3Dog


——————————— USING VECTOR AND RANDOM FUNCTION —————— 
#include <iostream>
#include <cstdlib>
#include <vector>
using namespace std;
double randomfunction() {
    double r ;
    r = rand();
    return r;
}
vector<double> vectorfunction(int n) {
    vector<double> v;
    for(int i= 0 ; i< n; ++i) {
        v.push_back(randomfunction());
    }
    return v;
}
int main() {
    vector<double> outputvector = vectorfunction(5);
    for (int i=0; i < outputvector.size(); i++ ) {
        cout << outputvector[i] << endl;
    }
    
    return 0;
}
——— output ———— 
16807
2.82475e+08
1.62265e+09
9.84944e+08
1.14411e+09

—————————— DYNAMIC CAST and TYPEID /STATIC CAST— DEEP DIVE ——————————— 
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <typeinfo>
using namespace std;

class Shape{ 
  public:
    virtual void draw() const = 0 ;
    virtual ~Shape() { }
};

class Rect : public Shape { 
  public : 
    virtual void draw() const { cout << "Rect" << endl; }
};

class Eclipse : public Shape { 
  virtual void draw() const { cout << "Eclipse " << endl ; } 
};

//Square above is introduced only to demo dynamic cast functionality , it can then pull all rectangles and sqaures 
class Square : public Rect { 
  public:
    virtual void draw() const { cout << "Square " << endl; }
};
Shape* randomShape() { 
  switch (rand() % 3) { 
    case 0 : 
        return new Rect() ;
    case 1 : 
        return new Eclipse();
    case 2 : 
        return new Square();
    }
    return nullptr;
}

vector<Shape*> randomShapes(int num) { 
  vector<Shape*> v;
  for(int i = 0 ; i<num; ++i ) { 
      v.push_back(randomShape());
  }
  return v;
}
/*
vector<Rect*> getRects(const vector <Shape*>& all){ 
    vector<Rect*> v;
    for(int i = 0; i < all.size() ; ++i) { 
        cout << typeid(*(all[i])).name() << endl;  //if we dont dereference all[i] then we wil get P5Shape as location details in output
        if ( typeid(Rect) == typeid(*(all[i])))  { //checking typeref of Rect class matches with dereference poimnter value
            v.push_back(static_cast<Rect*> (all[i]));  //now we know it is Rect based om if condition above, 
            //we will cast this shape into Rect class. Issue here is it will not pull descendents of Rect. for that we wil
            //have to use Dynamic cast as shown below
        }
    }
    return v;
}
*/
//-------Dynamic cast ---
vector<Rect*> getRects(const vector <Shape*>& all){ 
    vector<Rect*> v;
    for(int i = 0; i < all.size() ; ++i) {  
        Rect* r = dynamic_cast<Rect*> (all[i]); //here compiler will get all descendents of Rect, including Sqaure
        if (r != nullptr) { 
          v.push_back(r);
        }
    }
    return v;
}
 
int main()  {
  vector<Shape*> all = randomShapes(40);
  vector<Rect*> rects = getRects(all);

  for(int i=0 ; i< rects.size() ; ++i) { 
    rects[i]->draw();
  }
  
  for ( int i=0; i< all.size(); ++i) { 
    delete all[i];
  }

}
———— output ——— 
Square 
Rect
Square 
Square 
Square 
Rect
Square 
Square 
Rect
Rect
Square 
Rect
Square 
Square 
Rect
Square 
——————————— REGEX - REGULAR EXPRESSION RULES ——————————— 
http://www.cplusplus.com/reference/regex/ECMAScript/

Sample program is follows
#include <iostream>
#include <string>
#include <regex>
using namespace std;

int main ()
{
    string s ("Thid is e3nd of the india of tpphe era");
    smatch m;
    regex e ("3\\w");
    while (regex_search (s,m,e)) {
        for (auto x:m) cout << x << " ";
        s = m.suffix().str();
    }
    return 0;
}

——————————— REGEX_MATCH - EXAMPLES——————————— 
 
#include <regex>
#include <iostream>
using namespace std;

int main() {
    string str;
    while(true) {
        cin >> str;
        regex e(“abc”);
        bool match = regex_match(str,e);
        cout << (match? "Matched" : "Not Matched") << endl;
    }
    return 0;
}
—— output———
Jack 
Not matched
abc
Matched 
——————————— REGEX_MATCH - CASE SENSITIVE——————————— 

        regex e(“abc”, regex_constants::icase); //icase to elimimate case sensitiveness of abc

——————————— REGEX_MATCH DOT — Match any one character only after abc except new line—so one dot then one character , two then two characters——————— 
        regex e(“abc..”);

——————————— REGEX_MATCH  ?  ZERO OR ONE PRECEDING CHARACTER MATCH—————————— 

        regex e(“abc?”);  

Here it will match either 0 or 1 c so ab and abc will match because it has 0 and 1 c there. But aabc will not match because it has extra a at the beginning 

——————————— REGEX_MATCH  *  ZERO OR MORE PRECEDING CHARACTER MATCH—————————— 

        regex e("abc*”) . This will match  for ab , abc , abccc but not for aabc because there is extra a at the front. 

——————————— REGEX_MATCH  +  ONE OR MORE PRECEDING CHARACTER MATCH—————————— 
        regex e("abc+”)      So ab will not match because c is 0 but abc , abccc will match because c is one or more.


————— REGEX_MATCH  [ ] *   ZERO OR MORE PRECEDING CHARACTER MATCH , IN THIS CASE PRECEDING CHARACTER IS WHATEVER IS IN BRACKET—————— 

regex e("ab[cd]*") = This will match ab , abc , abcd , abcccdd . So match will happen on either c or d

————— REGEX_MATCH  [ ] {x} *   EXACT X TIMES MATCH OF PRECEDING CHARACTER MATCH  ——— 
regex e("ab[cd]{3}*”) = This will match abccc , abddd , abcdc  . So match will happen on either c or d or both exact 3 counts.


————— REGEX_MATCH  [ ] {x , } *   MATCH X OR MORE OF PRECEDING CHARACTER MATCH  ——— 

regex e("ab[cd]{3 , }*”)    here abcdcdddd , abcccc , abcdcdcdc is matched but not ab , abcd 

————— REGEX_MATCH  [ ] {3, 5 } *   MATCH FROM 3 TILL 5 OF PRECEDING CHARACTER MATCH  ——— 

————— REGEX_MATCH  [^ ] *   ANY CHARACTER NOT INSIDE THE SQUARE BRACKET , opposite of above expression 

        regex e("ab[^cd]*”)  so abc , abd , accccdd all this not matched but ab , abe, abeeee is all matches 


——————————— REGEX_MATCH  |  - This is OR operator —————————— 

	regex e(“abc | de[fg]” ) — This means either abc or de[fg] match  so abc , def , deg , defg all match but not abcdefg 
	regex e(“abc | de[ \ ] fg ]” ) — This will match abc or de[f] or de[g] or de[fg] . Here we are matching square bracket too

——————————— REGEX_MATCH  ( ) GROUPS AND SEQUENCE—————————


        regex e("(abc)de+\\1");     This means group is abc so match abcdeeabc meaning first group abc then dee with one e for + and then sequence of first group which is abc 
        regex e("(abc)c(de+)\\2\\1”);   Here we have two groups abc and de+ and then sequence at the end which 2nd group and then 1st group so match should be abccdeedeeabc


——————————— REGEX_MATCH  [:  : ] WORD CHARACTERS—————————

	        regex e("[[:w]]+@[[:w]]+\.com");  This means [[:w]:] word character so here more than one word character due to + so number of word then @ then number of words again and then escape . and at last match for com . allangon@gmail.com will be valid match here

—— CHARACTER CLASSES  —— —
[[:alpha:]] = This is equivalent to [a-zA-Z] 

[[:alnum:]] = Any letter or digit 

[[:blank:]] = Space or a tab character 


[:cntrl:] = Any control character. (These are not printable.)

[:digit:] = Any decimal digit.

[:graph:] = Any printable character that is not a whitespace.

[:lower:] = Any lowercase letter.

[:print:] = Any printable character, including whitespaces.

[:punct:] = Any punctuation character.

[:space:] = A whitespace character, such as a blank space, tab, or newline.

[:upper:] = Any uppercase letter.

 [:xdigit:] = A hexadecimal digit: This includes digits, as well as uppercase and lowercase letters.


——————————— REGEX_SEARCH—————————

regex_match(str , e) and regex_search(str, e) is in case of search it will try to see if e exists into str. 
        regex e("abc."); 
        bool found = regex_search(str,e);    here not just abce is found but also aaaaabce or aaaabcexxxxsss is also found because here we are searching abce into long string this will not match if we use regex_match because of extra aaaa or more xx character at the front and at end but not same in case of regex_search

——————————— REGEX_SEARCH ^ FOUND BEGINNING OF THE WORD—————————

        regex e("^abc"); 
        bool found = regex_search(str,e);  here abce , abcdsdsdsd is found since abc at the beginning but not found in case of sdsdsdsabc 

——————————— REGEX_SEARCH $ FOUND END OF THE WORD—————————

        regex e("abc$"); 
        bool found = regex_search(str,e);   Here asassaabc , xxabc is match since abc is at the end but not abcsdsds or sdsdabcsdsd is not found.

—— MATCHING CHARACTERS ——

“.”  = This will match all the single characters except for newline 

[+*/-]  = This will match any one of the character from the string.. same rule for + or * or / or - 
[ ch+ ] = example, in this case it will match C and/or H from the string . This is same as [ ch* ] , [ ch/] , [ch-]

\\w = Matches any digit or letter or underscore . Example “_\\w” will show _n from the input string e_nd 
\\W = This is exact opposite of \\w so this will not show what matches digit or letter or underscore 
\\n = This \n will match new line 
\\s = This matches white space
\\S = This will match character other than white space 
\\t =  This \t matches a tab 

\\f = Matches a form feed
\\r = Matches a carriage return 
\\v = Matches vertical tab
\\xF5 = This \x will match hexadecimal code F5 .. 
\\u02f3 = This \u matches unicode character 02f3 
\\d = This \d matches digits and display entire number before that matched digit
“\\d2” = This will display one front digit like 42 and 82 if we are passing 420 and 8277 into input string.
If we do “\\d2\\d” then will print one digit of front and back side of number which will be 420 and 827

——  WORDS ——
/b matches the word boundary. As shown below , following string matches any word beginning with “C” and ending with “t”, such as “cat” or “containment”. It does not match “caution”

“\\bC[a-zA-Z]*t\\b”

/B - This is not a word boundary. It matches word embedded into the main word but not if it is a standalone word . Following pattern matches a portion of a word beginning with “a.” It will match “at” embedded in “cat”, but it will not match “at” if it occurs as a stand-alone word.

——  LINE ——
^  = This will work only if line starts with this word “He”

^ He

$ = End of the line matcher 

“era$” = This will match only if statement ends with era word 


——  INDIVIDUAL CHARACTERS——
[ abc ] = Matches individual character a or b or c 
[^ abc] = Everything that does not match a or b or c

—— RANGES ——
[3-5] = Matches any digits from 3 to 5 .. even if we have 53 in search string, it will list it without worrying of the sequence of the digits 
[^3-5] = This means exclude 3 to 5

——  PATTERN MODIFIERS ——
[0-9] *  = This matches zero or more instances  

[0-3]+ = This matches one or more instances 

(ab) | ( bb) = Match either ab or bb and not both together like abbb

A{2} = Matches exactly 2 occurrence of capital A 
A{ 2, 5} = Matches more than 2 but less than 5 occurrence of capital A 

A{ 2, } = Matches three or more occurrence of capital A 

(ABC){3} = Matches capital ABC three occurrence . This is same as A{3} 



—— ASSERTION  —— — ^ $ \b \B ( ? = Disjunction ) ( ? ! Disjunction ) 


——————— ———— Posix thread—————————— 

POSIX Threads, or Pthreads, is a POSIX standard for threads. Use pthread.h header file and add -lpthread during execution of the program. main() program is a single, default thread. All other threads must be explicitly created by the programmer.
1. Thread management - create, detach , join. Joinable, etc 
2. Mutexes - synchronization, locking , unlocking etc 
3. Condition variables - communication between threads that share mutex
4. Synchronisation - routines that manage read/write locks and barriers.


pthread_create (pthread_t *thread,        // pointer to pthread_t structure . When a thread is created, an identifier is written to the memory location to which this variable points. This identifier enables us to refer to the thread.

			 pthread_attr_t *attr,    // An attribute object that may be used to set thread attributes.
			 void *(*start_routine)(void *),   // The routine that the thread will execute once it is created. We should pass the address of a function taking a pointer to void as a parameter and the function will return a pointer to void. So, we can pass any type of single argument and return a pointer to any type. 
			 void *arg)    // A single argument that may be passed to start_routine. It must be passed as a void pointer 

—————— Simple Thread Management Example - ———— 

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

void *worker_thread(void *arg)
{
       printf("This is worker_thread()\n");
       pthread_exit(NULL);
}

int main()
{
       pthread_t my_thread; 

       printf("In main: creating thread\n");
       pthread_create(&my_thread, NULL, &worker_thread,  NULL);

       pthread_exit(NULL);
}
————— output ———— 
In main: creating thread
This is worker_thread()

———————————————— Multi-threading —————————————— 

How to compile program - 
g++ –std=c++11 sample.cpp -lpthread

In every C++ application there is one default main thread i.e. main() function. In C++ 11 we can create additional threads by creating objects of std::thread class.
Each of the std::thread object can be associated with a thread.

We can attach a callback with the std::thread object, that will be executed when this new thread starts. These callbacks can be,

1.) Function Pointer
2.) Function Objects
3.) Lambda functions


After defining callable, pass it to the constructor.

import<thread> 
std::thread thread_object(callable) 

1) Callable Function Pointer = 
void foo(param) 
{ 
	// Do something 
} 

// The parameters to the function are put after the comma 
std::thread thread_obj(foo, params); 

2) Callable Function Object  = 
// Define the class of function object 
class fn_object_class { 
    // Overload () operator 
    void operator()(params) 
    { 
        // Do Something 
    } 
} 
  
// Create thread object 
std::thread thread_object(fn_class_object(), params) 

3) Callable Lambda Expression = 
// Define a lamda expression 
auto f = [](params) { 
	// Do Something 
}; 

// Pass f and its parameters to thread 
// object constructor as 
std::thread thread_object(f, params); 

—————————— CALLABLE - FUNCTION POINTER ———————————— 
#include <thread>
#include <iostream>
using namespace std;

void threadfunction() { 
  for (int i = 0 ; i <10000 ;  i++) { 
    cout << " thread is running , wait" << endl;
  }
}

int main() { 
  thread mythreadprocess(threadfunction) ;			// HERE it is not passing () of the function 
  mythreadprocess.join();   //this will wait till thread gets finished
  cout << "Now print this at the end" << endl;
  return 0;
}

———— output ——— 
> g++ sample.cpp -lpthread -std=c++11
> ./a.out 
 thread is running , wait
 thread is running , wait
 thread is running , wait
 thread is running , wait
 thread is running , wait
 thread is running , wait
 thread is running , wait
Now print this at the end
—————————— CALLABLE - FUNCTION OBJECT ———————————— 
#include <thread>
#include <iostream>
using namespace std;

class classthread {
public : 
  void operator()() {   //here operator () () is required syntax 
    for(int i=0; i < 1000 ;  i++) {
      cout << "Function object thread is running " << endl;
    }
  }
}; 

int main() { 
  thread mythread((classthread()) ); //see how many brackets of mythread((())) is the syntax
  mythread.join();
  cout << "function object thread just got finished " << endl;
  return 0;
}
———— output ——— 
Function object thread is running 
Function object thread is running 
Function object thread is running 
function object thread just got finished 


—————————— CALLABLE - LAMBDA FUNCTION ———————————— 

#include <iostream>
#include <thread>
int main()  
{
    int x = 9;
    std::thread threadObj([]{   //this will start the thread once object created 
            for(int i = 0; i < 10000; i++)
                std::cout<<"... Thread running....."<<std::endl;
            });
            
    for(int i = 0; i < 10000; i++)
        std::cout<<"Display From Main Thread"<<std::endl;
        
    threadObj.join();     //wait till threadObj gets finished 
    std::cout<<"Exiting from Main Thread"<<std::endl;
    return 0;
}
—————output ——— 
Display From Main Thread
Display From Main Thread
Display From Main Thread
Display From Main Thread
Display From Main Thread
Display From Main Thread
Display From Main Thread
Exiting from Main Thread

——————————— THREAD ID ———————————— 

Each of the std::thread object has an associated ID and we can fetch using,
std::thread::get_id()
std::this_thread::get_id()

——————————— RUNNING SEVERAL THREAD TOGETHER ———————————— 
#include <iostream>
#include <thread>
#include <vector>
#include <algorithm>
using namespace std;

class threadclass { 
public:
  void operator() () { 
    cout << "... thread is running with id " << this_thread::get_id() << endl;
  }
};

 int main() { 

  vector <thread> stack;
  for ( int i=0; i< 10 ; i++ ) { 
    stack.push_back(thread (threadclass()));
  }

  for_each(stack.begin() , stack.end() , mem_fn(&thread::join));
  cout << " Now all threads are completed " << endl;
  
  return 0;
 }

——— —— output ———— 
... thread is running with id 140667450963712
... thread is running with id 140667442571008
... thread is running with id 140667434178304
... thread is running with id 140667417392896
... thread is running with id 140667425785600
 Now all threads are completed 

——————————— DETACHING THREAD ( DAEMON OR BACKGROUND THREAD) ———————————— 

Case 1: Never call join() or detach() on std::thread object with no associated executing thread


 if(threadObj.joinable())
    {
        std::cout<<"Detaching Thread "<<std::endl;
        threadObj.detach();
    }

Case 2 : Never forget to call either join or detach on a std::thread object with associated executing thread 
#include <thread>
#include <algorithm>
class WorkerThread
{
public:
    void operator()()     
    {
        std::cout<<"Worker Thread "<<std::endl;
    }
};
int main()  
{
    std::thread threadObj( (WorkerThread()) );
    // Program will terminate as we have't called either join or detach with the std::thread object.
    // Hence std::thread's object destructor will terminate the program
    return 0;
}

———————————  RESOURCE ACQUISITION IS INITIALISATION   (RAII) —EXCEPTION SAFETY ——————————— 
Case 3 - Similarly we should not forget call either join() or detach() in case of exceptions. To prevents with we should use RESOURCE ACQUISITION IS INITIALIZATION (RAII) i.e.

https://www.tomdalling.com/blog/software-design/resource-acquisition-is-initialisation-raii-explained/


——————————— PASSING ARGUMENTS TO THREAD—————————— 
#include <iostream>
#include <string>
#include <thread>
using namespace std;

void threadCallback(int x, string str)
{
    cout<<"Passed Number = "<<x<<endl;
    cout<<"Passed String = "<<str<<endl;
}
int main()  
{
    int x = 10;
    string str = "Sample String";
    thread threadObj(threadCallback, x, str);  //see how name , parameters passed into same bracket
    threadObj.join();
    return 0;
}
————— output —————— 
Passed Number = 10
Passed String = Sample String

——————————— HOW NOT TO PASS ARGUMENTS TO THREAD—————————— 
Don’t pass addresses of variables from local stack to thread’s callback function. Because it might be possible that local variable in Thread 1 goes out of scope but Thread 2 is still trying to access it through it’s address.

#include <iostream>
#include <thread>
using namespace std;

void thread1(int * p)
{
    cout<<"because of &i , this is still been used in thread "" : p = "<<p<<endl;
    chrono::milliseconds dura( 1000 );
    this_thread::sleep_for( dura );
    *p = 19;
}
void functioncall()
{
    int i = 10;
    cout<<"Starting Thread :  "" : i = "<<i<<endl;
    thread t(thread1,&i);
    t.detach();
    cout<<"Thread is detached :  "" : i = "<<i<<endl;
}
int main()
{
    functioncall();
    chrono::milliseconds dura( 2000 );
    this_thread::sleep_for( dura );
    return 0;
}
——————— output ————— 
Starting Thread :   : i = 10
Thread is detached :   : i = 10
because of &i , this is still been used in thread  : p = 0x7ffd6035d7a4


——————————— HOW NOT TO PASS POINTER TO THREAD—————————— 
Similarly be careful while passing pointer to memory located on heap to thread. Because it might be possible that some thread deletes that memory before new thread tries to access it.
In such scenario accessing invalid address can cause unexpected behaviour.

#include <iostream>
#include <thread>
using namespace std;

void newThreadCallback(int * p)
{
    cout<<"Thread is still accessing pointer:  "" : p = "<<p<<endl;
    chrono::milliseconds dura( 1000 );
    this_thread::sleep_for( dura );
    *p = 19;
}
void functioncall()
{
    int * p = new int();
    *p = 10;
    cout<<"Starting Thread :  "" : *p = "<<*p<<endl;
    thread t(newThreadCallback,p);
    t.detach();
    delete p;
    p = NULL;
    cout<<"Pointer deleted and nullified " <<endl;
}
int main()
{
    functioncall();
    chrono::milliseconds dura( 2000 );
    this_thread::sleep_for( dura );
    return 0;
}
————— output ———— 

Starting Thread :   : *p = 10
Pointer deleted and nullified 
Thread is still accessing pointer:   : p = 0xcb4010


———————————HOW TO PASS REFERENCE TO THREAD——————————— 
If we pass address of x and then increment y , it still shows old value of x . 
#include <iostream>
#include <thread>
void threadCallback(int const & x)
{ 
    int & y = const_cast<int &>(x);
    y++;
    std::cout<<"Inside Thread x = "<<x<<std::endl;
}
int main()
{
    int x = 9;
    std::cout<<"In Main Thread : Before Thread Start x = "<<x<<std::endl;
    std::thread threadObj(threadCallback, x);
    threadObj.join();
    std::cout<<"In Main Thread : After Thread Joins x = "<<x<<std::endl;
    return 0;
}

——— output ——— 
In Main Thread : Before Thread Start x = 9
Inside Thread x = 10
In Main Thread : After Thread Joins x = 9
————— so we will have to use ref keyword to fix this issue —as follows —————— 
#include <iostream>
#include <thread>
void threadCallback(int const & x)
{ 
    int & y = const_cast<int &>(x);
    y++;
    std::cout<<"Inside Thread x = "<<x<<std::endl;
}
int main()
{
    int x = 9;
    std::cout<<"In Main Thread : Before Thread Start x = "<<x<<std::endl;
    std::thread threadObj(threadCallback, std::ref(x)) ;
    threadObj.join();
    std::cout<<"In Main Thread : After Thread Joins x = "<<x<<std::endl;
    return 0;
}
———— output ———— 
In Main Thread : Before Thread Start x = 9
Inside Thread x = 10
In Main Thread : After Thread Joins x = 10
—————————————— ASSIGNING POINTER TO MEMBER FUNCTION OF A CLASS AS THREAD FUNCTION —————————— 
#include <iostream>
#include <thread>
class DummyClass {
public:
    DummyClass()
    {}
    DummyClass(const DummyClass & obj)
    {}
    void sampleMemberFunction(int x)
    {
        std::cout<<"Inside sampleMemberFunction "<<x<<std::endl;
    }
};
int main() {
 
    DummyClass dummyObj;
    int x = 10;
    std::thread threadObj(&DummyClass::sampleMemberFunction,&dummyObj, x); // here we are accessing sampleMemberFunction of class &DummyClass and &dummyObj is object of that class.
    threadObj.join();
    return 0;
}

——— output ——— 
Inside sampleMemberFunction 10

————————————— DATA SHARING AND RACE CONDITIONS —————————— 
Race condition is a kind of a bug that occurs in multithreaded applications. When two or more threads perform a set of operations in parallel, that access the same memory location.  Also, one or more thread out of them modifies the data in that memory location, then this can lead to an unexpected results some times . This is called Race condition .

—— Class WALLET ————— Let’s Create a Wallet class that internally maintains money and provides a service/function i.e. addMoney(). This member function increments the internal money of wallet object by specified count.

class Wallet
{
    int mMoney;
public:
    Wallet() :mMoney(0){}
    int getMoney() { return mMoney; }
    void addMoney(int money)
    {
       for(int i = 0; i < money; ++i)
       {
          mMoney++;
       }
    }
};


—————————————— MUTEX LOCK——————————— — 
Now Let’s create 5 threads and all these threads will share a same object of class Wallet and add 1000 to internal money using it’s addMoney() member function in parallel.
So, if initially money in wallet is 0. Then after completion of all thread’s execution money in Wallet should be 5000.But, as all threads are modifying the shared data at same time, it might be possible that in some scenarios money in wallet at end will be much lesser than 5000.


#include <iostream>
#include <string>
#include <thread>
#include <vector>
#include <mutex>
using namespace std;

class Wallet{ 
    int mMoney;
    std::mutex mutex;
  public: 
      Wallet() : mMoney(0) { }    //constructor
      int getMoney() { return mMoney;}
      void addMoney(int money) { 
          mutex.lock() ;    //this is to lock
          for ( int i =0 ; i< money ; ++i) { 
            mMoney++;
          }  
          mutex.unlock();
      }
};

int functioncall() { 
  Wallet w1;
  vector<thread> v1;

  for(int i=0; i< 5; ++i) {
    v1.push_back(thread(&Wallet::addMoney, &w1, 1000));
  }
  for(int i=0; i< v1.size(); i++)  { 
      v1.at(i).join();
  } 
  return w1.getMoney();
}

int main() { 
  int val = 0;
  for(int somecounter=0 ; somecounter < 2000; somecounter++) { 
    if ((val = functioncall()) != 5000) { 
        cout << "counter at " << somecounter << " Money reached at " << val << endl;
    }
  }
  return 0;
}
———— output————— 
counter at 1922 Money reached at 4118
counter at 1931 Money reached at 4000
counter at 1933 Money reached at 4654
counter at 1939 Money reached at 4643
counter at 1946 Money reached at 4743
counter at 1958 Money reached at 4600
counter at 1964 Money reached at 4760
counter at 1969 Money reached at 4724
counter at 1971 Money reached at 4579
counter at 1973 Money reached at 4057
counter at 1975 Money reached at 4063
counter at 1979 Money reached at 4616
counter at 1996 Money reached at 4782

———— We can use below guard just in case we forgot to use unlock() 

std::lock_guard<std::mutex> lockGuard(mutex);

—————————————— EVENT HANDLING IN THREAD—————————— — 
Sometimes a thread needs to wait for an event to happen like a condition to become true or a task to be completed by another thread. Suppose we are building a network based application. This application does following tasks,

1. Perform some handshaking with server
2. Load Data from XML files.
3. Do processing on data loaded from XML.

As we can see that Task 1 is not dependent on any other Tasks but Task 3 is dependent on Task 2. So, it means Task 1 and Task 2 can be run in parallel by different Threads to improve the performance of application. Now, it includes two threads,

Responsibilities of Thread 1 are ———
Perform some handshaking with server.
Wait for data to be loaded from XML by Thread 2
Do processing on data loaded from XML.

Responsibilities of Thread 2 are ———— 
Load data from XML
Notify another Thread i.e. waiting for the message.



#include <iostream>
#include <thread>
#include <string>
using namespace std;

class executeclass{
    std::mutex m_mutex;
public:
    bool globaltrigger;
    executeclass(){ globaltrigger = false;};
    void loaddata(){
        this_thread::sleep_for(chrono::nanoseconds (1000));
        lock_guard<mutex> guard(m_mutex);
        cout << "Loading data now" << endl;
        globaltrigger = true;
    }
    
    void connectserver(){
        cout << " Connect to server " << endl;
        m_mutex.lock();
        while(globaltrigger != true) {
            m_mutex.unlock();
            this_thread::sleep_for(chrono::nanoseconds (100));
            m_mutex.lock();
        }
        m_mutex.unlock();
        cout << "Process completed " << endl;
    }
};


int main() {
    executeclass c1;
    thread t1(&executeclass::connectserver, &c1);
    thread t2(&executeclass::loaddata, &c1);
    t2.join();
    t1.join();
    
    return 0;
}
———— output ————— 
Connect to server 
Loading data now
Process completed 

Above code has below disadvantages. Thread will keep on acquiring the lock and release it just to check the value, therefore it will consume CPU cycles and will also make Thread 1 slow, because it needs to acquire same lock to update the bool flag. We can achieve this using Condition Variables. Condition Variable is a kind Event used for signaling between 2 threads. One thread can wait for it to get signaled, while other thread can signal this.

—————————————— EVENT HANDLING IN THREAD USING CONDITION VARIABLES —————————— — 
#include <iostream>
#include <thread>
#include <string>
#include <functional>
#include <mutex>
#include <condition_variable>
using namespace std;

class cardapp{
public:
    bool oksignal;
    mutex m_mutex;
    condition_variable cv;
    cardapp() { oksignal = false;};
    bool setcardfixflag() {
            return oksignal;
    }
    void fixcardreader() {
            cout << "We are fixing cardreader , wait for 1 sec" << endl;
            this_thread::sleep_for( chrono::nanoseconds (1000));
            lock_guard<std::mutex> lck1(m_mutex); //lock till 1000 milisecond over
            oksignal = true;  //set the signal;
            cv.notify_one(); //now notify swapcard thread
    }
    void swapcard() {
            unique_lock<std::mutex> lck2 (m_mutex); //lock thread till wait condition satisfy
            cv.wait(lck2, bind(&cardapp::setcardfixflag, this)); //check if oksignal is true
            cout << "Cardreader is fixed, now folks can swape cards ?" << oksignal << endl;
    }
};

int main() {
    cardapp c1;
    thread t1(&cardapp::swapcard, &c1);
    thread t2(&cardapp::fixcardreader, &c1);
    t1.join();
    t2.join();
    return 0;
}

——— output ———— 
We are fixing cardreader , wait for 1 sec
Cardreader is fixed, now folks can swape cards ?1

—————————————— FUTURE AND PROMISE —————————— — 

Above example had method setcardfixflag which was returning bool value however how about using another thread to return that value. 

#include <thread>
#include <future>
#include <iostream>
using namespace std;

void initilizer(promise<int> *promobj) {     //this thread will return value
    cout << "Inside thread now " << endl;
    promobj->set_value(200);
}

int main() {
    promise<int> promiseObj;
    future<int> futureObj = promiseObj.get_future();
    thread t1(initilizer, &promiseObj);
    t1.join();
    cout << "Value set is " << futureObj.get() << endl;
    return 0;
}
————— output ———— 
Inside thread now 
Value set is 200

——————————————ASYNC TUTORIAL —————————— — 
std::async() is a function template that accepts a callback(i.e. function or function object) as an argument and potentially executes them asynchronously. Suppose we have to fetch some data (string) from DB and some from files in file-system. Then I need to merge both the strings and print.

We can pass any callback in std::async i.e.

Function Pointer
Function Object
Lambda Function





——————————— Use of MEM_FN —BIG WRAPPER——————————— 
#include <functional>
#include <iostream>
#include <string>
using namespace std;

struct Foo{ 
  void display_name() { 
      cout << "Name is Allan" << endl;
  }
  void display_id(int i) { 
      cout << "ID is " << i << endl;
  }

  int result = 200;
};

int main() { 
  Foo F;
  auto wrapper1 = mem_fn(&Foo::display_name) ; //here mem_fn is pointed to address and function
  wrapper1(F);              //here we are pointing wrapper to object and parameters
  auto wrapper2 = mem_fn(&Foo::display_id); //auto means derive data type of wrapper word automatically based on its value
  wrapper2(F, 90);
  auto wrapper3 = mem_fn(&Foo::result) ;
  cout << "Result is " << wrapper3(F) << endl;

  return 0;
}

——— output ——— 
Name is Allan
ID is 90
Result is 200




——————— ———— CGI - Web programming —————————— 
Before you proceed with CGI Programming, make sure that your Web Server supports CGI and it is configured to handle CGI Programs. All the CGI Programs to be executed by the HTTP server are kept in a pre-configured directory. This directory is called CGI Directory and by convention it is named as /var/www/cgi-bin. By convention, CGI files have extension as. cgi, but you can keep your files with python extension .py as well.To understand the concept of CGI, let's see what happens when we click a hyperlink to browse a particular web page or URL.Your browser contacts the HTTP web server and demand for the URL ie. filename.

Web Server will parse the URL and will look for the filename. If it finds requested file then web server sends that file back to the browser otherwise sends an error message indicating that you have requested a wrong file.Web browser takes response from web server and displays either the received file or error message based on the received response.However, it is possible to set up the HTTP server in such a way that whenever a file in a certain directory is requested, that file is not sent back; instead it is executed as a program, and produced output from the program is sent back to your browser to display.

The Common Gateway Interface (CGI) is a standard protocol for enabling applications (called CGI programs or CGI scripts) to interact with Web servers and with clients. These CGI programs can be a written in Python, PERL, Shell, C or C++ etc.

Web client <—> web server —> server side scripting —> database

//https://franklingu.github.io/programming/2015/12/21/C++-CGI-setup-on-CentOS/

There are basically 2 choices for setting up web server to serve CGI scripts. Apache and httpd support execution of CGI scripts by default and you can just simply enable “+ExecCGI” option. Or you can try Nginx, which does not support CGI execution but supports FastCGI. So in this tutorial we will be exploring the easier option and we will be install htttpd to server CGI scripts.

—————————— include libraries —————— download those files from ———— https://github.com/JackieXie168/cgicc/tree/master/cgicc
All library .h files can be loaded at /var/www/cgi-bin/ folder and then refer to those as follows - 
#include </var/www/cgi-bin/CgiDefs.h>  


——————— Install httpd and then navigate to /var/www/cgi-bin and place below code there in a .cpp file 
#include <iostream>
using namespace std;

int main () {
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>Hello World - First CGI Program</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<h2>Hello World! This is my first CGI program</h2>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
———— To execute above code , use  g++ -o < name of the file>.cgi <name of the file>.cpp 
Example g++ -o start.cgi start.cpp -lcgicc
————— curl localhost/cgi-bin/start.cgi

The line Content-type:text/html\r\n\r\n is a part of HTTP header, which is sent to the browser to understand the content type to be displayed on the browser. 
—————— Headers————————— 
Content-type:  = A MIME string defining the format of the file being returned. Example is Content-type:text/html
Expires: Date = The date the information becomes invalid. This should be used by the browser to decide when a page needs to be refreshed
Location: URL = The URL that should be returned instead of the URL requested. You can use this filed to redirect a request to any file.
Content-length: N  = The length, in bytes, of the data being returned. The browser uses this value to report the estimated download time for a file.
Set-Cookie: String = Set the cookie passed through the string.

 —————— Cgi Environmental variables - 

All the CGI program will have access to the following environment variables. 
CONTENT_TYPE
CONTENT_LENGTH = The length of the query information that is available only for POST requests.
HTTP_COOKIE = Returns the set cookies in the form of key & value pair.
HTTP_USER_AGENT = The User-Agent request-header field contains information about the user agent originating the request. It is a name of the web browser.
PATH_INFO = The path for the CGI script.
QUERY_STRING = The URL-encoded information that is sent with GET method request.
REMOTE_ADDR = The IP address of the remote host making the request. This can be useful for logging or for authentication purpose
REMOTE_HOST = The fully qualified name of the host making the request. If this information is not available then REMOTE_ADDR can be used to get IR address.
REQUEST_METHOD = The method used to make the request. The most common methods are GET and POST.
SCRIPT_FILENAME = The full path to the CGI script.
SCRIPT_NAME = The name of the CGI script.
SERVER_NAME = The server's hostname or IP Address.
SERVER_SOFTWARE = The name and version of the software the server is running.

———— List all CGI variables /// https://andres.jaimes.net/811/how-to-install-a-fcgi-nginx-in-centos-6/— —— 
#include <iostream>
#include <stdlib.h>
using namespace std;

const string ENV[ 24 ] = {
   "COMSPEC", "DOCUMENT_ROOT", "GATEWAY_INTERFACE",   
   "HTTP_ACCEPT", "HTTP_ACCEPT_ENCODING",             
   "HTTP_ACCEPT_LANGUAGE", "HTTP_CONNECTION",         
   "HTTP_HOST", "HTTP_USER_AGENT", "PATH",            
   "QUERY_STRING", "REMOTE_ADDR", "REMOTE_PORT",      
   "REQUEST_METHOD", "REQUEST_URI", "SCRIPT_FILENAME",
   "SCRIPT_NAME", "SERVER_ADDR", "SERVER_ADMIN",      
   "SERVER_NAME","SERVER_PORT","SERVER_PROTOCOL",     
   "SERVER_SIGNATURE","SERVER_SOFTWARE" };   

int main () {
   cout << "Content-type:text/html\r\n\r\n";
   cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>CGI Environment Variables</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<table border = \"0\" cellspacing = \"2\">";

   for ( int i = 0; i < 24; i++ ) {
      cout << "<tr><td>" << ENV[ i ] << "</td><td>";
      
      // attempt to retrieve value of environment variable
      char *value = getenv( ENV[ i ].c_str() );  
      if ( value != 0 ) {
         cout << value;                                 
      } else {
         cout << "Environment variable does not exist.";
      }
      cout << "</td></tr>\n";
   }
   
   cout << "</table><\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}

———— output ——— 
<html>
<head>
<title>CGI Environment Variables</title>
</head>
<body>
<table border = "0" cellspacing = "2"><tr><td>COMSPEC</td><td>Environment variable does not exist.</td></tr>
<tr><td>DOCUMENT_ROOT</td><td>/var/www/html</td></tr>
<tr><td>GATEWAY_INTERFACE</td><td>CGI/1.1</td></tr>
<tr><td>HTTP_ACCEPT</td><td>*/*</td></tr>
<tr><td>HTTP_ACCEPT_ENCODING</td><td>Environment variable does not exist.</td></tr>
<tr><td>HTTP_ACCEPT_LANGUAGE</td><td>Environment variable does not exist.</td></tr>
<tr><td>HTTP_CONNECTION</td><td>Environment variable does not exist.</td></tr>
<tr><td>HTTP_HOST</td><td>localhost</td></tr>
<tr><td>HTTP_USER_AGENT</td><td>curl/7.56.0</td></tr>
<tr><td>PATH</td><td>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin</td></tr>
<tr><td>QUERY_STRING</td><td></td></tr>
<tr><td>REMOTE_ADDR</td><td>::1</td></tr>
<tr><td>REMOTE_PORT</td><td>46688</td></tr>
<tr><td>REQUEST_METHOD</td><td>GET</td></tr>
<tr><td>REQUEST_URI</td><td>/cgi-bin/cgisample.cgi</td></tr>
<tr><td>SCRIPT_FILENAME</td><td>/var/www/cgi-bin/cgisample.cgi</td></tr>
<tr><td>SCRIPT_NAME</td><td>/cgi-bin/cgisample.cgi</td></tr>
<tr><td>SERVER_ADDR</td><td>::1</td></tr>
<tr><td>SERVER_ADMIN</td><td>root@localhost</td></tr>
<tr><td>SERVER_NAME</td><td>localhost</td></tr>
<tr><td>SERVER_PORT</td><td>80</td></tr>
<tr><td>SERVER_PROTOCOL</td><td>HTTP/1.1</td></tr>
<tr><td>SERVER_SIGNATURE</td><td></td></tr>
<tr><td>SERVER_SOFTWARE</td><td>Apache/2.4.6 (CentOS)</td></tr>
</table><
</body>
</html>

—————————— GET /POST Method ————————— ON HOLD DUE TO ERROR ——————
You must have come across many situations when you need to pass some information from your browser to web server and ultimately to your CGI Program. Most frequently browser uses two methods to pass this information to web server. The GET method is the default method to pass information from browser to web server and it produces a long string that appears in your browser's Location.


———————————— API Requests using Python ————————— 
//https://www.pythonforbeginners.com/requests/using-requests-in-python
Requests is an Apache2 Licensed HTTP library, written in Python. Requests will allow you to send HTTP/1.1 requests using Python. With it, you can add content like headers, form data, multipart files, and parameters via simple Python libraries. It also allows you to access the response data of Python in the same way.

———————— GET requests using Requests library —

import requests
# api-endpoint
URL = "http://maps.googleapis.com/maps/api/geocode/json"
# location given here
location = "delhi technological university"
# defining a params dict for the parameters to be sent to the API
PARAMS = {'address': location}
# sending get request and saving the response as response object
r = requests.get(url=URL, params=PARAMS)
# extracting data in json format
data = r.json()
print(data)


———————— POST requests using Requests library —

# importing the requests library 
import requests 
# defining the api-endpoint  
API_ENDPOINT = "http://pastebin.com/api/api_post.php"
# your API key here 
API_KEY = "XXXXXXXXXXXXXXXXX"
  
# your source code here 
source_code = ''' 
print("Hello, world!") 
a = 1 
b = 2 
print(a + b) 
'''
  
# data to be sent to api 
data = {'api_dev_key':API_KEY, 
        'api_option':'paste', 
        'api_paste_code':source_code, 
        'api_paste_format':'python'} 
  
# sending post request and saving response as response object 
r = requests.post(url = API_ENDPOINT, data = data) 
  
# extracting response text  
pastebin_url = r.text 
print("The pastebin URL is:%s"%pastebin_url) 

—————————— AD-HOC TOPICS IN C ——————— 

———————— —  NULL TERMINATED CHARACTERS —————————— 
NULL refers to a null pointer constant which you only use for setting a pointer to point at "nothing", an invalid memory location.
Null termination, sometimes spelled "nul" to not confuse it with the above, means putting a zero character '\0' (sometimes called "nul character") at the end of a character array to state where your string ends. It has nothing to do with NULL pointers what so ever. A better name than "null termination" might be zero termination, as that is less confusing.

Use 0 for integers.
Use NULL for pointers.
Use '\0' to terminate a characer array and thereby making it a C string.

—————————— EXECVP FUNCTION ——————— 
The exec family of functions replaces the current running process with a new process. It can be used to run a C program by using another C program. It comes under the header file unistd.h

Syntax — 
int execvp (const char *file, char *const argv[]);

file: points to the file name associated with the file being executed.
argv:  is a null terminated array of character pointers. In example below, We will have two .C files , EXEC.c and execDemo.c and we will replace the execDemo.c with EXEC.c by calling execvp() function in execDemo.c

EXEC.c program — 
#include<stdio.h> 
#include<unistd.h> 
  
int main() 
{ 
    printf("I am EXEC.c called by execvp() "); 
    return 0; 
} 
--—compile this and second program execDemo.c  as below 
#include<stdlib.h> 
#include<unistd.h> 
int main() 
{ 
        char *args[]={"./EXEC",NULL}; 
        execvp(args[0],args);  
    return 0; 
} 
——— output —— 
I am EXEC.c called by execvp() 

—————————— EXECV FUNCTION ——————— 
This is similar function like EXECVP but here we specify path of the file as shown below 

int execv(const char *path, char *const argv[]);

Where path: should point to the path of the file being executed. So same code as earlier EXECVP .. 

        char *args[]={"./EXEC",NULL}; 
        execv(args[0],args);

—————————— EXECLP AND EXECL FUNCTION ——————— 
It serves same purpose as above function with different syntax 

int execlp(const char *file, const char *arg,.../* (char  *) NULL */);
int execl(const char *path, const char *arg,.../* (char  *) NULL */);

Where const char *arg and ellipses : describe a list of one or more pointers to null-terminated strings that represent the argument list available to the executed program.

—————————— EXECVPE AND EXECLE FUNCTION ——————— 

It serves same purpose as above function with different syntax 

int execvpe(const char *file, char *const argv[],char *const envp[]);

int execle(const char *path, const char *arg, .../*, (char *) NULL, 
char * const envp[] */);

Where char * const envp[]: allow the caller to specify the environment of the executed program via the argument envp.
envp:This argument is an array of pointers to null-terminated strings and must be terminated by a null pointer. The other functions take the environment for the new process image from the external variable environ in the calling process.

—————————— CALLING SHELL SCRIPT FROM C ——————— 
#include <stdio.h>
#include <stdlib.h>
#define samplescript "\
#/bin/bash \n\
echo \"hello\" \n\
"

int main() {
    puts("Starting now:");
    system(samplescript);    //it will run the script inside the c code. 
    return 0;
}
——— output ——— 
Starting now:
hello

—————————— NAMESPACE —————————— 

Namespaces allow us to group named entities that otherwise would have global scope into narrower scopes, giving them namespace scope. This allows organizing the elements of programs into different logical scopes referred to by names. Namespace is a feature added in C++ and not present in C. 
 
#include <iostream>
namespace n1 { 
  int i = 20;
}
namespace n2 { 
  double j = 30;
}
int main() { 
  std::cout << n1::i << '\n';
  std::cout << n2::j << '\n';
  return 0;
}

———— output ———  
20 
30

————— NAMESPACE - EXAMPLE 2 - USING CLASS——— 
#include <iostream> 
using namespace std;   
// Creating a namespace 
namespace ns 
{ 
    void display(); 
    class geek 
    { 
    public: 
       void display(); 
    }; 
} 
// Defining methods of namespace 
void ns::geek::display() 
{ 
    cout << "ns::geek::display()\n"; 
} 
void ns::display() 
{ 
    cout << "ns::display()\n"; 
} 
// Driver code 
int main() 
{ 
    ns::geek obj; 
    ns::display(); 
    obj.display(); 
    return 0; 
} 
—————— output —————— 
ns::display()
ns::geek::display()



——————————  PStreams  - POSIX Process Control in C++———http://pstreams.sourceforge.net———— 

PStreams allows you to run another program from your C++ application and to transfer data between the two programs similar to shell pipelines. In the simplest case, a PStreams class is like a C++ wrapper for the POSIX.2 functions popen(3) and pclose(3), using C++ iostreams instead of C's stdio library. The library provides class templates in the style of the standard iostreams that can be used with any ISO C++ compiler on a POSIX platform. The classes use a streambuf class that uses fork(2) and the exec(2) family of functions to create a new process and creates up to three pipes to write/read data to/from the process.










